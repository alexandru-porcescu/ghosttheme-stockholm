{"data":{"ghostPost":{"id":"Ghost__Post__5c85a8da181da30210ceca9d","title":"Serve Docker Containers With A Custom Domain and SSL","slug":"serve-docker-containers-with-custom-dns-and-ssl","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/caddy.jpg","excerpt":"Do even less work to deploy your Docker apps to production.","custom_excerpt":"Do even less work to deploy your Docker apps to production.","created_at_pretty":"11 March, 2019","published_at_pretty":"11 March, 2019","updated_at_pretty":"09 April, 2019","created_at":"2019-03-10T20:16:26.000-04:00","published_at":"2019-03-11T06:15:00.000-04:00","updated_at":"2019-04-09T15:05:49.000-04:00","meta_title":"Serve Docker Containers With A Domain and SSL | Hackers and Slackers","meta_description":"Do even less work to deploy your Docker apps to production. Caddy is a Fast, cross-platform HTTP/2 web server with automatic SSL.","og_description":"Do even less work to deploy your Docker apps to production. Caddy is a Fast, cross-platform HTTP/2 web server with automatic SSL.","og_image":"https://hackersandslackers.com/content/images/2019/03/caddy.jpg","og_title":"Serve Docker Containers With A Custom Domain and SSL","twitter_description":"Do even less work to deploy your Docker apps to production. Caddy is a Fast, cross-platform HTTP/2 web server with automatic SSL.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/caddy.jpg","twitter_title":"Serve Docker Containers With A Custom Domain and SSL","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},"tags":[{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"The past few years of software development and architecture has witnessed\nmultiple revolutions. The rise of containers, unruly package management\necosystems, and one-click-deployments holds an unspoken narrative: most people\nprobably don’t care about how  things work beneath the top layer. Sure,\nadvancements in application infrastructure has undoubtedly made our lives\neasier. I suppose I find this lack of curiosity and unwillingness to dig deeper\ninto the innards, an unrelatable trait. Yet I digress.\n\nI’ve never found web server configurations to be particularly difficult, but\napparently most consider this enough of a nuisance to make something even easier\nto use. That’s where I came across Caddy [https://caddyserver.com/].\n\nCaddy  is a web server and free SSL service in which most of the actual work\nhappens via their download GUI [https://caddyserver.com/download]. It’s great.\nEven though I never expected us to reach a place where apt install nginx  and \napt install certbot  is considered too much of a burden, it only took a few\nminutes of wrestling with a Docker container running on a VPS that I realized\nthere was a better way.\n\nServe Anything With Caddy\nIn my particular example, the Docker container I was running produced an API\nendpoint. For some reason, this service forcefully insists that this endpoint is\nyour machine’s localhost, or it simply won’t work. While scoffing at vanity URLs\nfor APIs is fine, what isn’t  fine is you can’t assign an SSL certificate to an\nIP address. That means whichever app consuming your API will fail because your\napp surely has a cert of its own, and HTTPS > HTTP  API calls just aren’t gonna\nhappen.\n\nCaddy trivializes SSL certs to the point where you might not notice you’ve\nacquired one. Any host specified in a Caddyfile  immediately receives an SSL\ncert, but we'll get to that in a moment.\n\nCaddy’s download page is like a shopping cart for which things you might want\nyour web server to do. Proxies, CORS, you name it: just put it in the (free)\nshopping cart:\n\nSoon we won't even have to write code at all!Selecting your platform, plugins, and license  will provide you with a\nconvenient one-liner which downloads your exact package, unpacks, and installs\nit on your machine. For example, a Caddy installation for Linux with no bells or\nwhistles looks like this:\n\ncurl https://getcaddy.com | bash\n\n\nThis will install Caddy, which leaves only some trivial configuration before\nyou're up and running.\n\nConfiguring Your Caddyfile\nCaddy is configured via what is simply named Caddyfile, a file which can\nconveniently live in your project folder, as opposed to a distant land called \n/etc/nginx/sites-enabled. Go ahead and create your Caddy file.\n\nThe first line in our Caddyfile config is both simple and magic. It contains\nmerely the domain you’re intending to listen on, such something like \nhackersandslackers.com.  No matter what else happens in your config, the mere\nexistence of this line will generate an SSL cert for you when you run caddy.\n\nYou can serve content via any method that Nginx  or Apache  can, albeit much\neasier. A few examples:\n\n * root path/to/project  points your DNS to serve HTTP out a root folder.\n * websocket path/to/socket command  will serve an application via the specified\n   websocket.\n * rewrite [/original/folder/path] [/new/folder/path]  will reroute internal\n   requests made to origin A to origin B,\n\nThe point I’m trying to make here is that no matter what your desired\nconfiguration might be, it’s dead simple and likely won’t exceed more than 5\nlines.\n\nServing Our Docker Container via Proxy\nIf you’re using Node, chances are you’re going for a proxy configuration. In my\ncase I had no choice: I somehow needed to interact with an HTTP  url, while also\npassing the authentication headers necessary to make the app work. Luckily, this\nis trivial:\n\nexample.com\n\nproxy example.com proxy example.com localhost:4466/my_api/prod {\n transparent\n} \n\nerrors proxieserrors.log\n\nYes, really. Our proxy  block simply creates a proxy from  example.com, and\nserves localhost:4466/my_api/prod.\n\ntransparent  is a magic phrase which passes through all our headers to the\ntarget. It's shorthand for the following:\n\nheader_upstream Host {host}\nheader_upstream X-Real-IP {remote}\nheader_upstream X-Forwarded-For {remote}\nheader_upstream X-Forwarded-Port {server_port}\nheader_upstream X-Forwarded-Proto {scheme}\n\nDespite our Docker app requiring an authentication token to work hitting \nexample.com  will still result in a working endpoint thanks to the headers we're\npushing upstream.\n\nI even went the extra mile to include errors proxieserrors.log  as a way to log\nerrors. I didn't even need to. I only even got two errors total: Caddy works\nobnoxiously well.\n\nIn case you need anything more, I’d recommend reading the documentation\n[https://caddyserver.com/docs/proxy]. Even then, this basically summarizes the\nthings you can potentially configure:\n\nproxy from to... {\n\tpolicy name [value]\n\tfail_timeout duration\n\tmax_fails integer\n\tmax_conns in≈teger\n\ttry_duration duration\n\ttry_interval duration\n\thealth_check path\n\thealth_check_port port\n\thealth_check_interval interval_duration\n\thealth_check_timeout timeout_duration\n\tfallback_delay delay_duration\n\theader_upstream name value\n\theader_downstream name value\n\tkeepalive number\n\ttimeout duration\n\twithout prefix\n\texcept ignored_paths...\n\tupstream to\n\tca_certificates certs...\n\tinsecure_skip_verify\n\tpreset\n}\n\nRun Caddy And Never Worry About It Again\nSaving your Caddyfile  and running $ caddy  will issue your cert, and run Caddy\nas a process. This will result in a dialogue letting  you know that Caddy is\nlistening on both ports 80  and 443.\n\nCaddy won’t run as a background process by default. To do this, simply use the\ncommand $ nohup caddy &  and you're good to go.","html":"<p>The past few years of software development and architecture has witnessed multiple revolutions. The rise of containers, unruly package management ecosystems, and one-click-deployments holds an unspoken narrative: most people probably don’t care about <em>how</em> things work beneath the top layer. Sure, advancements in application infrastructure has undoubtedly made our lives easier. I suppose I find this lack of curiosity and unwillingness to dig deeper into the innards, an unrelatable trait. Yet I digress.</p><p>I’ve never found web server configurations to be particularly difficult, but apparently most consider this enough of a nuisance to make something even easier to use. That’s where I came across <a href=\"https://caddyserver.com/\" rel=\"noopener\">Caddy</a>.</p><p><strong>Caddy</strong> is a web server and free SSL service in which most of the actual work happens via their <a href=\"https://caddyserver.com/download\" rel=\"noopener\">download GUI</a>. It’s great. Even though I never expected us to reach a place where <code>apt install nginx</code> and <code>apt install certbot</code> is considered too much of a burden, it only took a few minutes of wrestling with a Docker container running on a VPS that I realized there was a better way.</p><h2 id=\"serve-anything-with-caddy\">Serve Anything With Caddy</h2><p>In my particular example, the Docker container I was running produced an API endpoint. For some reason, this service forcefully insists that this endpoint is your machine’s <em>localhost</em>, or it simply won’t work. While scoffing at vanity URLs for APIs is fine, what <em>isn’t</em> fine is <em>you can’t assign an SSL certificate to an IP address. </em>That means whichever app consuming your API will fail because your app <em>surely </em>has a cert of its own, and <strong>HTTPS &gt; HTTP</strong> API calls just aren’t gonna happen.</p><p>Caddy trivializes SSL certs to the point where you might not notice you’ve acquired one. Any host specified in a <code>Caddyfile</code> immediately receives an SSL cert, but we'll get to that in a moment.</p><p>Caddy’s download page is like a shopping cart for which things you might want your web server to do. Proxies, CORS, you name it: just put it in the (free) shopping cart:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/caddy-download.png\" class=\"kg-image\"><figcaption>Soon we won't even have to write code at all!</figcaption></figure><!--kg-card-end: image--><p>Selecting your <strong>platform</strong>, <strong>plugins</strong>, and <strong>license</strong> will provide you with a convenient one-liner which downloads your exact package, unpacks, and installs it on your machine. For example, a Caddy installation for Linux with no bells or whistles looks like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">curl https://getcaddy.com | bash\n</code></pre>\n<!--kg-card-end: markdown--><p>This will install Caddy, which leaves only some trivial configuration before you're up and running.</p><h2 id=\"configuring-your-caddyfile\">Configuring Your Caddyfile</h2><p>Caddy is configured via what is simply named <code>Caddyfile</code>, a file which can conveniently live in your project folder, as opposed to a distant land called <code>/etc/nginx/sites-enabled</code>. Go ahead and create your Caddy file.</p><p>The first line in our Caddyfile config is both simple and magic. It contains merely the domain you’re intending to listen on, such something like <em>hackersandslackers.com.</em> No matter what else happens in your config, the mere existence of this line will generate an SSL cert for you when you run caddy.</p><p>You can serve content via any method that <strong>Nginx</strong> or <strong>Apache</strong> can, albeit much easier. A few examples:</p><ul><li><code>root path/to/project</code> points your DNS to serve HTTP out a root folder.</li><li><code>websocket path/to/socket command</code> will serve an application via the specified websocket.</li><li><code>rewrite [/original/folder/path] [/new/folder/path]</code> will reroute internal requests made to origin A to origin B,</li></ul><p>The point I’m trying to make here is that no matter what your desired configuration might be, it’s dead simple and likely won’t exceed more than 5 lines.</p><h2 id=\"serving-our-docker-container-via-proxy\">Serving Our Docker Container via Proxy</h2><p>If you’re using Node, chances are you’re going for a proxy configuration. In my case I had no choice: I somehow needed to interact with an <strong>HTTP</strong> url, while also passing the authentication headers necessary to make the app work. Luckily, this is trivial:</p><!--kg-card-begin: code--><pre><code>example.com\n\nproxy example.com proxy example.com localhost:4466/my_api/prod {\n transparent\n} \n\nerrors proxieserrors.log</code></pre><!--kg-card-end: code--><p>Yes, really. Our <code>proxy</code> block simply creates a proxy <em>from</em> <code>example.com</code>, and serves <code>localhost:4466/my_api/prod</code>.</p><p><code>transparent</code> is a magic phrase which passes through all our headers to the target. It's shorthand for the following:</p><!--kg-card-begin: code--><pre><code>header_upstream Host {host}\nheader_upstream X-Real-IP {remote}\nheader_upstream X-Forwarded-For {remote}\nheader_upstream X-Forwarded-Port {server_port}\nheader_upstream X-Forwarded-Proto {scheme}</code></pre><!--kg-card-end: code--><p>Despite our Docker app requiring an authentication token to work hitting <code>example.com</code> will still result in a working endpoint thanks to the headers we're pushing upstream.</p><p>I even went the extra mile to include <code>errors proxieserrors.log</code> as a way to log errors. I didn't even need to. I only even got two errors total: Caddy works obnoxiously well.</p><p>In case you need anything more, I’d recommend reading <a href=\"https://caddyserver.com/docs/proxy\" rel=\"noopener\">the documentation</a>. Even then, this basically summarizes the things you can potentially configure:</p><!--kg-card-begin: code--><pre><code>proxy from to... {\n\tpolicy name [value]\n\tfail_timeout duration\n\tmax_fails integer\n\tmax_conns in≈teger\n\ttry_duration duration\n\ttry_interval duration\n\thealth_check path\n\thealth_check_port port\n\thealth_check_interval interval_duration\n\thealth_check_timeout timeout_duration\n\tfallback_delay delay_duration\n\theader_upstream name value\n\theader_downstream name value\n\tkeepalive number\n\ttimeout duration\n\twithout prefix\n\texcept ignored_paths...\n\tupstream to\n\tca_certificates certs...\n\tinsecure_skip_verify\n\tpreset\n}</code></pre><!--kg-card-end: code--><h2 id=\"run-caddy-and-never-worry-about-it-again\">Run Caddy And Never Worry About It Again</h2><p>Saving your <code>Caddyfile</code> and running <code>$ caddy</code> will issue your cert, and run Caddy as a process. This will result in a dialogue letting  you know that Caddy is listening on both ports <code>80</code> and <code>443</code>.</p><p>Caddy won’t run as a background process by default. To do this, simply use the command <code>$ nohup caddy &amp;</code> and you're good to go.</p>","url":"https://hackersandslackers.com/serve-docker-containers-with-custom-dns-and-ssl/","uuid":"5b609f96-d76d-4b8b-943e-d470ee414d97","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c85a8da181da30210ceca9d"}},"pageContext":{"slug":"serve-docker-containers-with-custom-dns-and-ssl"}}