{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673637","title":"Managing Python Environments With Virtualenv","slug":"managing-python-environments","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/04/virtualenv.jpg","excerpt":"Working with virtualenv and virtualenvwrapper.","custom_excerpt":"Working with virtualenv and virtualenvwrapper.","created_at_pretty":"12 April, 2018","published_at_pretty":"15 November, 2017","updated_at_pretty":"10 April, 2019","created_at":"2018-04-12T17:49:21.000-04:00","published_at":"2017-11-15T17:48:00.000-05:00","updated_at":"2019-04-09T21:05:13.000-04:00","meta_title":"Managing Python Environments | Hackers and Slackers","meta_description":"Keep your Python environments separate with virtualenv and virtualenvwrapper.","og_description":"Keep your Python environments separate with virtualenv and virtualenvwrapper.","og_image":"https://hackersandslackers.com/content/images/2019/04/virtualenv-2.jpg","og_title":"Managing Python Environments With Virtualenv","twitter_description":"Keep your Python environments separate with virtualenv and virtualenvwrapper.","twitter_image":"https://hackersandslackers.com/content/images/2019/04/virtualenv-1.jpg","twitter_title":"Managing Python Environments With Virtualenv","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"As with any programming language, Python uses package managers (pip  in this\ncase) to manage the addition of libraries to be called at runtime. By default,\ninstalling a Python library with pip  will install that package to the default \nPython path,  which is the default folder from which Python stores its installed\npackages. For reference, you can determine you Python path via the following in\nthe Python shell:\n\nimport sys\nprint(sys.path)\n\n['', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload', '/Library/Python/2.7/site-packages', '/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python', '/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC']\n\n\nWithout any other specification, Python will always look in the Python path at\nruntime to locate and execute any packages imported by a script. For example,\nlet's say I were to run a script called myscript.py  which attempts to import\nthe 'requests' library, as such:\n\n# myscript.py\nimport requests\n\n\nRunning python myscript.py  in your terminal will attempt to look for the\nlibrary in your generic python path.\n\nEnvironments With Virtualenv\nWhile keeping all your Python packages in one place may be nice at first, this\nbecomes an unmanageable problem when you suddenly find yourself managing\nmultiple projects, each of which may contain different libraries and versions of\nsuch libraries. As such, it is best practice to always encapsulate the library\ndependancies of a project by utilizing one of python's environment manages, such\nas virtualenv.\n\nVirtualenv is the oldest and most common method for managing Python\nenvironments. Creating an environment with virtualenv will create a folder in\nthe user's current directory. This folder represents an environment which can\nthen be 'activated.' This is a way of explicitly using the new environment\ndirectory in place of PYTHONPATH to handle Python packages. As such, we can\ncreate as many environments as we want without worrying about package conflicts.\n\nINSTALLATION\nInstall virtualenv via the following:\n\n$ pip3 install virtualenv\n\n\nWith virtualenv installed, we can then create the environment. cd to the\ndirectory of your choice (preferably the one which you're planning to hold your\nproject) and create an environment with the name of your choice:\n\n$ virtualenv myenv\n\nUsing base prefix '/usr/local/Cellar/python/3.6.4_4/Frameworks/Python.framework/Versions/3.6'\nNew python executable in /Users/toddbirchard/myenv/bin/python3.6\nAlso creating executable in /Users/toddbirchard/myenv/bin/python\nInstalling setuptools, pip, wheel...done.\n\n\nA folder should now have been created in the current directory. That folder is\nthe new home of your virtual environment; every time you install a Python\npackage with the environment active, that package will be saved to the directory\nof said environment (as opposed to saved on your machine's Python path).\n\nACTIVATION\nNow that the environment has been created, it must be 'activated'.\n\n$ source myenv/bin/activate\n\n\nYou should notice in the terminal that once this is activated, the command line\nwill always state that the user is working out of the activated environment\nuntil otherwise changed.\n\nAlternative Methods of Virtual Environment Management","html":"<p>As with any programming language, Python uses package managers (<em>pip</em> in this case) to manage the addition of libraries to be called at runtime. By default, installing a Python library with <em>pip</em> will install that package to the default <em>Python path,</em> which is the default folder from which Python stores its installed packages. For reference, you can determine you Python path via the following in the Python shell:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import sys\nprint(sys.path)\n\n['', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload', '/Library/Python/2.7/site-packages', '/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python', '/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC']\n</code></pre>\n<!--kg-card-end: markdown--><p>Without any other specification, Python will always look in the Python path at runtime to locate and execute any packages imported by a script. For example, let's say I were to run a script called <code>myscript.py</code> which attempts to import the 'requests' library, as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># myscript.py\nimport requests\n</code></pre>\n<!--kg-card-end: markdown--><p>Running <code>python myscript.py</code> in your terminal will attempt to look for the library in your generic python path.</p><h2 id=\"environments-with-virtualenv\">Environments With Virtualenv</h2><p>While keeping all your Python packages in one place may be nice at first, this becomes an unmanageable problem when you suddenly find yourself managing multiple projects, each of which may contain different libraries and versions of such libraries. As such, it is best practice to always encapsulate the library dependancies of a project by utilizing one of python's environment manages, such as <strong>virtualenv</strong>.</p><p>Virtualenv is the oldest and most common method for managing Python environments. Creating an environment with virtualenv will create a folder in the user's current directory. This folder represents an environment which can then be 'activated.' This is a way of explicitly using the new environment directory in place of PYTHONPATH to handle Python packages. As such, we can create as many environments as we want without worrying about package conflicts.</p><h3 id=\"installation\">INSTALLATION</h3><p>Install virtualenv via the following:</p><!--kg-card-begin: markdown--><pre><code>$ pip3 install virtualenv\n</code></pre>\n<!--kg-card-end: markdown--><p>With virtualenv installed, we can then create the environment. cd to the directory of your choice (preferably the one which you're planning to hold your project) and create an environment with the name of your choice:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">$ virtualenv myenv\n\nUsing base prefix '/usr/local/Cellar/python/3.6.4_4/Frameworks/Python.framework/Versions/3.6'\nNew python executable in /Users/toddbirchard/myenv/bin/python3.6\nAlso creating executable in /Users/toddbirchard/myenv/bin/python\nInstalling setuptools, pip, wheel...done.\n</code></pre>\n<!--kg-card-end: markdown--><p>A folder should now have been created in the current directory. That folder is the new home of your virtual environment; every time you install a Python package with the environment active, that package will be saved to the directory of said environment (as opposed to saved on your machine's Python path).</p><h3 id=\"activation\">ACTIVATION</h3><p>Now that the environment has been created, it must be 'activated'.</p><!--kg-card-begin: markdown--><pre><code>$ source myenv/bin/activate\n</code></pre>\n<!--kg-card-end: markdown--><p>You should notice in the terminal that once this is activated, the command line will always state that the user is working out of the activated environment until otherwise changed.</p><h2 id=\"alternative-methods-of-virtual-environment-management\">Alternative Methods of Virtual Environment Management</h2>","url":"https://hackersandslackers.com/managing-python-environments/","uuid":"e5af4c12-7a41-4152-970f-63f20b8b2fde","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5acfd461583e28622a7833f9"}},"pageContext":{"slug":"managing-python-environments"}}