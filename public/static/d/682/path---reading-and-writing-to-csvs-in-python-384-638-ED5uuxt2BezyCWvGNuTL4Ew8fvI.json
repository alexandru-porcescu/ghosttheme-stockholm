{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673718","title":"Reading and Writing to CSVs in Python","slug":"reading-and-writing-to-csvs-in-python","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/09/csvpython2@2x.jpg","excerpt":"Playing with tabular data the native Python way.","custom_excerpt":"Playing with tabular data the native Python way.","created_at_pretty":"27 September, 2018","published_at_pretty":"27 September, 2018","updated_at_pretty":"05 November, 2018","created_at":"2018-09-27T13:22:47.000-04:00","published_at":"2018-09-27T18:35:00.000-04:00","updated_at":"2018-11-05T07:55:10.000-05:00","meta_title":"Reading and Writing to CSVs in Python | Hackers and Slackers","meta_description":"Using native Python libraries to interact with tabular data. Pandas not included.\n\n\n\n\n\n\n\n\nar \n\n","og_description":"Using native Python libraries to interact with tabular data. Pandas not included.","og_image":"https://hackersandslackers.com/content/images/2018/09/csvpython2@2x.jpg","og_title":"Reading and Writing to CSVs in Python | Hackers and Slackers","twitter_description":"Using native Python libraries to interact with tabular data. Pandas not included.","twitter_image":"https://hackersandslackers.com/content/images/2018/09/csvpython2@2x.jpg","twitter_title":"Reading and Writing to CSVs in Python | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"Tables. Cells. Two-dimensional data. We here at Hackers & Slackers know how to\ntalk dirty, but there's one word we'll be missing from our vocabulary today:\nPandas.Before the remaining audience closes their browser windows in fury, hear\nme out. We love Pandas; so much so that tend to recklessly gunsling this 30mb\nlibrary to perform simple tasks. This isn't always a wise choice. I get it:\nyou're here for data, not software engineering best practices. We all are, but\nin a landscape where engineers and scientists already produce polarizing code\nquality, we're all just a single bloated lambda function away from looking like\n idiots and taking a hit to our credibility. This is a silly predicament when\nthere are plenty of built-in Python libraries at our disposable which work\nperfectly fine. Python’s built in CSV library can cover quite a bit of data\nmanipulation use cases to achieve the same results of large scientific libraries\njust as easily.\n\nBasic CSV Interaction\nRegardless of whether you're reading or writing to CSVs, there are a couple\nlines of code which will stay mostly the same between the two. \n\n# read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n     reader = csv.reader(myCsvFile, delimiter=',', quotechar='|')\n\nBefore accomplishing anything, we've stated some critical things in these two\nlines of code:\n\n * All interactions with our CSV will only be valid as long as they live within\n   the with.open  block (comparable to managing database connections).\n * We'll be interacting with a file in our directory called hackers.csv, for\n   which we only need read (or r) permissions\n * We create a reader  object, which is again comparable to managing database \n   cursors  if you're familiar.\n * We have the ability to set the delimiter of our CSV (a curious feature,\n   considering the meaning of C  in the acronym CSV.\n\nIterating Rows\nAn obvious use case you probably have in mind would be to loop through each row\nto see what sort of values we're dealing with. Your first inclination might be\nto do something like this:\n\n# read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.reader(myCsvFile, delimiter=',', quotechar='|')\n\tfor row in reader.readlines():\n\t\tprint('row = ', row)\n\nThat's fine and all, but row  in this case returns a simple list - this is\nobviously problem if you want to access the values of certain columns by column \nname,  as opposed to numeric index (I bet you do). Well, we've got you covered:\n\n# read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.DictReader(myCsvFile)\n\tfor row in reader.readlines():\n\t\tprint(row['column_name_1'], row['column_name_2'])\n\nChanging reader  to DictReader  outputs a dictionary  per CSV row, as opposed to\na simple list. Are things starting to feel a little Panda-like yet?\n\nBonus: Printing all Keys and Their Values\nLet's get a little weird just for fun. Since our rows are dict objects now, we\ncan print our entire CSV as a series of dicts like so:\n\n# read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.DictReader(myCsvFile)\n\tfor row in loc_reader:\n            for (k, v) in row.items():\n\t\t\t\tprint(k, ':', v)\n\nSkipping Headers\nAs we read information from CSVs to be repurposed for, say, API calls, we \nprobably  don't want to iterate over the first row of our CSV: this will output\nour key values alone, which would be useless in this context. Consider this:\n\n# read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r') as myCsvFile:\n\tnext(myCsvFile)\n\tfor row in myCsvFile.readlines():\n\t\tprint(row)\n\nWhoa! A different approach.... but somehow just as simple? In this case, we\nleave out reader  altogether (which still works!) but more importantly, we\nintroduce next(). next(myCsvFile)  immediately skips to the next line in a CSV,\nso in our case, we simply skip line one before going into our For loop. Amazing.\n\nWriting to CSVs\nWriting to CSVs isn't much different than reading from them. In fact, almost all\nthe same principles apply, where instances of the word \"read\" are more or less\nreplaced with\" write. Huh. \n\n# write_csv.py\nimport csv\n\nwith open('hackers.csv', 'w') as myCsvFile:\n    columns = ['column_name_1', 'column_name_2']\n    writer = csv.DictWriter(myCsvFile, fieldnames=columns)\n\n    writer.writeheader()\n    writer.writerow({'column_name_1': 'Mark', 'column_name_2': 'Twain'})\n    writer.writerow({'column_name_1': 'Foo', 'column_name_2: 'Bar'})\n\nWe're writing a brand new CSV here: 'hackers.csv' doesn't technically exist yet,\nbut that doesn't stop Python from not giving a shit. Python knows what you mean.\nPython has your back.\n\nHere, we set our headers as a fixed list set by the column  variable. This is a\nstatic way of creating headers, but the same can be done dynamically by passing\nthe keys  of a dict, or whatever it is you like to do. \n\nwriter.writeheader()  knows what we're saying thanks to the aforementioned \nfieldnames  we passed to our writer earlier. Good for you, writer.\n\nBut how do we write rows, you might ask? Why, with writer.writerow(), of course!\nBecause we use DictWriter  similarly to how we used DictReader  earlier, we can\nmap values to our CSV with simple column references. Easy.","html":"<p>Tables. Cells. Two-dimensional data. We here at Hackers &amp; Slackers know how to talk dirty, but there's one word we'll be missing from our vocabulary today: Pandas.Before the remaining audience closes their browser windows in fury, hear me out. We love Pandas; so much so that tend to recklessly gunsling this 30mb library to perform simple tasks. This isn't always a wise choice. I get it: you're here for data, not software engineering best practices. We all are, but in a landscape where engineers and scientists already produce polarizing code quality, we're all just a single bloated lambda function away from looking like  idiots and taking a hit to our credibility. This is a silly predicament when there are plenty of built-in Python libraries at our disposable which work perfectly fine. Python’s built in CSV library can cover quite a bit of data manipulation use cases to achieve the same results of large scientific libraries just as easily.</p><h2 id=\"basic-csv-interaction\">Basic CSV Interaction</h2><p>Regardless of whether you're reading or writing to CSVs, there are a couple lines of code which will stay mostly the same between the two. </p><pre><code># read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n     reader = csv.reader(myCsvFile, delimiter=',', quotechar='|')</code></pre><p>Before accomplishing anything, we've stated some critical things in these two lines of code:</p><ul><li>All interactions with our CSV will only be valid as long as they live within the <code>with.open</code> block (comparable to managing database connections).</li><li>We'll be interacting with a file in our directory called <code>hackers.csv</code>, for which we only need read (or <code>r</code>) permissions</li><li>We create a <code>reader</code> object, which is again comparable to managing database <code>cursors</code> if you're familiar.</li><li>We have the ability to set the delimiter of our CSV (a curious feature, considering the meaning of <strong>C</strong> in the acronym <strong>CSV.</strong></li></ul><h3 id=\"iterating-rows\">Iterating Rows</h3><p>An obvious use case you probably have in mind would be to loop through each row to see what sort of values we're dealing with. Your first inclination might be to do something like this:</p><pre><code># read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.reader(myCsvFile, delimiter=',', quotechar='|')\n\tfor row in reader.readlines():\n\t\tprint('row = ', row)</code></pre><p>That's fine and all, but <code>row</code> in this case returns a simple list - this is obviously problem if you want to access the values of certain columns by column <em>name,</em> as opposed to <em>numeric index </em>(I bet you do). Well, we've got you covered:</p><pre><code># read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.DictReader(myCsvFile)\n\tfor row in reader.readlines():\n\t\tprint(row['column_name_1'], row['column_name_2'])</code></pre><p>Changing <code>reader</code> to <code>DictReader</code> outputs a <em>dictionary</em> per CSV row, as opposed to a simple list. Are things starting to feel a little Panda-like yet?</p><h4 id=\"bonus-printing-all-keys-and-their-values\">Bonus: Printing all Keys and Their Values</h4><p>Let's get a little weird just for fun. Since our rows are dict objects now, we can print our entire CSV as a series of dicts like so:</p><pre><code># read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r', newline='') as myCsvFile:\n    reader = csv.DictReader(myCsvFile)\n\tfor row in loc_reader:\n            for (k, v) in row.items():\n\t\t\t\tprint(k, ':', v)</code></pre><h3 id=\"skipping-headers\">Skipping Headers</h3><p>As we read information from CSVs to be repurposed for, say, API calls, we <em>probably</em> don't want to iterate over the first row of our CSV: this will output our key values alone, which would be useless in this context. Consider this:</p><pre><code># read_csv.py\nimport csv\n\nwith open('hackers.csv', 'r') as myCsvFile:\n\tnext(myCsvFile)\n\tfor row in myCsvFile.readlines():\n\t\tprint(row)</code></pre><p>Whoa! A different approach.... but somehow just as simple? In this case, we leave out <code>reader</code> altogether (which still works!) but more importantly, we introduce <code>next()</code>. <code>next(myCsvFile)</code> immediately skips to the next line in a CSV, so in our case, we simply skip line one before going into our For loop. Amazing.</p><h2 id=\"writing-to-csvs\">Writing to CSVs</h2><p>Writing to CSVs isn't much different than reading from them. In fact, almost all the same principles apply, where instances of the word \"read\" are more or less replaced with\" write. Huh. </p><pre><code># write_csv.py\nimport csv\n\nwith open('hackers.csv', 'w') as myCsvFile:\n    columns = ['column_name_1', 'column_name_2']\n    writer = csv.DictWriter(myCsvFile, fieldnames=columns)\n\n    writer.writeheader()\n    writer.writerow({'column_name_1': 'Mark', 'column_name_2': 'Twain'})\n    writer.writerow({'column_name_1': 'Foo', 'column_name_2: 'Bar'})</code></pre><p>We're writing a brand new CSV here: 'hackers.csv' doesn't technically exist yet, but that doesn't stop Python from not giving a shit. Python knows what you mean. Python has your back.</p><p>Here, we set our headers as a fixed list set by the <code>column</code> variable. This is a static way of creating headers, but the same can be done dynamically by passing the <code>keys</code> of a dict, or whatever it is you like to do. </p><p><code>writer.writeheader()</code> knows what we're saying thanks to the aforementioned <code>fieldnames</code> we passed to our writer earlier. Good for you, writer.</p><p>But how do we write rows, you might ask? Why, with <code>writer.writerow()</code>, of course! Because we use <code>DictWriter</code> similarly to how we used <code>DictReader</code> earlier, we can map values to our CSV with simple column references. Easy.</p>","url":"https://hackersandslackers.com/reading-and-writing-to-csvs-in-python/","uuid":"eb4f019f-e135-49d2-a568-f03f1e622d62","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5bad11e75ee4c83af27dda9e"}},"pageContext":{"slug":"reading-and-writing-to-csvs-in-python"}}