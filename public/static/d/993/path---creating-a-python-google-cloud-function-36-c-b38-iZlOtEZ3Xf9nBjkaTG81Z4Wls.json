{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb867372d","title":"Working With Google Cloud Functions","slug":"creating-a-python-google-cloud-function","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/10/googlefunc-1@2x.jpg","excerpt":"GCP scores a victory by trivializing serverless functions.","custom_excerpt":"GCP scores a victory by trivializing serverless functions.","created_at_pretty":"18 October, 2018","published_at_pretty":"19 October, 2018","updated_at_pretty":"14 April, 2019","created_at":"2018-10-18T19:44:02.000-04:00","published_at":"2018-10-18T22:33:07.000-04:00","updated_at":"2019-04-14T07:24:50.000-04:00","meta_title":"Creating Google Cloud Functions Running Python | Hackers and Slackers","meta_description":"Create serverless functions using Google Cloud's Cloud Functions and Source Repositories. Set up a CRON job to run your function with Cloud Scheduler.","og_description":"Create serverless functions using Google Cloud's Cloud Functions and Source Repositories. ","og_image":"https://hackersandslackers.com/content/images/2018/10/googlefunc-1@2x.jpg","og_title":"Creating Google Cloud Functions Running Python | Hackers and Slackers","twitter_description":"Create serverless functions using Google Cloud's Cloud Functions and Source Repositories. ","twitter_image":"https://hackersandslackers.com/content/images/2018/10/googlefunc-1@2x.jpg","twitter_title":"Creating Google Cloud Functions Running Python | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Google Cloud","slug":"googlecloud","description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/googleseries2.jpg","meta_description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","meta_title":"The Rise of Google Cloud | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Google Cloud","slug":"googlecloud","description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/googleseries2.jpg","meta_description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","meta_title":"The Rise of Google Cloud | Hackers and Slackers","visibility":"public"},{"name":"Architecture","slug":"architecture","description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to Lambda functions, Docker containers, Google Cloud functions,  Kubernetes, Heroku, etc.","feature_image":null,"meta_description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to cloud functions, Docker containers, Kubernetes, Heroku, etc.","meta_title":"Software Architecture | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#The Rise of Google Cloud","slug":"the-rise-of-google-cloud","description":"Build robust serverless architecture on Google Cloud Platform. Learn through tutorials, make comparisons, and hear opinions on GCP as a whole.","feature_image":"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/ADF7E324-9EAD-4F15-8670-AF205E6804EA.png","meta_description":"Build robust serverless architecture on Google Cloud Platform. Learn through tutorials, make comparisons, and hear opinions on GCP as a whole.","meta_title":"The Rise of Google Cloud","visibility":"internal"}],"plaintext":"The more I explore Google Cloud's endless catalog of cloud services, the more I\nlike Google Cloud. This is why before moving forward, I'd like to be transparent\nthat this blog has become little more than thinly veiled Google propaganda,\nwhere I will henceforth bombard you with persuasive and subtle messaging to sell\nyour soul to Google. Let's be honest; they've probably simulated it anyway.\n\nIt should be safe to assume that you're familiar with AWS Lambda Functions\n[https://hackersandslackers.com/creating-endpoints-with-lambda/]  by now, which\nhave served as the backbone of what we refer to as \"serverless.\" These cloud\ncode snippets have restructured entire technology departments, and are partially\nto blame for why almost nobody knows enough basic Linux to configure a web\nserver or build anything without a vendor. Google Cloud Functions don't yet\nserve all the use cases that Lambda functions cover, but for the cases they do\ncover, they seem to be taking the lead.\n\nLambdas vs Cloud Functions\nFirst off, let's talk about a big one: price. AWS charges based on Lambda usage,\nwhereas Google Cloud Functions are free. The only exception to this is when you\nbreak 2 million invocations/month, at which point you'll be hemorrhaging as\nghastly 40 cents per additional million. That's ridiculous. I think we've just\ndiscovered Google Cloud's lead generation strategy.\n\nWhat about in terms of workflow? AWS holds an architecture philosophy of\nchaining services together, into what inevitably becomes a web of self-contained\nbillable items on your invoice. An excellent illustration of this is a  post on \ncommon AWS patterns\n[https://www.jeremydaly.com/serverless-microservice-patterns-for-aws/]  which\nprovides a decent visual of this complexity, while also revealing how much\npeople love this kind of stuff, as though SaaS is the new Legos. To interact\nwith a Lambda function in AWS via HTTP requests, you need to set up an API\nGateway in front, which is arguably a feat more convoluted and complicated than\ncoding. Pair this with an inevitable user permission struggle to get the right\nLambda roles set up, and you quickly have yourself a nightmare- especially  if\nyou're trying to get a single function live. Eventually, you’ll get to write\nsome code or upload a horrendous zip file like some neanderthal (friendly\nreminder: I am entirely biased).\n\nCloud Functions do have their drawbacks in this comparison. Firstly, we cannot\nbuild APIs with Cloud Functions- in fact, without Firebase, we can't even use\nvanity URLs. \n\nAnother huge drawback is Cloud Functions cannot communicate with Google's\nrelational database offering, Cloud SQL. This is big, and what's worse, it feels\nlike an oversight. There are no technical constraints behind this, other than\nGoogle hasn't created an interface to whitelist anything other than IP addresses\nfor Cloud SQL instances.\n\nLastly, we cannot create a fully-fledged API available to be sold or\ndistributed. The is currently no Google Cloud API Gateway equivalent.\n\nDeploying a Cloud Function\nBy the end of this tutorial we'll have utilized the following Google Cloud\nservices/tools:\n\n * A new Google Cloud Function\n * A Google  Source Repository to sync to our Github repo and auto-deploy\n   changes.\n * A CRON job to run our function on a schedule, via Google Cloud Scheduler.\n * The gcloud  CLI to enable us to work locally.\n\nYou'll notice we lack any mentions of API endpoints, methods, stages, or\nanything related to handling web requests. It should not be understated that \nCloud Functions are preconfigured with an endpoint, and all nonsense regarding\nwhether endpoints accept GET or POST or AUTH or OPTIONs is missing entirely.\nThese things are instead handled in the  logic of the function itself, and\nbecause Google Cloud functions running Python are preconfigured with Flask, all\nof that stuff is really trivially easy.  That's right, we've got Flask, Python, \n and GCP  all in a single post. Typing these words feels like eating cake while\nDwyane The Rock Johnson reads me bedtime stories and caresses me as I fall\nasleep. It's great.\n\nIn the Cloud console, go ahead and create a new function. Our function will take\nthe form of an HTTP endpoint:\n\nSingle-page setup. Easy. * Memory Allocated lets us allocate more than the default 256MB to our\n   function. Remember that Cloud functions are free: choose accordingly.\n * Trigger  specifies what will have access to this function. By selecting HTTP,\n   we will immediately receive a URL.\n * Source code  gives us a few options to deploy our code, with cloud source\n   repository  being by far the easiest solution (more on that in a bit).\n * Runtime  allows you to select NodeJS by accident.\n * Function to Execute  needs the name of our entry point function, which is to\n   be found in main.py  or main.js  depending on which language you’ve selected.\n\nIf you're familiar with Lambda functions, the choices of an inline code editor\nor a zip file upload should come as no surprise. Since you're already familiar,\nI don't need to tell you why these methods suck  for any sane workflow. Luckily,\nwe have a better option: syncing our Github repo to a Google Source Repository.\n\nGoogle Source Repositories\nGoogle Source Repositories are repos that function just like Github or Bitbucket\nrepos. They're especially useful for syncing code changes from a Github repo,\nand setting up automatic deployments on commit.\n\nThe Google Source Repositories HomeSetting up this sync is super easy. Create a\nnew repository, specify that we're connecting an external Github repo, and we'll\nbe able to select any repo in our account via the GUI:\n\nSyncing a Github RepoNow when we go back to our editing our function, setting\nthe Source code  field to the name of this new repository will automatically\ndeploy the function whenever a change is committed. With this method, we have\neffectively zero changes to our normal workflow.\n\nCommit to Google Source Repositories Directly\nIf you don't want to sync a Github repo, no problem. We can create a repo\nlocally using the gcloud CLI:\n\n$ gcloud source repos create real-repo\n$ cd myproject/\n$ git init\n--------------------------------------------------------\n(take a moment to write or save some actual code here)\n--------------------------------------------------------\n$ git add --all\n$ git remote add google https://source.developers.google.com/p/hackers/r/real-repo\n$ git commit -m 'cheesey init message'\n$ git push --all google\n\n\nNow make that puppy go live with gcloud functions deploy totally-dope-function,\nwhere totally-dope-function  is the name of your function, as it should be.\n\nWith our function set up and method in place for deploying code, we can now see\nhow our Cloud Function is doing.\n\nViewing Error Logs\nBecause we have a real endpoint to work with, we don't need to waste any time\ncreating dumb unit tests where we send fake JSON to our function (real talk\nthough, we should always write unit tests).\n\nThe Cloud Function error log screen does a decent job of providing us with a GUI\nto see how our deployed function is running, and where things have gone wrong:\n\nOrange Exclamation Marks Denote ErrorsFiring Our Function on a Schedule\nLet's say our function is a job we're looking to run daily, or perhaps hourly.\nGoogle Cloud Scheduler is a super easy way to trigger functions via CRON.\n\nHow is this free again?The easiest way to handle this is by creating our\nfunction as an HTTP endpoint back when we started. A Cloud Scheduler  job can\nhit this endpoint at any time interval we want - just make sure you wrote your\nendpoint to handle GET requests.\n\nCloud Functions in Short\nGCP seems to have been taking notes on the sidelines on how to improve this\nprocess by removing red-tape around service setup or policy configuration. AWS\nand GCP are tackling opposites approaches; AWS allows you to build a Robust API\ncomplete with staging and testing with the intent that some of these APIs can\neven be sold as standalone products to consumers. GCP takes the opposite\napproach: cloud functions are services intended for developers to develop. That\nshould probably cover the vast majority of use cases anyway.","html":"<p>The more I explore Google Cloud's endless catalog of cloud services, the more I like Google Cloud. This is why before moving forward, I'd like to be transparent that this blog has become little more than thinly veiled Google propaganda, where I will henceforth bombard you with persuasive and subtle messaging to sell your soul to Google. Let's be honest; they've probably simulated it anyway.</p><p>It should be safe to assume that you're familiar with AWS <a href=\"https://hackersandslackers.com/creating-endpoints-with-lambda/\">Lambda Functions</a> by now, which have served as the backbone of what we refer to as \"serverless.\" These cloud code snippets have restructured entire technology departments, and are partially to blame for why almost nobody knows enough basic Linux to configure a web server or build anything without a vendor. Google Cloud Functions don't yet serve all the use cases that Lambda functions cover, but for the cases they do cover, they seem to be taking the lead.</p><h2 id=\"lambdas-vs-cloud-functions\">Lambdas vs Cloud Functions</h2><p>First off, let's talk about a big one: price. AWS charges based on Lambda usage, whereas Google Cloud Functions are <strong>free</strong>. The only exception to this is when you break 2 million invocations/month, at which point you'll be hemorrhaging as ghastly <strong>40 cents per additional million</strong>. That's ridiculous. I think we've just discovered Google Cloud's lead generation strategy.</p><p>What about in terms of workflow? AWS holds an architecture philosophy of chaining services together, into what inevitably becomes a web of self-contained billable items on your invoice. An excellent illustration of this is a  post on <a href=\"https://www.jeremydaly.com/serverless-microservice-patterns-for-aws/\">common AWS patterns</a> which provides a decent visual of this complexity, while also revealing how much people love this kind of stuff, as though SaaS is the new Legos. To interact with a Lambda function in AWS via HTTP requests, you need to set up an API Gateway in front, which is arguably a feat more convoluted and complicated than coding. Pair this with an inevitable user permission struggle to get the right Lambda roles set up, and you quickly have yourself a nightmare- <em>especially</em> if you're trying to get a single function live. Eventually, you’ll get to write some code or upload a horrendous zip file like some neanderthal (friendly reminder: I am entirely biased).</p><p>Cloud Functions do have their drawbacks in this comparison. Firstly, we cannot build APIs with Cloud Functions- in fact, without Firebase, we can't even use vanity URLs. </p><p>Another huge drawback is Cloud Functions cannot communicate with Google's relational database offering, Cloud SQL. This is big, and what's worse, it feels like an oversight. There are no technical constraints behind this, other than Google hasn't created an interface to whitelist anything other than IP addresses for Cloud SQL instances.</p><p>Lastly, we cannot create a fully-fledged API available to be sold or distributed. The is currently no Google Cloud API Gateway equivalent.</p><h2 id=\"deploying-a-cloud-function\">Deploying a Cloud Function</h2><p>By the end of this tutorial we'll have utilized the following Google Cloud services/tools:</p><ul><li>A new <strong>Google Cloud Function</strong></li><li>A <strong>Google</strong> <strong>Source Repository </strong>to sync to our Github repo and auto-deploy changes.</li><li>A CRON job to run our function on a schedule, via <strong>Google Cloud Scheduler</strong>.</li><li>The <strong>gcloud</strong> CLI to enable us to work locally.</li></ul><p>You'll notice we lack any mentions of API endpoints, methods, stages, or anything related to handling web requests. It should not be understated that <em>Cloud Functions are preconfigured with an endpoint</em>, and all nonsense regarding whether endpoints accept GET or POST or AUTH or OPTIONs is missing entirely. These things are instead handled in the  logic of the function itself, and because Google Cloud functions running Python are preconfigured with <strong>Flask, </strong>all of that stuff is <em>really trivially easy.</em> That's right, we've got <em>Flask</em>, <em>Python</em>,<em> </em>and <em>GCP</em> all in a single post. Typing these words feels like eating cake while Dwyane The Rock Johnson reads me bedtime stories and caresses me as I fall asleep. It's great.</p><p>In the Cloud console, go ahead and create a new function. Our function will take the form of an HTTP endpoint:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/func.gif\" class=\"kg-image\"><figcaption>Single-page setup. Easy.</figcaption></figure><!--kg-card-end: image--><ul><li><strong>Memory Allocated </strong>lets us allocate more than the default 256MB to our function. Remember that Cloud functions are free: choose accordingly.</li><li><strong>Trigger</strong> specifies what will have access to this function. By selecting HTTP, we will immediately receive a URL.</li><li><strong>Source code</strong> gives us a few options to deploy our code, with <em>cloud source repository</em> being by far the easiest solution (more on that in a bit).</li><li><strong>Runtime</strong> allows you to select NodeJS by accident.</li><li><strong>Function to Execute</strong> needs the name of our entry point function, which is to be found in <code>main.py</code> or <code>main.js</code> depending on which language you’ve selected.</li></ul><p>If you're familiar with Lambda functions, the choices of an inline code editor or a zip file upload should come as no surprise. Since you're already familiar, I don't need to tell you why these methods <em>suck</em> for any sane workflow. Luckily, we have a better option: syncing our Github repo to a Google Source Repository.</p><h2 id=\"google-source-repositories\">Google Source Repositories</h2><p>Google Source Repositories are repos that function just like Github or Bitbucket repos. They're especially useful for syncing code changes from a Github repo, and setting up automatic deployments on commit.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/google-source-repo.png\" class=\"kg-image\"><figcaption>The Google Source Repositories Home</figcaption></figure><!--kg-card-end: image--><p>Setting up this sync is super easy. Create a new repository, specify that we're connecting an external Github repo, and we'll be able to select any repo in our account via the GUI:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/google-source-github-sync.gif\" class=\"kg-image\"><figcaption>Syncing a Github Repo</figcaption></figure><!--kg-card-end: image--><p>Now when we go back to our editing our function, setting the <strong>Source code</strong> field to the name of this new repository will automatically deploy the function whenever a change is committed. With this method, we have effectively zero changes to our normal workflow.</p><h3 id=\"commit-to-google-source-repositories-directly\">Commit to Google Source Repositories Directly</h3><p>If you don't want to sync a Github repo, no problem. We can create a repo locally using the <strong>gcloud CLI</strong>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ gcloud source repos create real-repo\n$ cd myproject/\n$ git init\n--------------------------------------------------------\n(take a moment to write or save some actual code here)\n--------------------------------------------------------\n$ git add --all\n$ git remote add google https://source.developers.google.com/p/hackers/r/real-repo\n$ git commit -m 'cheesey init message'\n$ git push --all google\n</code></pre>\n<!--kg-card-end: markdown--><p>Now make that puppy go live with <code>gcloud functions deploy totally-dope-function</code>, where <em><strong>totally-dope-function</strong> </em>is the name of your function, as it should be.</p><p>With our function set up and method in place for deploying code, we can now see how our Cloud Function is doing.</p><h2 id=\"viewing-error-logs\">Viewing Error Logs</h2><p>Because we have a real endpoint to work with, we don't need to waste any time creating dumb unit tests where we send fake JSON to our function (real talk though, we should always write unit tests).</p><p>The Cloud Function error log screen does a decent job of providing us with a GUI to see how our deployed function is running, and where things have gone wrong:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/logs.gif\" class=\"kg-image\"><figcaption>Orange Exclamation Marks Denote Errors</figcaption></figure><!--kg-card-end: image--><h2 id=\"firing-our-function-on-a-schedule\">Firing Our Function on a Schedule</h2><p>Let's say our function is a job we're looking to run daily, or perhaps hourly. Google Cloud Scheduler is a super easy way to trigger functions via CRON.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/google-cloud-scheduler.png\" class=\"kg-image\"><figcaption>How is this free again?</figcaption></figure><!--kg-card-end: image--><p>The easiest way to handle this is by creating our function as an HTTP endpoint back when we started. A <strong>Cloud Scheduler</strong> job can hit this endpoint at any time interval we want - just make sure you wrote your endpoint to handle GET requests.</p><h2 id=\"cloud-functions-in-short\">Cloud Functions in Short</h2><p>GCP seems to have been taking notes on the sidelines on how to improve this process by removing red-tape around service setup or policy configuration. AWS and GCP are tackling opposites approaches; AWS allows you to build a Robust API complete with staging and testing with the intent that some of these APIs can even be sold as standalone products to consumers. GCP takes the opposite approach: cloud functions are services intended for developers to develop. That should probably cover the vast majority of use cases anyway.</p>","url":"https://hackersandslackers.com/creating-a-python-google-cloud-function/","uuid":"ec428cb9-976e-4578-a3de-9120a0dd7352","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5bc91ac23d1eab214413b12b"}},"pageContext":{"slug":"creating-a-python-google-cloud-function"}}