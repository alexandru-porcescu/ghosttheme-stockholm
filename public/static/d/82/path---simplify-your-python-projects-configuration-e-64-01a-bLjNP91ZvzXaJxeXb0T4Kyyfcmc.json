{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673740","title":"The Many Faces and Filetypes of Python Configs","slug":"simplify-your-python-projects-configuration","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/11/config@2x.jpg","excerpt":"Cleverly (or uncleverly) configure your Python project using .ini, .yaml, or .env files.","custom_excerpt":"Cleverly (or uncleverly) configure your Python project using .ini, .yaml, or .env files.","created_at_pretty":"29 November, 2018","published_at_pretty":"29 November, 2018","updated_at_pretty":"27 December, 2018","created_at":"2018-11-29T02:24:13.000-05:00","published_at":"2018-11-29T16:40:26.000-05:00","updated_at":"2018-12-26T23:23:54.000-05:00","meta_title":"Simplify Your Python Project Configuration | Hackers and Slackers","meta_description":"Cleverly (or uncleverly) configure your Python project using .ini, .yaml, or .env files. Adopt a feel for when certain files or classes fit your needs best.","og_description":"Cleverly (or uncleverly) configure your Python project using .ini, .yaml, or .env files. Adopt a feel for when certain files or classes fit your needs best.","og_image":"https://hackersandslackers.com/content/images/2018/11/config@2x.jpg","og_title":"The Many Faces and Files of Python Configs","twitter_description":"Cleverly (or uncleverly) configure your Python project using .ini, .yaml, or .env files. Adopt a feel for when certain files or classes fit your needs best.","twitter_image":"https://hackersandslackers.com/content/images/2018/11/config@2x.jpg","twitter_title":"The Many Faces and Files of Python Configs","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"As we cling harder and harder to Dockerfiles, Kubernetes, or any modern\npreconfigured app environment, our dependency on billable boilerplate grows.\nWhether or not that is a problem is a conversation in itself. The longer I keep\nmy projects self-hosted, the more Â I'm consumed by the open-ended approaches\npeople take to manage their project configuration variables.\n\nFull disclosure here: this post is probably about as boring as where you see\nthis heading. Today, I'm here to talk about Python Environment and general\nconfiguration variable handling.\n\nPick Your Poison\nSomeday, each and every one of us will die. I'm referring of course to the part\ninside of us that slowly withers away as we're forced to maintain projects we've\nhanded off. We can do our best to avoid these situations by isolating the\nvariables most subject to change in separate, easy-to-edit files for Person\nNumber 2 to pick up on.\n\nOption 1: Project Config via .ini Files\n.ini  files are simple, making them perfect for simple projects- especially\nthose to be handled by others why may not have development backgrounds. These\nare configuration files with a single-level hierarchy:\n\n[GLOBAL]\nPROJECT: Fake Example Project\nREGION: us-east-1\nINPUT_FOLDER: data/zip/\nOUTPUT_FOLDER: data/output/\nTIMEOUT: 200\nMEMORY: 512\n\n[PROD]\nDATABASE = postgresql://loser:weakpassword@localhost:5432/mydatabase\nENDPOINT = https://production.endpoint.example.com\nUSER = PROD_USERNAME\n\n[DEV]\nDATABASE = postgresql://loser:weakpassword@localhost:5432/mydatabase\nENDPOINT = https://dev.endpoint.example.com\nUSER = DEV_USERNAME\n\n\nAnother example, for instance, may be to specify AWS Services:\n\n[S3]\nBUCKET_NAME: public-bucket\nBUCKET_FOLDER: /\n\n[RDS]\nNAME: rds/prod/sensitivedata\nARN: arn:aws:rds:us-east-1:66574567568434896:secret:rds/prod/peopledata-ZvJ3Ys\nREGION: us-east-1\n\n[LAMBDA]\nFUNCTION_NAME: handler\nHANDLER: lambda.handler\nDESCRIPTION: Performs a task every now and then.\nRUNTIME: python3.7\nROLE: lambda_role\nDIST_FOLDER: lambda/dist\n\n[SECRETS]\nSECRET_NAME: rds/prod/totallysecret\nSECRET_ARN: arn:aws:secretsmanager:us-east-1:769979969:secret:rds/prod/stupidproject-5647\n\n\n.ini  files are handled in Python by the configparser  library; this is our way\nof doing something with the essentially static text in these files. Since we're\nkeeping vars separate from app source code, we now need to create a file and a\nclass which exists merely to access these values.\n\nCreating a Python Class to Extract Variables\nInstead of explicitly hardcoding a dump of all variables, we're going to create\na class that provides an easy syntax for accessing variables on demand. Check it\nout:\n\n# config_loader.py\nfrom configparser import SafeConfigParser\nimport os\n\n\nclass Config:\n    \"\"\"Interact with configuration variables.\"\"\"\n\n    configParser = SafeConfigParser()\n    configFilePath = (os.path.join(os.getcwd(), 'config.ini'))\n\n    @classmethod\n    def initialize(cls, newhire_table):\n        \"\"\"Start config by reading config.ini.\"\"\"\n        cls.configParser.read(cls.configFilePath)\n\n    @classmethod\n    def prod(cls, key):\n        \"\"\"Get prod values from config.ini.\"\"\"\n        return cls.configParser.get('PROD', key)\n\n    @classmethod\n    def dev(cls, key):\n        \"\"\"Get dev values from config.ini.\"\"\"\n        return cls.configParser.get('DEV', key)\n\n\nThis simple class goes a long way to simplify grabbing variables. The class\nnever needs to be instantiated, so we can import Config  wherever we please and\nimmediately start pulling values.\n\nTo separate variables by concern, each block in config.ini  receives its own\nclass method. Now retrieving the proper variables is as simple as \nConfig.prod('DATABASE')  will return the URI for a production database. Easy to\nuse, simple to understand.\n\nOption 2: Complex YAML Configurations\nUnless you're developing apps in isolation in an isolated third-world nation or\nunder a dictatorship which blocks internet access, you already know that .yaml \nfiles are all the rage when it comes to storing static values in text files\n(wow, this really is  an obscure topic for a post).\n\nYAML  files provide plenty of upsides to alternative file types. Where .ini \nfiles are simply grouped variables, YAML  provides a hierarchy structure. This\nmakes YAML files much easier to understand and maintain for larger applications,\nas some variables only make sense in the context of being a sub-variable (?).\n\nCheck out what a sample YAML config might look like:\n\n---\n\nappName: appName\nlogLevel: WARN\n\nAWS:\n    Region: us-east-1\n    Resources:\n      EC2: \n        Type: \"AWS::EC2::Instance\"\n        Properties: \n          ImageId: \"ami-0ff8a91507f77f867\"\n          InstanceType: t2.micro\n          KeyName: testkey\n          BlockDeviceMappings:\n            -\n              DeviceName: /dev/sdm\n              Ebs:\n                VolumeType: io1\n                Iops: 200\n                DeleteOnTermination: false\n                VolumeSize: 20\n      Lambda:\n          Type: \"AWS::Lambda::Function\"\n          Properties: \n            Handler: \"index.handler\"\n            Role: \n              Fn::GetAtt: \n                - \"LambdaExecutionRole\"\n                - \"Arn\"\n            Runtime: \"python3.7\"\n            Timeout: 25\n            TracingConfig:\n              Mode: \"Active\"\n\nroutes:\n  admin:\n    url: /admin\n    template: admin.html\n    assets:\n        templates: /templates\n        static: /static\n  dashboard:\n    url: /dashboard\n    template: dashboard.html\n    assets:\n        templates: /templates\n        static: /static\n  account:\n    url: /account\n    template: account.html\n    assets:\n        templates: /templates\n        static: /static\n        \ndatabases:\n  cassandra:\n    host: example.cassandra.db\n    username: user\n    password: password\n  redshift:\n    jdbcURL: jdbc:redshift://<IP>:<PORT>/file?user=username&password=pass\n    tempS3Dir: s3://path/to/redshift/temp/dir/ \n  redis:\n    host: hostname\n    port: port-number\n    auth: authentication\n    db: database\n\n\nThis would read horribly if we tried to fit this in an .ini  file. A more fair\ncomparison would be to JSON  configurations: JSON objects indeed share the same\nhierarchy advantages of YAML, but JSON syntax is prone to errors and unhelpful\nerror messages, thanks to being a brainchild of Old Man JavaScript. YAML doesn't\ncare if you open and close with brackets, use double quotes, or leave a trailing\ncomma. All of these stupid things are why I prefer Python.\n\nParsing YAML in Python\nI recommend the Python Confuse library [https://github.com/sampsyo/confuse]  (a\npackage name that's sure to raise some eyebrows by your company's information\nsecurity team).\n\nConfuse  allows use to interact with YAML files almost identically to how we\nwould with JSON, with the exception that we specify .get()  at the end of\nwalking through the tree hierarchy, like so:\n\nconfig = confuse.Configuration('MyApp', __name__)\n\nconfig['AWS']['Lambda']['Runtime'].get()\n\n\n.get()  can accept a datatype value such as int. Doing so ensures that the value\nwe're getting is actually of the schema we're expecting, which is a neat\nfeature.\n\nValidators\nConfuse's documentation [https://confuse.readthedocs.io/en/latest/]details\nadditional validation methods for values we pull from YAML files. Methods like \nas_filename(), as_number(), and as_str_seq()  do basically what you'd expect\nthem to.\n\nCLI Configuration\nConfuse also gets into the realm of building CLIs, allowing use to use our YAML\nfile to inform arguments which can be passed to a CLI and their potential\nvalues:\n\nconfig = confuse.Configuration('myapp')\nparser = argparse.ArgumentParser()\nparser.add_argument('--foo', help='a parameter')\nargs = parser.parse_args()\nconfig.set_args(args)\nprint(config['foo'].get())\n\n\nThere's plenty of things you can go nuts with here.\n\nOption 3: Using .env Config Files\nLastly, we can leverage the already well-known .env  format to set variables.\nWorking this way is pretty equivalent to working with .ini  files, but we're\nhuman beings so we're stupid and do things like build the same protocols over\nand over. In .env, we get to store beautiful values such as these:\n\nCONFIG_PATH=${HOME}/.config/foo\nDOMAIN=example.org\nEMAIL=admin@${DOMAIN}\n\nTo read these values, we'll be using the python-dotenv library\n[https://github.com/theskumar/python-dotenv]. This gets you started:\n\nfrom dotenv import load_dotenv\nfrom pathlib import Path\n\nload_dotenv(verbose=True)\n\nenv_path = Path('.') / '.env'\nload_dotenv(dotenv_path=env_path)\n\n\nAfter that, it's a matter of setting variables in Python to values you extract\nfrom .env:\n\nimport os\nSECRET_KEY = os.getenv(\"EMAIL\")\nDATABASE_PASSWORD = os.getenv(\"DATABASE_PASSWORD\")\n\n\nSo Yeah, Basically Just Use What You Want\nClearly there are plenty of ways to set environment and project variables in\nPython. We could spend all day investigating the nuances of each and how their\naccompanying Python configuration class should be structured, but we've got apps\nto build. \n\nBesides, I need to go reflect on my life after writing a thousand words about\nloading variables in Python.","html":"<p>As we cling harder and harder to Dockerfiles, Kubernetes, or any modern preconfigured app environment, our dependency on billable boilerplate grows. Whether or not that is a problem is a conversation in itself. The longer I keep my projects self-hosted, the more Â I'm consumed by the open-ended approaches people take to manage their project configuration variables.</p><p>Full disclosure here: this post is probably about as boring as where you see this heading. Today, I'm here to talk about Python Environment and general configuration variable handling.</p><h2 id=\"pick-your-poison\">Pick Your Poison</h2><p>Someday, each and every one of us will die. I'm referring of course to the part inside of us that slowly withers away as we're forced to maintain projects we've handed off. We can do our best to avoid these situations by isolating the variables most subject to change in separate, easy-to-edit files for Person Number 2 to pick up on.</p><h2 id=\"option-1-project-config-via-ini-files\">Option 1: Project Config via .ini Files</h2><p><code>.ini</code> files are simple, making them perfect for simple projects- especially those to be handled by others why may not have development backgrounds. These are configuration files with a single-level hierarchy:</p><pre><code class=\"language-ini\">[GLOBAL]\nPROJECT: Fake Example Project\nREGION: us-east-1\nINPUT_FOLDER: data/zip/\nOUTPUT_FOLDER: data/output/\nTIMEOUT: 200\nMEMORY: 512\n\n[PROD]\nDATABASE = postgresql://loser:weakpassword@localhost:5432/mydatabase\nENDPOINT = https://production.endpoint.example.com\nUSER = PROD_USERNAME\n\n[DEV]\nDATABASE = postgresql://loser:weakpassword@localhost:5432/mydatabase\nENDPOINT = https://dev.endpoint.example.com\nUSER = DEV_USERNAME\n</code></pre>\n<p>Another example, for instance, may be to specify AWS Services:</p><pre><code class=\"language-ini\">[S3]\nBUCKET_NAME: public-bucket\nBUCKET_FOLDER: /\n\n[RDS]\nNAME: rds/prod/sensitivedata\nARN: arn:aws:rds:us-east-1:66574567568434896:secret:rds/prod/peopledata-ZvJ3Ys\nREGION: us-east-1\n\n[LAMBDA]\nFUNCTION_NAME: handler\nHANDLER: lambda.handler\nDESCRIPTION: Performs a task every now and then.\nRUNTIME: python3.7\nROLE: lambda_role\nDIST_FOLDER: lambda/dist\n\n[SECRETS]\nSECRET_NAME: rds/prod/totallysecret\nSECRET_ARN: arn:aws:secretsmanager:us-east-1:769979969:secret:rds/prod/stupidproject-5647\n</code></pre>\n<p><code>.ini</code> files are handled in Python by the <strong>configparser</strong> library; this is our way of doing something with the essentially static text in these files. Since we're keeping vars separate from app source code, we now need to create a file and a class which exists merely to access these values.</p><h3 id=\"creating-a-python-class-to-extract-variables\">Creating a Python Class to Extract Variables</h3><p>Instead of explicitly hardcoding a dump of all variables, we're going to create a class that provides an easy syntax for accessing variables on demand. Check it out:</p><pre><code class=\"language-python\"># config_loader.py\nfrom configparser import SafeConfigParser\nimport os\n\n\nclass Config:\n    &quot;&quot;&quot;Interact with configuration variables.&quot;&quot;&quot;\n\n    configParser = SafeConfigParser()\n    configFilePath = (os.path.join(os.getcwd(), 'config.ini'))\n\n    @classmethod\n    def initialize(cls, newhire_table):\n        &quot;&quot;&quot;Start config by reading config.ini.&quot;&quot;&quot;\n        cls.configParser.read(cls.configFilePath)\n\n    @classmethod\n    def prod(cls, key):\n        &quot;&quot;&quot;Get prod values from config.ini.&quot;&quot;&quot;\n        return cls.configParser.get('PROD', key)\n\n    @classmethod\n    def dev(cls, key):\n        &quot;&quot;&quot;Get dev values from config.ini.&quot;&quot;&quot;\n        return cls.configParser.get('DEV', key)\n</code></pre>\n<p>This simple class goes a long way to simplify grabbing variables. The class never needs to be instantiated, so we can <code>import Config</code> wherever we please and immediately start pulling values.</p><p>To separate variables by concern, each block in <code>config.ini</code> receives its own class method. Now retrieving the proper variables is as simple as <code>Config.prod('DATABASE')</code> will return the URI for a production database. Easy to use, simple to understand.</p><h2 id=\"option-2-complex-yaml-configurations\">Option 2: Complex YAML Configurations</h2><p>Unless you're developing apps in isolation in an isolated third-world nation or under a dictatorship which blocks internet access, you already know that <code>.yaml</code> files are all the rage when it comes to storing static values in text files (wow, this really <em>is</em> an obscure topic for a post).</p><p><strong>YAML</strong> files provide plenty of upsides to alternative file types. Where <strong>.ini</strong> files are simply grouped variables, <strong>YAML</strong> provides a hierarchy structure. This makes YAML files much easier to understand and maintain for larger applications, as some variables only make sense in the context of being a sub-variable (?).</p><p>Check out what a sample YAML config might look like:</p><pre><code class=\"language-yaml\">---\n\nappName: appName\nlogLevel: WARN\n\nAWS:\n    Region: us-east-1\n    Resources:\n      EC2: \n        Type: &quot;AWS::EC2::Instance&quot;\n        Properties: \n          ImageId: &quot;ami-0ff8a91507f77f867&quot;\n          InstanceType: t2.micro\n          KeyName: testkey\n          BlockDeviceMappings:\n            -\n              DeviceName: /dev/sdm\n              Ebs:\n                VolumeType: io1\n                Iops: 200\n                DeleteOnTermination: false\n                VolumeSize: 20\n      Lambda:\n          Type: &quot;AWS::Lambda::Function&quot;\n          Properties: \n            Handler: &quot;index.handler&quot;\n            Role: \n              Fn::GetAtt: \n                - &quot;LambdaExecutionRole&quot;\n                - &quot;Arn&quot;\n            Runtime: &quot;python3.7&quot;\n            Timeout: 25\n            TracingConfig:\n              Mode: &quot;Active&quot;\n\nroutes:\n  admin:\n    url: /admin\n    template: admin.html\n    assets:\n        templates: /templates\n        static: /static\n  dashboard:\n    url: /dashboard\n    template: dashboard.html\n    assets:\n        templates: /templates\n        static: /static\n  account:\n    url: /account\n    template: account.html\n    assets:\n        templates: /templates\n        static: /static\n        \ndatabases:\n  cassandra:\n    host: example.cassandra.db\n    username: user\n    password: password\n  redshift:\n    jdbcURL: jdbc:redshift://&lt;IP&gt;:&lt;PORT&gt;/file?user=username&amp;password=pass\n    tempS3Dir: s3://path/to/redshift/temp/dir/ \n  redis:\n    host: hostname\n    port: port-number\n    auth: authentication\n    db: database\n</code></pre>\n<p>This would read horribly if we tried to fit this in an <strong>.ini</strong> file. A more fair comparison would be to <strong>JSON</strong> configurations: JSON objects indeed share the same hierarchy advantages of YAML, but JSON syntax is prone to errors and unhelpful error messages, thanks to being a brainchild of Old Man JavaScript. YAML doesn't care if you open and close with brackets, use double quotes, or leave a trailing comma. All of these stupid things are why I prefer Python.</p><h3 id=\"parsing-yaml-in-python\">Parsing YAML in Python</h3><p>I recommend the <a href=\"https://github.com/sampsyo/confuse\">Python <em>Confuse</em> library</a> (a package name that's sure to raise some eyebrows by your company's information security team).</p><p><strong>Confuse</strong> allows use to interact with YAML files almost identically to how we would with JSON, with the exception that we specify <code>.get()</code> at the end of walking through the tree hierarchy, like so:</p><pre><code class=\"language-python\">config = confuse.Configuration('MyApp', __name__)\n\nconfig['AWS']['Lambda']['Runtime'].get()\n</code></pre>\n<p><strong>.get()</strong> can accept a datatype value such as <em>int. </em>Doing so ensures that the value we're getting is actually of the schema we're expecting, which is a neat feature.</p><h4 id=\"validators\">Validators</h4><p><a href=\"https://confuse.readthedocs.io/en/latest/\">Confuse's documentation </a>details additional validation methods for values we pull from YAML files. Methods like <code>as_filename()</code>, <code>as_number()</code>, and <code>as_str_seq()</code> do basically what you'd expect them to.</p><h4 id=\"cli-configuration\">CLI Configuration</h4><p>Confuse also gets into the realm of building CLIs, allowing use to use our YAML file to inform arguments which can be passed to a CLI and their potential values:</p><pre><code class=\"language-python\">config = confuse.Configuration('myapp')\nparser = argparse.ArgumentParser()\nparser.add_argument('--foo', help='a parameter')\nargs = parser.parse_args()\nconfig.set_args(args)\nprint(config['foo'].get())\n</code></pre>\n<p>There's plenty of things you can go nuts with here.</p><h2 id=\"option-3-using-env-config-files\">Option 3: Using .env Config Files</h2><p>Lastly, we can leverage the already well-known <code>.env</code> format to set variables. Working this way is pretty equivalent to working with <strong>.ini</strong> files, but we're human beings so we're stupid and do things like build the same protocols over and over. In <strong>.env</strong>, we get to store beautiful values such as these:</p><pre><code>CONFIG_PATH=${HOME}/.config/foo\nDOMAIN=example.org\nEMAIL=admin@${DOMAIN}</code></pre><p>To read these values, we'll be using the <a href=\"https://github.com/theskumar/python-dotenv\"><strong>python-dotenv</strong> library</a>. This gets you started:</p><pre><code class=\"language-python\">from dotenv import load_dotenv\nfrom pathlib import Path\n\nload_dotenv(verbose=True)\n\nenv_path = Path('.') / '.env'\nload_dotenv(dotenv_path=env_path)\n</code></pre>\n<p>After that, it's a matter of setting variables in Python to values you extract from <code>.env</code>:</p><pre><code class=\"language-python\">import os\nSECRET_KEY = os.getenv(&quot;EMAIL&quot;)\nDATABASE_PASSWORD = os.getenv(&quot;DATABASE_PASSWORD&quot;)\n</code></pre>\n<h2 id=\"so-yeah-basically-just-use-what-you-want\">So Yeah, Basically Just Use What You Want</h2><p>Clearly there are plenty of ways to set environment and project variables in Python. We could spend all day investigating the nuances of each and how their accompanying Python configuration class should be structured, but we've got apps to build. </p><p>Besides, I need to go reflect on my life after writing a thousand words about loading variables in Python.</p>","url":"https://hackersandslackers.com/simplify-your-python-projects-configuration/","uuid":"48fb64b7-b9f2-4605-ac1f-c1c45ffc5964","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5bff941deae98c3b9d4c25f4"}},"pageContext":{"slug":"simplify-your-python-projects-configuration"}}