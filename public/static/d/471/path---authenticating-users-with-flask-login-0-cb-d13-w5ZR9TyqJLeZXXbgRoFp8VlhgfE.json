{"data":{"ghostPost":{"id":"Ghost__Post__5c779ffbc380a221de39c7cf","title":"Using Flask-Login to Handle User Accounts","slug":"authenticating-users-with-flask-login","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin.jpg","excerpt":"Add user authentication to your Flask app with Flask-Login","custom_excerpt":"Add user authentication to your Flask app with Flask-Login","created_at_pretty":"28 February, 2019","published_at_pretty":"04 April, 2019","updated_at_pretty":"11 April, 2019","created_at":"2019-02-28T03:46:51.000-05:00","published_at":"2019-04-04T18:36:51.000-04:00","updated_at":"2019-04-10T22:01:31.000-04:00","meta_title":"Authenticating Users With Flask-Login | Hackers and Slackers","meta_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","og_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","og_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin-2.jpg","og_title":"Authenticating Users With Flask-Login","twitter_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","twitter_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin-1.jpg","twitter_title":"Authenticating Users With Flask-Login","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"We’ve covered a lot of Flask goodness in this series thus far. We fully\nunderstand how to structure a sensible application; we can serve up complex\npage\ntemplates\n[https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/],\nand have dived into interacting with databases using Flask-SQLAlchemy\n[https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/].\nFor our next challenge, we’re going to need all  of the knowledge we've acquired\nthus far and much, much more. Welcome to the Super Bowl of Flask development.\nThis. Is. Flask-Login.\n\nFlask-Login [https://flask-login.readthedocs.io/en/latest/]  is a dope library\nwhich handles all aspects of user management, including vital nuances you might\nnot expect. Some noteworthy features include securing parts of our app behind\nlogin walls, encrypting passwords, and handling sessions. Moreover, It plays\nnicely with other Flask libraries we’re already familiar with: Flask-SQLAlchemy\n[https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/] \nto create and fetch accounts, and Flask-WTForms\n[https://hackersandslackers.com/guide-to-building-forms-in-flask/]  for handling\nintelligent sign-up & log-in forms. This tutorial assumes you have some working\nknowledge of these things.\n\nFlask-Login is shockingly quite easy to use after the initial learning curve...\nbut therein lies the catch. Perhaps I’m not the only one to have noticed, but\nmost Flask-related documentation tends to be, well, God-awful. The community is\nriddled with helplessly outdated information; if you ever come across flask.ext \nin a tutorial, it is inherently worthless to anybody developing in 2019. To make\nmatters worse, official Flask-Login documentation contains some artifacts which\nare just plain wrong. The documentation contradicts itself (I’ll show you what I\nmean), and offers little to no code examples to speak of. My only hope is that I\nmight save somebody the endless headaches I’ve experienced myself.\n\nStructuring Our Application\nLet’s start with installing dependencies. This should give you an idea of what\nyou’re in for:\n\n$ pip3 install flask flask-login flask-sqlalchemy psycopg2-binary python-dotenv\n\n\nSweet. Let’s take this one step at a time, starting with our project file\nstructure:\n\nflasklogin-tutorial\n├── /login_tutorial\n│   ├── __init__.py\n│   ├── auth.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── routes.py\n│   ├── /static\n│   │   ├── /dist\n│   │   │   ├── /css\n│   │   │   │   ├── account.css\n│   │   │   │   └── dashboard.css\n│   │   │   └── /js\n│   │   │       └── main.min.js\n│   │   └── /src\n│   │       ├── /js\n│   │       │   └── main.js\n│   │       └── /less\n│   │           ├── account.less\n│   │           ├── dashboard.less\n│   │           └── vars.less\n│   └── /templates\n│       ├── dashboard.html\n│       ├── layout.html\n│       ├── login.html\n│       ├── meta.html\n│       ├── scripts.html\n│       └── signup.html\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n\n\nOf course, I wouldn't be a gentleman unless I revealed my config.py  as well:\n\nimport os\n\n\nclass Config:\n    \"\"\"Set Flask configuration vars from .env file.\"\"\"\n\n    # General Config\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    FLASK_APP = os.environ.get('FLASK_APP')\n    FLASK_ENV = os.environ.get('FLASK_ENV')\n    FLASK_DEBUG = os.environ.get('FLASK_DEBUG')\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get('SQLALCHEMY_TRACK_MODIFICATIONS')\n\n\nThe configuration values live in a .env  file, a practice I highly encourage. Of\nthese configuration variables, SECRET_KEY  is where we should turn our\nattention. SECRET_KEY is the equivalent of a password used to secure our app; it\nshould be as long, nonsensical, and impossible-to-remember as humanly possible.\nSeriously: having your secret key compromised is the equivalent of feeding\ngremlins after midnight.\n\nInitializing Flask-Login\nWith a standard \"application factory\" app, setting up Flask-Login is no\ndifferent from other Flask plugins (or whatever they're called now). This makes\nsetting up easy; all we need to do is make sure Flask-Login  is initialized in \n__init__.py  along with the rest of our plugins:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\n\n\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n\n    # Application Configuration\n    app.config.from_object('config.Config')\n\n    # Initialize Plugins\n    db.init_app(app)\n    login_manager.init_app(app)\n\n    with app.app_context():\n        # Import parts of our application\n        from . import routes\n        from . import login\n        app.register_blueprint(routes.main_bp)\n        app.register_blueprint(login.login_bp)\n\n        # Initialize Global db\n        db.create_all()\n\n        return app\n\n\nIn the above example, we're using the minimal number of plug-ins to get logins\nworking: Flask-SQLAlchemy  and Flask-Login.\n\nTo keep our sanity, we're going to separate our login routes from our main\napplication routes and logic. This is why we register a Blueprint called auth_bp\n, imported from a file called auth.py. Our “main” application (AKA anything that\nisn’t logging in) will instead live in routes.py, in a Blueprint called main_bp.\nWe'll come back to these in a moment\n\nCreating a User Model\nWe'll save our User  model in models.py. There are a few things to keep in mind\nwhen creating models compatible with Flask-Login- the most important being the\nutilization of UserMixin  from the flask_login  library. When we inherit our\nclass from UserMixin,  our model is immediately extended to include all the\nmethods necessary for Flask-Login to work. This is by far the easiest way of\ncreating a User model. I won't bother getting into details of what these methods\ndo, because if you simply begin your class with class User(UserMixin, db.Model):\n, you genuinely don't need to understand any of it:\n\nfrom . import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n\nclass User(UserMixin, db.Model):\n    \"\"\"Model for user accounts.\"\"\"\n\n    __tablename__ = 'flasklogin-users'\n\n    id = db.Column(db.Integer,\n                   primary_key=True,\n                   )\n    name = db.Column(db.String,\n                     nullable=False,\n                     unique=False)\n    email = db.Column(db.String(40),\n                      unique=True,\n                      nullable=False\n                      )\n    password = db.Column(db.String(200),\n                         primary_key=False,\n                         unique=False,\n                         nullable=False\n                         )\n    website = db.Column(db.String(60),\n                        index=False,\n                        unique=False,\n                        nullable=True\n                        )\n    created_on = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n    last_login = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n\n    def set_password(self, password):\n        \"\"\"Create hashed password.\"\"\"\n        self.password = generate_password_hash(password, method='sha256')\n\n    def check_password(self, password):\n        \"\"\"Check hashed password.\"\"\"\n        return check_password_hash(self.password, password)\n\n    def __repr__(self):\n        return '<User {}>'.format(self.username)\n\n\nThe set_password  and check_password  methods don't necessarily need to live\ninside our User model, but it's nice to keep related logic bundled together and\nout of our routes.\n\nYou may notice that our password field explicitly allows 200 characters: this is\nbecause our database will be storing hashed passwords. Thus, even if a user's\npassword is 8 characters long, the string in our database will look much\ndifferent.\n\nCreating Log-in and Sign-up Forms\nIf you're well versed in WTForms, our form logic in forms.py  probably looks as\nyou'd expect. Of course, the constraints we set here are to handle front-end\nvalidation only:\n\nfrom wtforms import Form, StringField, PasswordField, validators, SubmitField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length, Optional\n\n\nclass SignupForm(Form):\n    \"\"\"User Signup Form.\"\"\"\n\n    name = StringField('Name',\n                        validators=[DataRequired(message=('Enter a fake name or something.'))])\n    email = StringField('Email',\n                        validators=[Length(min=6, message=('Please enter a valid email address.')),\n                                    Email(message=('Please enter a valid email address.')),\n                                    DataRequired(message=('Please enter a valid email address.'))])\n    password = PasswordField('Password',\n                             validators=[DataRequired(message='Please enter a password.'),\n                                         Length(min=6, message=('Please select a stronger password.')),\n                                         EqualTo('confirm', message='Passwords must match')])\n    confirm = PasswordField('Confirm Your Password',)\n    website = StringField('Website',\n                          validators=[Optional()])\n    submit = SubmitField('Register')\n\n\nclass LoginForm(Form):\n    \"\"\"User Login Form.\"\"\"\n\n    email = StringField('Email', validators=[DataRequired('Please enter a valid email address.'),\n                                             Email('Please enter a valid email address.')])\n    password = PasswordField('Password', validators=[DataRequired('Uhh, your password tho?')])\n    submit = SubmitField('Log In')\n\n\nWith those out of the way, let's look at how we implement these on the Jinja\nside.\n\nsignup.html\n{% extends \"layout.html\" %}\n\n{% block pagestyles %}\n    <link href=\"{{ url_for('static', filename='dist/css/account.css') }}\" rel=\"stylesheet\" type=\"text/css\">\n{% endblock %}\n\n{% block content %}\n  <div class=\"formwrapper\">\n    <form method=post>\n      <div class=\"logo\">\n        <img src=\"{{ url_for('static', filename='dist/img/logo.png') }}\">\n      </div>\n      {% for message in get_flashed_messages() %}\n        <div class=\"alert alert-warning\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n            {{ message }}\n        </div>\n      {% endfor %}\n      <h1>Sign Up</h1>\n      <div class=\"name\">\n        {{ form.name.label }}\n        {{ form.name(placeholder='John Smith') }}\n        {% if form.name.errors %}\n          <ul class=\"errors\">\n            {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"email\">\n        {{ form.email.label }}\n        {{ form.email(placeholder='youremail@example.com') }}\n        {% if form.email.errors %}\n          <ul class=\"errors\">\n            {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"password\">\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.password.errors %}\n          <ul class=\"errors\">\n            {% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"confirm\">\n        {{ form.confirm.label }}\n        {{ form.confirm }}\n        {% if form.confirm.errors %}\n          <ul class=\"errors\">\n            {% for error in form.confirm.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"website\">\n        {{ form.website.label }}\n        {{ form.website(placeholder='http://example.com') }}\n      </div>\n      <div class=\"submitbutton\">\n        <input id=\"submit\" type=\"submit\" value=\"Submit\">\n      </div>\n    </form>\n    <div class=\"loginsignup\">\n      <span>Already have an account? <a href=\"{{ url_for('auth_bp.login_page') }}\">Log in.</a><span>\n    </div>\n  </div>\n{% endblock %}\n\n\n\nlogin.py\n{% extends \"layout.html\" %}\n\n{% block pagestyles %}\n  <link href=\"{{ url_for('static', filename='dist/css/account.css') }}\" rel=\"stylesheet\" type=\"text/css\">\n{% endblock %}\n\n{% block content %}\n  <div class=\"formwrapper\">\n    <form method=post>\n      <div class=\"logo\">\n        <img src=\"{{ url_for('static', filename='dist/img/logo.png') }}\">\n      </div>\n      {% for message in get_flashed_messages() %}\n        <div class=\"alert alert-warning\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n            {{ message }}\n        </div>\n      {% endfor %}\n      <h1>Log In</h1>\n      <div class=\"email\">\n         {{ form.email.label }}\n         {{ form.email(placeholder='youremail@example.com') }}\n         {% if form.email.errors %}\n           <ul class=\"errors\">\n             {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n           </ul>\n         {% endif %}\n      </div>\n      <div class=\"password\">\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.email.errors %}\n          <ul class=\"errors\">\n            {% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"submitbutton\">\n        <input id=\"submit\" type=\"submit\" value=\"Submit\">\n      </div>\n      <div class=\"loginsignup\">\n        <span>Don't have an account? <a href=\"{{ url_for('auth_bp.signup_page') }}\">Sign up.</a><span>\n        </div>\n    </form>\n  </div>\n{% endblock %}\n\n\n\nExcellent: the stage is set to start kicking some ass.\n\nCreating Our Login Routes\nLet us turn our attention to the heart of the logic we'll be writing in auth.py:\n\nimport os\nfrom flask import redirect, render_template, flash, Blueprint, request, session, url_for\nfrom flask_login import login_required, logout_user, current_user, login_user\nfrom flask import current_app as app\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom .forms import LoginForm, SignupForm\nfrom .models import db, User\nfrom . import login_manager\n\n\n# Blueprint Configuration\nauth_bp = Blueprint('auth_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    \"\"\"User login page.\"\"\"\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        ...\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=\"Log in with your User account.\")\n\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    \"\"\"User sign-up page.\"\"\"\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        ...\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=\"Sign up for a user account.\")\n\n\nHere we find two separate skeleton routes for Sign up  and Log in. Without the\nauthentication logic added quite yet, these routes look almost identical thus\nfar.\n\nEach time a user visits a page in your app, the corresponding route is sent a \nrequest  object. This object contains contextual information about the request\nmade by the user, such as the type of request (GET or POST), any form data which\nwas submitted, etc. We leverage this to see whether the user is just arriving at\nthe page for the first time (a GET request), or if they're attempting to sign in\n(a POST request). The fairly clever takeaway here is that our login pages verify\nusers by making POST requests to themselves: this allows us to keep all logic\nrelated to logging in or signing up in a single route.\n\nSigning Up\nWe're able to validate the submitted form by importing the SignupForm  class and\npassing request.form  as the form in question. if signup_form.validate()  checks\nthe information submitted by the user against all the form's validators. If any\nof the validators are not met, the user is redirected back to the signup form\nwith error messages present.\n\nAssuming that our user isn't inept, we can move on with our logic. First, we\nneed to make sure a user with the provided email doesn't already exist:\n\n...\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    \"\"\"User sign-up page.\"\"\"\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        if signup_form.validate():\n            # Get Form Fields\n            name = request.form.get('name')\n            email = request.form.get('email')\n            password = request.form.get('password')\n            website = request.form.get('website')\n            existing_user = User.query.filter_by(email=email).first()\n            if existing_user is None:\n                user = User(name=name,\n                            email=email,\n                            password=generate_password_hash(password, method='sha256'),\n                            website=website)\n                db.session.add(user)\n                db.session.commit()\n                login_user(user)\n                return redirect(url_for('main_bp.dashboard'))\n            flash('A user already exists with that email address.')\n            return redirect(url_for('auth_bp.signup_page'))\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=\"Sign up for a user account.\")\n\n\nIf existing_user is None, we're all clear to actually clear to create a new user\nrecord. We create an instance of our User model via user = User(...). We then\nadd the user via standard SQLAlchemy syntax and finally use the imported method \nlogin_user()  to log the user in.\n\nIf everything goes well, the user will finally be redirected to the main\napplication, which is handled by return redirect(url_for('main_bp.dashboard')):\n\nA successful user log in.And here's what will happen if we log out and try to\nsign up with the same information:\n\nAttempting to sign up with an existing emailLogging In\nMoving on to our login route:\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    \"\"\"User login page.\"\"\"\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        if login_form.validate():\n            # Get Form Fields\n            email = request.form.get('email')\n            password = request.form.get('password')\n            # Validate Login Attempt\n            user = User.query.filter_by(email=email).first()\n            if user:\n                if user.check_password(password=password):\n                    login_user(user)\n                    next = request.args.get('next')\n                    return redirect(next or url_for('main_bp.dashboard'))\n        flash('Invalid username/password combination')\n        return redirect(url_for('auth_bp.login_page'))\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=\"Log in with your User account.\")\n\n\nThis should mostly look the same! our logic is identical up until the point\nwhere we check to see if the user exists. This time, a match results in success\nas opposed to a failure. Continuing, we then use user.check_password()  to check\nthe hashed password we created earlier with user.generate_password_hash(). Both\nof these methods handle the encrypting and decrypting of passwords on their own\n(based on that SECRET_KEY we created earlier) to ensure that nobody (not even\nus) has any business looking at user passwords.\n\nAs with last time, a successful login ends in login_user(user). Our redirect\nlogic is little more sophisticated this time around: instead of always sending\nthe user back to the dashboard, we check for next, which is a parameter stored\nin the query string of the current user. If the user attempted to access our app\nbefore logging in, next  would equal the page they had attempted to reach: this\nallows us wall-off our app from unauthorized users, and then drop users off at\nthe page they attempted to reach before they logged in:\n\nA successful log inIMPORTANT: Login Helpers\nBefore your app can work like the above, we need to finish auth.py  by providing\na few more routes:\n\n@auth_bp.route(\"/logout\")\n@login_required\ndef logout_page():\n    \"\"\"User log-out logic.\"\"\"\n    logout_user()\n    return redirect(url_for('auth_bp.login_page'))\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    \"\"\"Check if user is logged-in on every page load.\"\"\"\n    if user_id is not None:\n        return User.query.get(user_id)\n    return None\n\n\n@login_manager.unauthorized_handler\ndef unauthorized():\n    \"\"\"Redirect unauthorized users to Login page.\"\"\"\n    flash('You must be logged in to view that page.')\n    return redirect(url_for('auth_bp.login_page'))\n\n\nOur first route, logout_page, handles the logic of users logging out. This will\nsimply end the user's session and redirect them to the login screen.\n\nload_user  is critical for making our app work: before every page load, our app\nmust verify whether or not the user is logged in (or still  logged in after time\nhas elapsed). user_loader  loads users by their unique ID. If a user is\nreturned, this signifies a logged-out user. Otherwise, when None  is returned,\nthe user is logged out.\n\nLastly, we have the unauthorized  route, which uses the unauthorized_handler \ndecorator for dealing with unauthorized users. Any time a user attempts to hit\nour app and is unauthorized, this route will fire.\n\nThe Last Piece: routes.py\nThe last thing we'll cover is how to protect parts of our app from unauthorized\nusers. Here's what we have in routes.py:\n\nimport os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask_login import current_user\nfrom flask import current_app as app\nfrom .models import User\nfrom flask_login import login_required\n\n\n# Blueprint Configuration\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@main_bp.route('/', methods=['GET'])\n@login_required\ndef dashboard():\n    \"\"\"Serve logged in Dashboard.\"\"\"\n    return render_template('dashboard.html',\n                           title='Flask-Login Tutorial.',\n                           template='dashboard-template',\n                           current_user=current_user,\n                           body=\"You are now logged in!\")\n\n\nThe magic here is all contained within the @login_required  decorator. When this\ndecorator is present on a route, the following things happen:\n\n * The @login_manager.user_loader  route we created determines whether or not\n   the user is authorized to view the page (logged in). If the user is logged\n   in, they'll be permitted to view the page.\n * If the user is not logged in, the user will be redirected as per the logic in\n   the route decorated with @login_manager.unauthorized_handler.\n * The name of the route the user attempted to access will be stored in the URL\n   as ?url=[name-of-route]. This what allows next  to work.\n\nThere You Have It\nIf you've made it this far, I commend you for your courage. To reward your\naccomplishments, I've published the source code for this tutorial on Github\n[https://github.com/toddbirchard/flasklogin-tutorial]  for your reference.\nGodspeed, brave adventurer.","html":"<p>We’ve covered a lot of Flask goodness in this series thus far. We fully understand how to structure a sensible application; we can serve up <a href=\"https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/\"><strong>complex page templates</strong></a>, and have dived into <a href=\"https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/\"><strong>interacting with databases using Flask-SQLAlchemy</strong></a>. For our next challenge, we’re going to need <em>all</em> of the knowledge we've acquired thus far and much, much more. Welcome to the Super Bowl of Flask development. This. Is. Flask-Login.</p><p><a href=\"https://flask-login.readthedocs.io/en/latest/\"><strong>Flask-Login</strong></a> is a dope library which handles all aspects of user management, including vital nuances you might not expect. Some noteworthy features include securing parts of our app behind login walls, encrypting passwords, and handling sessions. Moreover, It plays nicely with other Flask libraries we’re already familiar with: <a href=\"https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/\"><strong>Flask-SQLAlchemy</strong></a> to create and fetch accounts, and <a href=\"https://hackersandslackers.com/guide-to-building-forms-in-flask/\"><strong>Flask-WTForms</strong></a> for handling intelligent sign-up &amp; log-in forms. This tutorial assumes you have <em>some </em>working knowledge of these things.</p><p>Flask-Login is shockingly quite easy to use after the initial learning curve... but therein lies the catch. Perhaps I’m not the only one to have noticed, but most Flask-related documentation tends to be, well, God-awful. The community is riddled with helplessly outdated information; if you ever come across <code>flask.ext</code> in a tutorial, it is inherently worthless to anybody developing in 2019. To make matters worse, official Flask-Login documentation contains some artifacts which are just plain wrong. The documentation contradicts itself (I’ll show you what I mean), and offers little to no code examples to speak of. My only hope is that I might save somebody the endless headaches I’ve experienced myself.</p><h2 id=\"structuring-our-application\">Structuring Our Application</h2><p>Let’s start with installing dependencies. This should give you an idea of what you’re in for:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ pip3 install flask flask-login flask-sqlalchemy psycopg2-binary python-dotenv\n</code></pre>\n<!--kg-card-end: markdown--><p>Sweet. Let’s take this one step at a time, starting with our project file structure:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">flasklogin-tutorial\n├── /login_tutorial\n│   ├── __init__.py\n│   ├── auth.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── routes.py\n│   ├── /static\n│   │   ├── /dist\n│   │   │   ├── /css\n│   │   │   │   ├── account.css\n│   │   │   │   └── dashboard.css\n│   │   │   └── /js\n│   │   │       └── main.min.js\n│   │   └── /src\n│   │       ├── /js\n│   │       │   └── main.js\n│   │       └── /less\n│   │           ├── account.less\n│   │           ├── dashboard.less\n│   │           └── vars.less\n│   └── /templates\n│       ├── dashboard.html\n│       ├── layout.html\n│       ├── login.html\n│       ├── meta.html\n│       ├── scripts.html\n│       └── signup.html\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n</code></pre>\n<!--kg-card-end: markdown--><p>Of course, I wouldn't be a gentleman unless I revealed my <strong>config.py</strong> as well:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\n\n\nclass Config:\n    &quot;&quot;&quot;Set Flask configuration vars from .env file.&quot;&quot;&quot;\n\n    # General Config\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    FLASK_APP = os.environ.get('FLASK_APP')\n    FLASK_ENV = os.environ.get('FLASK_ENV')\n    FLASK_DEBUG = os.environ.get('FLASK_DEBUG')\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get('SQLALCHEMY_TRACK_MODIFICATIONS')\n</code></pre>\n<!--kg-card-end: markdown--><p>The configuration values live in a <code>.env</code> file, a practice I highly encourage. Of these configuration variables, <strong>SECRET_KEY</strong> is where we should turn our attention. SECRET_KEY is the equivalent of a password used to secure our app; it should be as long, nonsensical, and impossible-to-remember as humanly possible. Seriously: having your secret key compromised is the equivalent of feeding gremlins after midnight.</p><h2 id=\"initializing-flask-login\">Initializing Flask-Login</h2><p>With a standard \"application factory\" app, setting up Flask-Login is no different from other Flask plugins (or whatever they're called now). This makes setting up easy; all we need to do is make sure <strong>Flask-Login</strong> is initialized in <code>__init__.py</code> along with the rest of our plugins:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\n\n\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n\n    # Application Configuration\n    app.config.from_object('config.Config')\n\n    # Initialize Plugins\n    db.init_app(app)\n    login_manager.init_app(app)\n\n    with app.app_context():\n        # Import parts of our application\n        from . import routes\n        from . import login\n        app.register_blueprint(routes.main_bp)\n        app.register_blueprint(login.login_bp)\n\n        # Initialize Global db\n        db.create_all()\n\n        return app\n</code></pre>\n<!--kg-card-end: markdown--><p>In the above example, we're using the minimal number of plug-ins to get logins working: <strong>Flask-SQLAlchemy</strong> and <strong>Flask-Login</strong>.</p><p>To keep our sanity, we're going to separate our login routes from our main application routes and logic. This is why we register a Blueprint called <strong>auth_bp</strong>, imported from a file called <code>auth.py</code>. Our “main” application (AKA anything that isn’t logging in) will instead live in <code>routes.py</code>, in a Blueprint called <strong>main_bp</strong>. We'll come back to these in a moment</p><h2 id=\"creating-a-user-model\">Creating a User Model</h2><p>We'll save our <strong>User</strong> model in <code>models.py</code>. There are a few things to keep in mind when creating models compatible with Flask-Login- the most important being the utilization of <code>UserMixin</code> from the <code>flask_login</code> library. When we inherit our class from <strong>UserMixin,</strong> our model is immediately extended to include all the methods necessary for Flask-Login to work. This is by far the easiest way of creating a User model. I won't bother getting into details of what these methods do, because if you simply begin your class with <code>class User(UserMixin, db.Model):</code>, you genuinely don't need to understand any of it:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from . import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n\nclass User(UserMixin, db.Model):\n    &quot;&quot;&quot;Model for user accounts.&quot;&quot;&quot;\n\n    __tablename__ = 'flasklogin-users'\n\n    id = db.Column(db.Integer,\n                   primary_key=True,\n                   )\n    name = db.Column(db.String,\n                     nullable=False,\n                     unique=False)\n    email = db.Column(db.String(40),\n                      unique=True,\n                      nullable=False\n                      )\n    password = db.Column(db.String(200),\n                         primary_key=False,\n                         unique=False,\n                         nullable=False\n                         )\n    website = db.Column(db.String(60),\n                        index=False,\n                        unique=False,\n                        nullable=True\n                        )\n    created_on = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n    last_login = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n\n    def set_password(self, password):\n        &quot;&quot;&quot;Create hashed password.&quot;&quot;&quot;\n        self.password = generate_password_hash(password, method='sha256')\n\n    def check_password(self, password):\n        &quot;&quot;&quot;Check hashed password.&quot;&quot;&quot;\n        return check_password_hash(self.password, password)\n\n    def __repr__(self):\n        return '&lt;User {}&gt;'.format(self.username)\n</code></pre>\n<!--kg-card-end: markdown--><p>The <code>set_password</code> and <code>check_password</code> methods don't necessarily need to live inside our User model, but it's nice to keep related logic bundled together and out of our routes.</p><p>You may notice that our password field explicitly allows 200 characters: this is because our database will be storing hashed passwords. Thus, even if a user's password is 8 characters long, the string in our database will look much different.</p><h2 id=\"creating-log-in-and-sign-up-forms\">Creating Log-in and Sign-up Forms</h2><p>If you're well versed in <strong>WTForms</strong>, our form logic in <strong>forms.py</strong> probably looks as you'd expect. Of course, the constraints we set here are to handle front-end validation only:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from wtforms import Form, StringField, PasswordField, validators, SubmitField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length, Optional\n\n\nclass SignupForm(Form):\n    &quot;&quot;&quot;User Signup Form.&quot;&quot;&quot;\n\n    name = StringField('Name',\n                        validators=[DataRequired(message=('Enter a fake name or something.'))])\n    email = StringField('Email',\n                        validators=[Length(min=6, message=('Please enter a valid email address.')),\n                                    Email(message=('Please enter a valid email address.')),\n                                    DataRequired(message=('Please enter a valid email address.'))])\n    password = PasswordField('Password',\n                             validators=[DataRequired(message='Please enter a password.'),\n                                         Length(min=6, message=('Please select a stronger password.')),\n                                         EqualTo('confirm', message='Passwords must match')])\n    confirm = PasswordField('Confirm Your Password',)\n    website = StringField('Website',\n                          validators=[Optional()])\n    submit = SubmitField('Register')\n\n\nclass LoginForm(Form):\n    &quot;&quot;&quot;User Login Form.&quot;&quot;&quot;\n\n    email = StringField('Email', validators=[DataRequired('Please enter a valid email address.'),\n                                             Email('Please enter a valid email address.')])\n    password = PasswordField('Password', validators=[DataRequired('Uhh, your password tho?')])\n    submit = SubmitField('Log In')\n</code></pre>\n<!--kg-card-end: markdown--><p>With those out of the way, let's look at how we implement these on the Jinja side.</p><h3 id=\"signup-html\">signup.html</h3><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block pagestyles %}\n    &lt;link href=&quot;{{ url_for('static', filename='dist/css/account.css') }}&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;\n{% endblock %}\n\n{% block content %}\n  &lt;div class=&quot;formwrapper&quot;&gt;\n    &lt;form method=post&gt;\n      &lt;div class=&quot;logo&quot;&gt;\n        &lt;img src=&quot;{{ url_for('static', filename='dist/img/logo.png') }}&quot;&gt;\n      &lt;/div&gt;\n      {% for message in get_flashed_messages() %}\n        &lt;div class=&quot;alert alert-warning&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;\n            {{ message }}\n        &lt;/div&gt;\n      {% endfor %}\n      &lt;h1&gt;Sign Up&lt;/h1&gt;\n      &lt;div class=&quot;name&quot;&gt;\n        {{ form.name.label }}\n        {{ form.name(placeholder='John Smith') }}\n        {% if form.name.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;email&quot;&gt;\n        {{ form.email.label }}\n        {{ form.email(placeholder='youremail@example.com') }}\n        {% if form.email.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;password&quot;&gt;\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.password.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;confirm&quot;&gt;\n        {{ form.confirm.label }}\n        {{ form.confirm }}\n        {% if form.confirm.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.confirm.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;website&quot;&gt;\n        {{ form.website.label }}\n        {{ form.website(placeholder='http://example.com') }}\n      &lt;/div&gt;\n      &lt;div class=&quot;submitbutton&quot;&gt;\n        &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n      &lt;/div&gt;\n    &lt;/form&gt;\n    &lt;div class=&quot;loginsignup&quot;&gt;\n      &lt;span&gt;Already have an account? &lt;a href=&quot;{{ url_for('auth_bp.login_page') }}&quot;&gt;Log in.&lt;/a&gt;&lt;span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"login-py\">login.py</h3><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block pagestyles %}\n  &lt;link href=&quot;{{ url_for('static', filename='dist/css/account.css') }}&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;\n{% endblock %}\n\n{% block content %}\n  &lt;div class=&quot;formwrapper&quot;&gt;\n    &lt;form method=post&gt;\n      &lt;div class=&quot;logo&quot;&gt;\n        &lt;img src=&quot;{{ url_for('static', filename='dist/img/logo.png') }}&quot;&gt;\n      &lt;/div&gt;\n      {% for message in get_flashed_messages() %}\n        &lt;div class=&quot;alert alert-warning&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;\n            {{ message }}\n        &lt;/div&gt;\n      {% endfor %}\n      &lt;h1&gt;Log In&lt;/h1&gt;\n      &lt;div class=&quot;email&quot;&gt;\n         {{ form.email.label }}\n         {{ form.email(placeholder='youremail@example.com') }}\n         {% if form.email.errors %}\n           &lt;ul class=&quot;errors&quot;&gt;\n             {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n           &lt;/ul&gt;\n         {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;password&quot;&gt;\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.email.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;submitbutton&quot;&gt;\n        &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;loginsignup&quot;&gt;\n        &lt;span&gt;Don't have an account? &lt;a href=&quot;{{ url_for('auth_bp.signup_page') }}&quot;&gt;Sign up.&lt;/a&gt;&lt;span&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n{% endblock %}\n\n</code></pre>\n<!--kg-card-end: markdown--><p>Excellent: the stage is set to start kicking some ass.</p><h2 id=\"creating-our-login-routes\">Creating Our Login Routes</h2><p>Let us turn our attention to the heart of the logic we'll be writing in <strong>auth.py</strong>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nfrom flask import redirect, render_template, flash, Blueprint, request, session, url_for\nfrom flask_login import login_required, logout_user, current_user, login_user\nfrom flask import current_app as app\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom .forms import LoginForm, SignupForm\nfrom .models import db, User\nfrom . import login_manager\n\n\n# Blueprint Configuration\nauth_bp = Blueprint('auth_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    &quot;&quot;&quot;User login page.&quot;&quot;&quot;\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        ...\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=&quot;Log in with your User account.&quot;)\n\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    &quot;&quot;&quot;User sign-up page.&quot;&quot;&quot;\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        ...\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=&quot;Sign up for a user account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Here we find two separate skeleton routes for <strong>Sign up</strong> and <strong>Log in</strong>. Without the authentication logic added quite yet, these routes look almost identical thus far.</p><p>Each time a user visits a page in your app, the corresponding route is sent a <code>request</code> object. This object contains contextual information about the request made by the user, such as the type of request (GET or POST), any form data which was submitted, etc. We leverage this to see whether the user is just arriving at the page for the first time (a GET request), or if they're attempting to sign in (a POST request). The fairly clever takeaway here is that our login pages verify users by making POST requests to themselves: this allows us to keep all logic related to logging in or signing up in a single route.</p><h3 id=\"signing-up\">Signing Up</h3><p>We're able to validate the submitted form by importing the <code>SignupForm</code> class and passing <code>request.form</code> as the form in question. <code>if signup_form.validate()</code> checks the information submitted by the user against all the form's validators. If any of the validators are not met, the user is redirected back to the signup form with error messages present.</p><p>Assuming that our user isn't inept, we can move on with our logic. First, we need to make sure a user with the provided email doesn't already exist:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">...\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    &quot;&quot;&quot;User sign-up page.&quot;&quot;&quot;\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        if signup_form.validate():\n            # Get Form Fields\n            name = request.form.get('name')\n            email = request.form.get('email')\n            password = request.form.get('password')\n            website = request.form.get('website')\n            existing_user = User.query.filter_by(email=email).first()\n            if existing_user is None:\n                user = User(name=name,\n                            email=email,\n                            password=generate_password_hash(password, method='sha256'),\n                            website=website)\n                db.session.add(user)\n                db.session.commit()\n                login_user(user)\n                return redirect(url_for('main_bp.dashboard'))\n            flash('A user already exists with that email address.')\n            return redirect(url_for('auth_bp.signup_page'))\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=&quot;Sign up for a user account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>If <code>existing_user is None</code>, we're all clear to actually clear to create a new user record. We create an instance of our User model via <code>user = User(...)</code>. We then add the user via standard SQLAlchemy syntax and finally use the imported method <code>login_user()</code> to log the user in.</p><p>If everything goes well, the user will finally be redirected to the main application, which is handled by <code>return redirect(url_for('main_bp.dashboard'))</code>:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/signup.gif\" class=\"kg-image\"><figcaption>A successful user log in.</figcaption></figure><!--kg-card-end: image--><p>And here's what will happen if we log out and try to sign up with the same information:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/signupfailed.gif\" class=\"kg-image\"><figcaption>Attempting to sign up with an existing email</figcaption></figure><!--kg-card-end: image--><h3 id=\"logging-in\">Logging In</h3><p>Moving on to our login route:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    &quot;&quot;&quot;User login page.&quot;&quot;&quot;\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        if login_form.validate():\n            # Get Form Fields\n            email = request.form.get('email')\n            password = request.form.get('password')\n            # Validate Login Attempt\n            user = User.query.filter_by(email=email).first()\n            if user:\n                if user.check_password(password=password):\n                    login_user(user)\n                    next = request.args.get('next')\n                    return redirect(next or url_for('main_bp.dashboard'))\n        flash('Invalid username/password combination')\n        return redirect(url_for('auth_bp.login_page'))\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=&quot;Log in with your User account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>This should mostly look the same! our logic is identical up until the point where we check to see if the user exists. This time, a match results in success as opposed to a failure. Continuing, we then use <code>user.check_password()</code> to check the hashed password we created earlier with <code>user.generate_password_hash()</code>. Both of these methods handle the encrypting and decrypting of passwords on their own (based on that SECRET_KEY we created earlier) to ensure that nobody (not even us) has any business looking at user passwords.</p><p>As with last time, a successful login ends in <code>login_user(user)</code>. Our redirect logic is little more sophisticated this time around: instead of always sending the user back to the dashboard, we check for <code>next</code>, which is a parameter stored in the query string of the current user. If the user attempted to access our app before logging in, <code>next</code> would equal the page they had attempted to reach: this allows us wall-off our app from unauthorized users, and then drop users off at the page they attempted to reach before they logged in:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/login.gif\" class=\"kg-image\"><figcaption>A successful log in</figcaption></figure><!--kg-card-end: image--><h3 id=\"important-login-helpers\">IMPORTANT: Login Helpers</h3><p>Before your app can work like the above, we need to finish <strong>auth.py</strong> by providing a few more routes:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">@auth_bp.route(&quot;/logout&quot;)\n@login_required\ndef logout_page():\n    &quot;&quot;&quot;User log-out logic.&quot;&quot;&quot;\n    logout_user()\n    return redirect(url_for('auth_bp.login_page'))\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    &quot;&quot;&quot;Check if user is logged-in on every page load.&quot;&quot;&quot;\n    if user_id is not None:\n        return User.query.get(user_id)\n    return None\n\n\n@login_manager.unauthorized_handler\ndef unauthorized():\n    &quot;&quot;&quot;Redirect unauthorized users to Login page.&quot;&quot;&quot;\n    flash('You must be logged in to view that page.')\n    return redirect(url_for('auth_bp.login_page'))\n</code></pre>\n<!--kg-card-end: markdown--><p>Our first route, <code>logout_page</code>, handles the logic of users logging out. This will simply end the user's session and redirect them to the login screen.</p><p><code>load_user</code> is critical for making our app work: before every page load, our app must verify whether or not the user is logged in (or <em>still</em> logged in after time has elapsed). <code>user_loader</code> loads users by their unique ID. If a user is returned, this signifies a logged-out user. Otherwise, when <code>None</code> is returned, the user is logged out.</p><p>Lastly, we have the <code>unauthorized</code> route, which uses the <code>unauthorized_handler</code> decorator for dealing with unauthorized users. Any time a user attempts to hit our app and is unauthorized, this route will fire.</p><h2 id=\"the-last-piece-routes-py\">The Last Piece: routes.py</h2><p>The last thing we'll cover is how to protect parts of our app from unauthorized users. Here's what we have in <strong>routes.py</strong>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask_login import current_user\nfrom flask import current_app as app\nfrom .models import User\nfrom flask_login import login_required\n\n\n# Blueprint Configuration\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@main_bp.route('/', methods=['GET'])\n@login_required\ndef dashboard():\n    &quot;&quot;&quot;Serve logged in Dashboard.&quot;&quot;&quot;\n    return render_template('dashboard.html',\n                           title='Flask-Login Tutorial.',\n                           template='dashboard-template',\n                           current_user=current_user,\n                           body=&quot;You are now logged in!&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>The magic here is all contained within the <code>@login_required</code> decorator. When this decorator is present on a route, the following things happen:</p><ul><li>The <code>@login_manager.user_loader</code> route we created determines whether or not the user is authorized to view the page (logged in). If the user is logged in, they'll be permitted to view the page.</li><li>If the user is not logged in, the user will be redirected as per the logic in the route decorated with <code>@login_manager.unauthorized_handler</code>.</li><li>The name of the route the user attempted to access will be stored in the URL as <code>?url=[name-of-route]</code>. This what allows <code>next</code> to work.</li></ul><h3 id=\"there-you-have-it\">There You Have It</h3><p>If you've made it this far, I commend you for your courage. To reward your accomplishments, I've published the <a href=\"https://github.com/toddbirchard/flasklogin-tutorial\">source code for this tutorial on Github</a> for your reference. Godspeed, brave adventurer.</p>","url":"https://hackersandslackers.com/authenticating-users-with-flask-login/","uuid":"23a82e0a-31e7-49ea-8cc1-fecdd466bcfd","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c779ffbc380a221de39c7cf"}},"pageContext":{"slug":"authenticating-users-with-flask-login"}}