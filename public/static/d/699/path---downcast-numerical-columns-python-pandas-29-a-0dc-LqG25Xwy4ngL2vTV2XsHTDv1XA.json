{"data":{"ghostPost":{"id":"Ghost__Post__5c4e57144b23df2da7332b80","title":"Downcast Numerical Data Types with Pandas","slug":"downcast-numerical-columns-python-pandas","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","excerpt":"Using an Example Where We Downcast Numerical Columns.","custom_excerpt":"Using an Example Where We Downcast Numerical Columns.","created_at_pretty":"28 January, 2019","published_at_pretty":"28 January, 2019","updated_at_pretty":"14 February, 2019","created_at":"2019-01-27T20:12:52.000-05:00","published_at":"2019-01-28T07:30:00.000-05:00","updated_at":"2019-02-13T22:50:18.000-05:00","meta_title":"Using Pandas' Assign Function on Multiple Columns | Hackers and Slackers","meta_description":"Using Pandas' Assign function on multiple columns via an example: downcasting numerical columns.","og_description":"Using Pandas' Assign by example: downcasting numerical columns.","og_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","og_title":"Code Snippet Corner: Using Pandas' Assign Function on Multiple Columns","twitter_description":"Using Pandas' Assign by example: downcasting numerical columns.","twitter_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","twitter_title":"Code Snippet Corner: Using Pandas' Assign Function on Multiple Columns","authors":[{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null}],"primary_author":{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null},"primary_tag":{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#Code Snippet Corner","slug":"code-snippet-corner","description":"Your weekly dose of Python tidbits and Jupyter notebooks to get you feeling saucy.","feature_image":"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/codecornerseries_o_o.jpg","meta_description":"Your weekly dose of Python tidbits and Jupyter notebooks to get you feeling saucy.","meta_title":"Python Code Snippet Corner","visibility":"internal"}],"plaintext":"Recently, I had to find a way to reduce the memory footprint of a Pandas\nDataFrame in order to actually do operations on it.  Here's a trick that came in\nhandy!\n\nBy default, if you read a DataFrame from a file, it'll cast all the numerical\ncolumns as the float64  type.  This is in keeping with the philosophy behind\nPandas and NumPy - by using strict types (instead of normal Python \"duck\ntyping\"), you can do things a lot faster.  The float64  is the most flexible\nnumerical type - it can handle fractions, as well as turning missing values into\na NaN.  This will let us read it into memory, and then start messing with it.\n The downside is that it consumes a lot of memory.\n\nNow, let's say we want to save memory by manually downcasting our columns into\nthe smallest type that can handle its values?  And let's ALSO say that we want\nto be really, really lazy and don't want to look at a bunch of numbers by hand.\n And let's say we wanna do this via Method Chaining, because of all the\nadvantages outlined here: https://tomaugspurger.github.io/method-chaining\n\nLet's introduce our example DataFrame.  We'll convert all the values to floats\nmanually because that's what the default is when we read from a file.\n\ndf = pd.DataFrame({\n    \"stay_float\": [0.5, 3.7, 7.5],\n    \"to_int\": [-5, 7, 5],\n    \"to_uint\": [1, 100, 200]}).astype(float)\n\n\nFirst, let's introduce the workhorse of this exercise - Pandas's to_numeric \nfunction, and its handy optional argument, downcast.  This will take a numerical\ntype - float, integer  (not int), or unsigned  - and then downcast it to the\nsmallest version available.\n\nNext, let's make a function that checks to see if a column can be downcast from\na float to an integer.\n\ndef float_to_int(ser):\n    try:\n        int_ser = ser.astype(int)\n        if (ser == int_ser).all():\n            return int_ser\n        else:\n            return ser\n    except ValueError:\n        return ser\n\nWe're using the try/except pattern here because if we try to make a column with \nNaN  values into an integer column, it'll throw an error.  If it'd otherwise be\na good candidate for turning into an integer, we should figure a value to impute\nfor those missing values - but that'll be different for every column.  Sometimes\nit'd make sense to make it 0, other times the mean or median of the column, or\nsomething else entirely.\n\nI'd also like to direct your attention to Line 4, which has a very useful Pandas\npattern - if (ser == int_ser).all().  When you do operations on Pandas columns\nlike Equals or Greater Than, you get a new column where the operation was\napplied element-by-element.  If you're trying to set up a conditional, the\ninterpreter doesn't know what to do with an array containing [True, False, True] \n - you have to boil it down to a single value.  So, if you wan to check if two\ncolumns are completely equal, you have to call the .all()  method (which has a\nuseful sibling, any()) to make a conditional that can actually be used to\ncontrol execution.\n\nNext, let's make a function that lets us apply a transformation to multiple\ncolumns based on a condition.  The assign  method is pretty awesome, and it'd be\nfun to not have to leave it (or, if we do, to at least replace it with a\nfunction we can pipe as part of a chain of transformations to the DataFrame as a\nwhole).\n\ndef multi_assign(df, transform_fn, condition):\n    df_to_use = df.copy()\n    \n    return (df_to_use\n        .assign(\n            **{col: transform_fn(df_to_use[col])\n               for col in condition(df_to_use)})\n           )\n\n\nassign  lets us do multiple assignments, so long as we make a dictionary of\ncolumn names and target values and then unpack it.  Really, it'd actually be\neasier to skip the function and go directly to using this syntax, except that\nI'm not aware of a method of accessing a filterable list of the DF's columns\nwhile still \"in\" the chain.  I think future versions of Pandas' syntax will\ninclude this, as I've read they want to support more Method Chaining.\n Personally, I find the reduction in Cognitive Load is worth it, with having a\nlot of little modular lego-piece transformations chained together.\n\nIt also works as a nice foundation for other little helper functions.  So,\nhere's one to turn as many float columns to integers as we can.\n\ndef all_float_to_int(df):\n    df_to_use = df.copy()\n    transform_fn = float_to_int\n    condition = lambda x: list(x\n                    .select_dtypes(include=[\"float\"])\n                    .columns)    \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n\n\nSee the pattern in action!  We decide on a transformation function, we decide on\nwhat conditions we want to apply all these transformations (we could have a\nhundred columns, and who wants to make a note of all that?), and then we pass it\nto the multi-assign  function.\n\n(df\n     .pipe(all_float_to_int)).dtypes\n\n\nstay_float    float64\nto_int          int64\nto_uint         int64\ndtype: object\n\n\nCool!  But we didn't actually decrease the size of our DataFrame - 64 bytes of\ninteger takes up as many bytes as 64 bytes of float, just like how a hundred\npounds of feathers weighs as much as a hundred pounds of bricks.  What we did do\nis make it easier to downcast those columns later.\n\nNext, let's make a function that takes a subset of the columns, and tries to\ndowncast it to the smallest version that it can.  We've got fairly small values\nhere, so it should get some work done.\n\ndef downcast_all(df, target_type, inital_type=None):\n    #Gotta specify floats, unsigned, or integer\n    #If integer, gotta be 'integer', not 'int'\n    #Unsigned should look for Ints\n    if inital_type is None:\n        inital_type = target_type\n    \n    df_to_use = df.copy()\n    \n    transform_fn = lambda x: pd.to_numeric(x, \n                                downcast=target_type)\n    \n    condition = lambda x: list(x\n                    .select_dtypes(include=[inital_type])\n                    .columns) \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n\n\nSame basic pattern as before!  But now we have two arguments - one is the \ntarget_type, which tells us what types to try to downcast to.  By default, this\nwill be the same as the initial_type, with one exception that we'll grab in a\nsecond!\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n).dtypes\n\n\nstay_float    float32\nto_int           int8\nto_uint         int16\ndtype: object\n\n\nAlright, now we're getting somewhere!  Wonder if we can do even better, though?\n That last column has a conspicuous name!  And it has no values lower than 0 -\nmaybe we could save space if we store it as an unsigned integer!  Let's add a\npipe to our chain that'll try to downcast certain integers into unsigneds...\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n     .pipe(downcast_all,  \n           target_type = \"unsigned\", \n           inital_type = \"integer\")\n).dtypes\n\n\nstay_float    float32\nto_int           int8\nto_uint         uint8\ndtype: objec\n\n\nWhat do ya know, we can!\n\nLet's see how much memory we save by doing this.\n\ndf.info(memory_usage='deep')\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float64\nto_int        3 non-null float64\nto_uint       3 non-null float64\ndtypes: float64(3)\nmemory usage: 152.0 bytes\n\n\nvs\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n     .pipe(downcast_all,  \n           target_type = \"unsigned\", \n           inital_type = \"integer\")\n).info(memory_usage='deep')\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float32\nto_int        3 non-null int8\nto_uint       3 non-null uint8\ndtypes: float32(1), int8(1), uint8(1)\nmemory usage: 98.0 bytes\n\n\n152 down to 98 - we reduced it by more than 1/3rd!","html":"<p>Recently, I had to find a way to reduce the memory footprint of a Pandas DataFrame in order to actually do operations on it.  Here's a trick that came in handy!</p><p>By default, if you read a DataFrame from a file, it'll cast all the numerical columns as the <code>float64</code> type.  This is in keeping with the philosophy behind Pandas and NumPy - by using strict types (instead of normal Python \"duck typing\"), you can do things a lot faster.  The <code>float64</code> is the most flexible numerical type - it can handle fractions, as well as turning missing values into a <code>NaN</code>.  This will let us read it into memory, and then start messing with it.  The downside is that it consumes a lot of memory.</p><p>Now, let's say we want to save memory by manually downcasting our columns into the smallest type that can handle its values?  And let's ALSO say that we want to be really, really lazy and don't want to look at a bunch of numbers by hand.  And let's say we wanna do this via Method Chaining, because of all the advantages outlined here: <a href=\"https://tomaugspurger.github.io/method-chaining\">https://tomaugspurger.github.io/method-chaining</a></p><p>Let's introduce our example DataFrame.  We'll convert all the values to floats manually because that's what the default is when we read from a file.</p><pre><code class=\"language-python\">df = pd.DataFrame({\n    &quot;stay_float&quot;: [0.5, 3.7, 7.5],\n    &quot;to_int&quot;: [-5, 7, 5],\n    &quot;to_uint&quot;: [1, 100, 200]}).astype(float)\n</code></pre>\n<p>First, let's introduce the workhorse of this exercise - Pandas's <code>to_numeric</code> function, and its handy optional argument, <code>downcast</code>.  This will take a numerical type - <code>float</code>, <code>integer</code> (not <code>int</code>), or <code>unsigned</code> - and then downcast it to the smallest version available.</p><p>Next, let's make a function that checks to see if a column can be downcast from a float to an integer.</p><pre><code>def float_to_int(ser):\n    try:\n        int_ser = ser.astype(int)\n        if (ser == int_ser).all():\n            return int_ser\n        else:\n            return ser\n    except ValueError:\n        return ser</code></pre><p>We're using the try/except pattern here because if we try to make a column with <code>NaN</code> values into an integer column, it'll throw an error.  If it'd otherwise be a good candidate for turning into an integer, we should figure a value to impute for those missing values - but that'll be different for every column.  Sometimes it'd make sense to make it 0, other times the mean or median of the column, or something else entirely.</p><p>I'd also like to direct your attention to Line 4, which has a very useful Pandas pattern - <code>if (ser == int_ser).all()</code>.  When you do operations on Pandas columns like Equals or Greater Than, you get a new column where the operation was applied element-by-element.  If you're trying to set up a conditional, the interpreter doesn't know what to do with an array containing <code>[True, False, True]</code> - you have to boil it down to a single value.  So, if you wan to check if two columns are completely equal, you have to call the <code>.all()</code> method (which has a useful sibling, <code>any()</code>) to make a conditional that can actually be used to control execution.</p><p>Next, let's make a function that lets us apply a transformation to multiple columns based on a condition.  The <code>assign</code> method is pretty awesome, and it'd be fun to not have to leave it (or, if we do, to at least replace it with a function we can pipe as part of a chain of transformations to the DataFrame as a whole).</p><pre><code class=\"language-python\">def multi_assign(df, transform_fn, condition):\n    df_to_use = df.copy()\n    \n    return (df_to_use\n        .assign(\n            **{col: transform_fn(df_to_use[col])\n               for col in condition(df_to_use)})\n           )\n</code></pre>\n<p><code>assign</code> lets us do multiple assignments, so long as we make a dictionary of column names and target values and then unpack it.  Really, it'd actually be easier to skip the function and go directly to using this syntax, except that I'm not aware of a method of accessing a filterable list of the DF's columns while still \"in\" the chain.  I think future versions of Pandas' syntax will include this, as I've read they want to support more Method Chaining.  Personally, I find the reduction in Cognitive Load is worth it, with having a lot of little modular lego-piece transformations chained together.  </p><p>It also works as a nice foundation for other little helper functions.  So, here's one to turn as many float columns to integers as we can.</p><pre><code class=\"language-python\">def all_float_to_int(df):\n    df_to_use = df.copy()\n    transform_fn = float_to_int\n    condition = lambda x: list(x\n                    .select_dtypes(include=[&quot;float&quot;])\n                    .columns)    \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n</code></pre>\n<p>See the pattern in action!  We decide on a transformation function, we decide on what conditions we want to apply all these transformations (we could have a hundred columns, and who wants to make a note of all that?), and then we pass it to the <code>multi-assign</code> function.  </p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float64\nto_int          int64\nto_uint         int64\ndtype: object\n</code></pre>\n<p>Cool!  But we didn't actually decrease the size of our DataFrame - 64 bytes of integer takes up as many bytes as 64 bytes of float, just like how a hundred pounds of feathers weighs as much as a hundred pounds of bricks.  What we did do is make it easier to downcast those columns later.</p><p>Next, let's make a function that takes a subset of the columns, and tries to downcast it to the smallest version that it can.  We've got fairly small values here, so it should get some work done.</p><pre><code class=\"language-python\">def downcast_all(df, target_type, inital_type=None):\n    #Gotta specify floats, unsigned, or integer\n    #If integer, gotta be 'integer', not 'int'\n    #Unsigned should look for Ints\n    if inital_type is None:\n        inital_type = target_type\n    \n    df_to_use = df.copy()\n    \n    transform_fn = lambda x: pd.to_numeric(x, \n                                downcast=target_type)\n    \n    condition = lambda x: list(x\n                    .select_dtypes(include=[inital_type])\n                    .columns) \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n</code></pre>\n<p>Same basic pattern as before!  But now we have two arguments - one is the <code>target_type</code>, which tells us what types to try to downcast to.  By default, this will be the same as the <code>initial_type</code>, with one exception that we'll grab in a second!</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float32\nto_int           int8\nto_uint         int16\ndtype: object\n</code></pre>\n<p>Alright, now we're getting somewhere!  Wonder if we can do even better, though?  That last column has a conspicuous name!  And it has no values lower than 0 - maybe we could save space if we store it as an unsigned integer!  Let's add a pipe to our chain that'll try to downcast certain integers into unsigneds...</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n     .pipe(downcast_all,  \n           target_type = &quot;unsigned&quot;, \n           inital_type = &quot;integer&quot;)\n).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float32\nto_int           int8\nto_uint         uint8\ndtype: objec\n</code></pre>\n<p>What do ya know, we can!</p><p>Let's see how much memory we save by doing this.</p><pre><code class=\"language-python\">df.info(memory_usage='deep')\n</code></pre>\n<pre><code class=\"language-bash\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float64\nto_int        3 non-null float64\nto_uint       3 non-null float64\ndtypes: float64(3)\nmemory usage: 152.0 bytes\n</code></pre>\n<p>vs</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n     .pipe(downcast_all,  \n           target_type = &quot;unsigned&quot;, \n           inital_type = &quot;integer&quot;)\n).info(memory_usage='deep')\n</code></pre>\n<pre><code class=\"language-bash\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float32\nto_int        3 non-null int8\nto_uint       3 non-null uint8\ndtypes: float32(1), int8(1), uint8(1)\nmemory usage: 98.0 bytes\n</code></pre>\n<p>152 down to 98 - we reduced it by more than 1/3rd!</p>","url":"https://hackersandslackers.com/downcast-numerical-columns-python-pandas/","uuid":"58bbb902-99bb-404d-8a3c-232d56b6e776","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c4e57144b23df2da7332b80"}},"pageContext":{"slug":"downcast-numerical-columns-python-pandas"}}