{"data":{"ghostTag":{"slug":"flask","name":"Flask","visibility":"public","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications."},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5c779ffbc380a221de39c7cf","title":"Using Flask-Login to Handle User Accounts","slug":"authenticating-users-with-flask-login","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin.jpg","excerpt":"Add user authentication to your Flask app with Flask-Login","custom_excerpt":"Add user authentication to your Flask app with Flask-Login","created_at_pretty":"28 February, 2019","published_at_pretty":"04 April, 2019","updated_at_pretty":"07 April, 2019","created_at":"2019-02-28T03:46:51.000-05:00","published_at":"2019-04-04T18:36:51.000-04:00","updated_at":"2019-04-07T14:15:17.000-04:00","meta_title":"Authenticating Users With Flask-Login | Hackers and Slackers","meta_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","og_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","og_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin-2.jpg","og_title":"Authenticating Users With Flask-Login","twitter_description":"Adding user authentication to your Flask app with the Flask-Login Python library. Manage user creation, log-ins, signups, and application security.","twitter_image":"https://hackersandslackers.com/content/images/2019/04/flasklogin-1.jpg","twitter_title":"Authenticating Users With Flask-Login","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"We’ve covered a lot of Flask goodness in this series thus far. We fully\nunderstand how to structure a sensible application; we can serve up complex\npage\ntemplates\n[https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/],\nand have dived into interacting with databases using Flask-SQLAlchemy\n[https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/].\nFor our next challenge, we’re going to need all  of the knowledge we've acquired\nthus far and much, much more. Welcome to the Super Bowl of Flask development.\nThis. Is. Flask-Login.\n\nFlask-Login [https://flask-login.readthedocs.io/en/latest/]  is a dope library\nwhich handles all aspects of user management, including vital nuances you might\nnot expect. Some noteworthy features include securing parts of our app behind\nlogin walls, encrypting passwords, and handling sessions. Moreover, It plays\nnicely with other Flask libraries we’re already familiar with: Flask-SQLAlchemy\n[https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/] \nto create and fetch accounts, and Flask-WTForms\n[https://hackersandslackers.com/guide-to-building-forms-in-flask/]  for handling\nintelligent sign-up & log-in forms. This tutorial assumes you have some working\nknowledge of these things.\n\nFlask-Login is shockingly quite easy to use after the initial learning curve...\nbut therein lies the catch. Perhaps I’m not the only one to have noticed, but\nmost Flask-related documentation tends to be, well, God-awful. The community is\nriddled with helplessly outdated information; if you ever come across flask.ext \nin a tutorial, it is inherently worthless to anybody developing in 2019. To make\nmatters worse, official Flask-Login documentation contains some artifacts which\nare just plain wrong. The documentation contradicts itself (I’ll show you what I\nmean), and offers little to no code examples to speak of. My only hope is that I\nmight save somebody the endless headaches I’ve experienced myself.\n\nStructuring Our Application\nLet’s start with installing dependencies. This should give you an idea of what\nyou’re in for:\n\n$ pip3 install flask flask-login flask-sqlalchemy psycopg2-binary python-dotenv\n\n\nSweet. Let’s take this one step at a time, starting with our project file\nstructure:\n\nflasklogin-tutorial\n├── /login_tutorial\n│   ├── __init__.py\n│   ├── auth.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── routes.py\n│   ├── /static\n│   │   ├── /dist\n│   │   │   ├── /css\n│   │   │   │   ├── account.css\n│   │   │   │   └── dashboard.css\n│   │   │   └── /js\n│   │   │       └── main.min.js\n│   │   └── /src\n│   │       ├── /js\n│   │       │   └── main.js\n│   │       └── /less\n│   │           ├── account.less\n│   │           ├── dashboard.less\n│   │           └── vars.less\n│   └── /templates\n│       ├── dashboard.html\n│       ├── layout.html\n│       ├── login.html\n│       ├── meta.html\n│       ├── scripts.html\n│       └── signup.html\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n\n\nOf course, I wouldn't be a gentleman unless I revealed my config.py  as well:\n\nimport os\n\n\nclass Config:\n    \"\"\"Set Flask configuration vars from .env file.\"\"\"\n\n    # General Config\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    FLASK_APP = os.environ.get('FLASK_APP')\n    FLASK_ENV = os.environ.get('FLASK_ENV')\n    FLASK_DEBUG = os.environ.get('FLASK_DEBUG')\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get('SQLALCHEMY_TRACK_MODIFICATIONS')\n\n\nThe configuration values live in a .env  file, a practice I highly encourage. Of\nthese configuration variables, SECRET_KEY  is where we should turn our\nattention. SECRET_KEY is the equivalent of a password used to secure our app; it\nshould be as long, nonsensical, and impossible-to-remember as humanly possible.\nSeriously: having your secret key compromised is the equivalent of feeding\ngremlins after midnight.\n\nInitializing Flask-Login\nWith a standard \"application factory\" app, setting up Flask-Login is no\ndifferent from other Flask plugins (or whatever they're called now). This makes\nsetting up easy; all we need to do is make sure Flask-Login  is initialized in \n__init__.py  along with the rest of our plugins:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\n\n\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n\n    # Application Configuration\n    app.config.from_object('config.Config')\n\n    # Initialize Plugins\n    db.init_app(app)\n    login_manager.init_app(app)\n\n    with app.app_context():\n        # Import parts of our application\n        from . import routes\n        from . import login\n        app.register_blueprint(routes.main_bp)\n        app.register_blueprint(login.login_bp)\n\n        # Initialize Global db\n        db.create_all()\n\n        return app\n\n\nIn the above example, we're using the minimal number of plug-ins to get logins\nworking: Flask-SQLAlchemy  and Flask-Login.\n\nTo keep our sanity, we're going to separate our login routes from our main\napplication routes and logic. This is why we register a Blueprint called auth_bp\n, imported from a file called auth.py. Our “main” application (AKA anything that\nisn’t logging in) will instead live in routes.py, in a Blueprint called main_bp.\nWe'll come back to these in a moment\n\nCreating a User Model\nWe'll save our User  model in models.py. There are a few things to keep in mind\nwhen creating models compatible with Flask-Login- the most important being the\nutilization of UserMixin  from the flask_login  library. When we inherit our\nclass from UserMixin,  our model is immediately extended to include all the\nmethods necessary for Flask-Login to work. This is by far the easiest way of\ncreating a User model. I won't bother getting into details of what these methods\ndo, because if you simply begin your class with class User(UserMixin, db.Model):\n, you genuinely don't need to understand any of it:\n\nfrom . import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n\nclass User(UserMixin, db.Model):\n    \"\"\"Model for user accounts.\"\"\"\n\n    __tablename__ = 'flasklogin-users'\n\n    id = db.Column(db.Integer,\n                   primary_key=True,\n                   )\n    name = db.Column(db.String,\n                     nullable=False,\n                     unique=False)\n    email = db.Column(db.String(40),\n                      unique=True,\n                      nullable=False\n                      )\n    password = db.Column(db.String(200),\n                         primary_key=False,\n                         unique=False,\n                         nullable=False\n                         )\n    website = db.Column(db.String(60),\n                        index=False,\n                        unique=False,\n                        nullable=True\n                        )\n    created_on = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n    last_login = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n\n    def set_password(self, password):\n        \"\"\"Create hashed password.\"\"\"\n        self.password = generate_password_hash(password, method='sha256')\n\n    def check_password(self, password):\n        \"\"\"Check hashed password.\"\"\"\n        return check_password_hash(self.password, password)\n\n    def __repr__(self):\n        return '<User {}>'.format(self.username)\n\n\nThe set_password  and check_password  methods don't necessarily need to live\ninside our User model, but it's nice to keep related logic bundled together and\nout of our routes.\n\nYou may notice that our password field explicitly allows 200 characters: this is\nbecause our database will be storing hashed passwords. Thus, even if a user's\npassword is 8 characters long, the string in our database will look much\ndifferent.\n\nCreating Log-in and Sign-up Forms\nIf you're well versed in WTForms, our form logic in forms.py  probably looks as\nyou'd expect. Of course, the constraints we set here are to handle front-end\nvalidation only:\n\nfrom wtforms import Form, StringField, PasswordField, validators, SubmitField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length, Optional\n\n\nclass SignupForm(Form):\n    \"\"\"User Signup Form.\"\"\"\n\n    name = StringField('Name',\n                        validators=[DataRequired(message=('Enter a fake name or something.'))])\n    email = StringField('Email',\n                        validators=[Length(min=6, message=('Please enter a valid email address.')),\n                                    Email(message=('Please enter a valid email address.')),\n                                    DataRequired(message=('Please enter a valid email address.'))])\n    password = PasswordField('Password',\n                             validators=[DataRequired(message='Please enter a password.'),\n                                         Length(min=6, message=('Please select a stronger password.')),\n                                         EqualTo('confirm', message='Passwords must match')])\n    confirm = PasswordField('Confirm Your Password',)\n    website = StringField('Website',\n                          validators=[Optional()])\n    submit = SubmitField('Register')\n\n\nclass LoginForm(Form):\n    \"\"\"User Login Form.\"\"\"\n\n    email = StringField('Email', validators=[DataRequired('Please enter a valid email address.'),\n                                             Email('Please enter a valid email address.')])\n    password = PasswordField('Password', validators=[DataRequired('Uhh, your password tho?')])\n    submit = SubmitField('Log In')\n\n\nWith those out of the way, let's look at how we implement these on the Jinja\nside.\n\nsignup.html\n{% extends \"layout.html\" %}\n\n{% block pagestyles %}\n    <link href=\"{{ url_for('static', filename='dist/css/account.css') }}\" rel=\"stylesheet\" type=\"text/css\">\n{% endblock %}\n\n{% block content %}\n  <div class=\"formwrapper\">\n    <form method=post>\n      <div class=\"logo\">\n        <img src=\"{{ url_for('static', filename='dist/img/logo.png') }}\">\n      </div>\n      {% for message in get_flashed_messages() %}\n        <div class=\"alert alert-warning\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n            {{ message }}\n        </div>\n      {% endfor %}\n      <h1>Sign Up</h1>\n      <div class=\"name\">\n        {{ form.name.label }}\n        {{ form.name(placeholder='John Smith') }}\n        {% if form.name.errors %}\n          <ul class=\"errors\">\n            {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"email\">\n        {{ form.email.label }}\n        {{ form.email(placeholder='youremail@example.com') }}\n        {% if form.email.errors %}\n          <ul class=\"errors\">\n            {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"password\">\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.password.errors %}\n          <ul class=\"errors\">\n            {% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"confirm\">\n        {{ form.confirm.label }}\n        {{ form.confirm }}\n        {% if form.confirm.errors %}\n          <ul class=\"errors\">\n            {% for error in form.confirm.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"website\">\n        {{ form.website.label }}\n        {{ form.website(placeholder='http://example.com') }}\n      </div>\n      <div class=\"submitbutton\">\n        <input id=\"submit\" type=\"submit\" value=\"Submit\">\n      </div>\n    </form>\n    <div class=\"loginsignup\">\n      <span>Already have an account? <a href=\"{{ url_for('auth_bp.login_page') }}\">Log in.</a><span>\n    </div>\n  </div>\n{% endblock %}\n\n\n\nlogin.py\n{% extends \"layout.html\" %}\n\n{% block pagestyles %}\n  <link href=\"{{ url_for('static', filename='dist/css/account.css') }}\" rel=\"stylesheet\" type=\"text/css\">\n{% endblock %}\n\n{% block content %}\n  <div class=\"formwrapper\">\n    <form method=post>\n      <div class=\"logo\">\n        <img src=\"{{ url_for('static', filename='dist/img/logo.png') }}\">\n      </div>\n      {% for message in get_flashed_messages() %}\n        <div class=\"alert alert-warning\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n            {{ message }}\n        </div>\n      {% endfor %}\n      <h1>Log In</h1>\n      <div class=\"email\">\n         {{ form.email.label }}\n         {{ form.email(placeholder='youremail@example.com') }}\n         {% if form.email.errors %}\n           <ul class=\"errors\">\n             {% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}\n           </ul>\n         {% endif %}\n      </div>\n      <div class=\"password\">\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.email.errors %}\n          <ul class=\"errors\">\n            {% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}\n          </ul>\n        {% endif %}\n      </div>\n      <div class=\"submitbutton\">\n        <input id=\"submit\" type=\"submit\" value=\"Submit\">\n      </div>\n      <div class=\"loginsignup\">\n        <span>Don't have an account? <a href=\"{{ url_for('auth_bp.signup_page') }}\">Sign up.</a><span>\n        </div>\n    </form>\n  </div>\n{% endblock %}\n\n\n\nExcellent: the stage is set to start kicking some ass.\n\nCreating Our Login Routes\nLet us turn our attention to the heart of the logic we'll be writing in auth.py:\n\nimport os\nfrom flask import redirect, render_template, flash, Blueprint, request, session, url_for\nfrom flask_login import login_required, logout_user, current_user, login_user\nfrom flask import current_app as app\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom .forms import LoginForm, SignupForm\nfrom .models import db, User\nfrom . import login_manager\n\n\n# Blueprint Configuration\nauth_bp = Blueprint('auth_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    \"\"\"User login page.\"\"\"\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        ...\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=\"Log in with your User account.\")\n\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    \"\"\"User sign-up page.\"\"\"\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        ...\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=\"Sign up for a user account.\")\n\n\nHere we find two separate skeleton routes for Sign up  and Log in. Without the\nauthentication logic added quite yet, these routes look almost identical thus\nfar.\n\nEach time a user visits a page in your app, the corresponding route is sent a \nrequest  object. This object contains contextual information about the request\nmade by the user, such as the type of request (GET or POST), any form data which\nwas submitted, etc. We leverage this to see whether the user is just arriving at\nthe page for the first time (a GET request), or if they're attempting to sign in\n(a POST request). The fairly clever takeaway here is that our login pages verify\nusers by making POST requests to themselves: this allows us to keep all logic\nrelated to logging in or signing up in a single route.\n\nSigning Up\nWe're able to validate the submitted form by importing the SignupForm  class and\npassing request.form  as the form in question. if signup_form.validate()  checks\nthe information submitted by the user against all the form's validators. If any\nof the validators are not met, the user is redirected back to the signup form\nwith error messages present.\n\nAssuming that our user isn't inept, we can move on with our logic. First, we\nneed to make sure a user with the provided email doesn't already exist:\n\n...\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    \"\"\"User sign-up page.\"\"\"\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        if signup_form.validate():\n            # Get Form Fields\n            name = request.form.get('name')\n            email = request.form.get('email')\n            password = request.form.get('password')\n            website = request.form.get('website')\n            existing_user = User.query.filter_by(email=email).first()\n            if existing_user is None:\n                user = User(name=name,\n                            email=email,\n                            password=generate_password_hash(password, method='sha256'),\n                            website=website)\n                db.session.add(user)\n                db.session.commit()\n                login_user(user)\n                return redirect(url_for('main_bp.dashboard'))\n            flash('A user already exists with that email address.')\n            return redirect(url_for('auth_bp.signup_page'))\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=\"Sign up for a user account.\")\n\n\nIf existing_user is None, we're all clear to actually clear to create a new user\nrecord. We create an instance of our User model via user = User(...). We then\nadd the user via standard SQLAlchemy syntax and finally use the imported method \nlogin_user()  to log the user in.\n\nIf everything goes well, the user will finally be redirected to the main\napplication, which is handled by return redirect(url_for('main_bp.dashboard')):\n\nA successful user log in.And here's what will happen if we log out and try to\nsign up with the same information:\n\nAttempting to sign up with an existing emailLogging In\nMoving on to our login route:\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    \"\"\"User login page.\"\"\"\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        if login_form.validate():\n            # Get Form Fields\n            email = request.form.get('email')\n            password = request.form.get('password')\n            # Validate Login Attempt\n            user = User.query.filter_by(email=email).first()\n            if user:\n                if user.check_password(password=password):\n                    login_user(user)\n                    next = request.args.get('next')\n                    return redirect(next or url_for('main_bp.dashboard'))\n        flash('Invalid username/password combination')\n        return redirect(url_for('auth_bp.login_page'))\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=\"Log in with your User account.\")\n\n\nThis should mostly look the same! our logic is identical up until the point\nwhere we check to see if the user exists. This time, a match results in success\nas opposed to a failure. Continuing, we then use user.check_password()  to check\nthe hashed password we created earlier with user.generate_password_hash(). Both\nof these methods handle the encrypting and decrypting of passwords on their own\n(based on that SECRET_KEY we created earlier) to ensure that nobody (not even\nus) has any business looking at user passwords.\n\nAs with last time, a successful login ends in login_user(user). Our redirect\nlogic is little more sophisticated this time around: instead of always sending\nthe user back to the dashboard, we check for next, which is a parameter stored\nin the query string of the current user. If the user attempted to access our app\nbefore logging in, next  would equal the page they had attempted to reach: this\nallows us wall-off our app from unauthorized users, and then drop users off at\nthe page they attempted to reach before they logged in:\n\nA successful log inIMPORTANT: Login Helpers\nBefore your app can work like the above, we need to finish auth.py  by providing\na few more routes:\n\n@auth_bp.route(\"/logout\")\n@login_required\ndef logout_page():\n    \"\"\"User log-out logic.\"\"\"\n    logout_user()\n    return redirect(url_for('auth_bp.login_page'))\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    \"\"\"Check if user is logged-in on every page load.\"\"\"\n    if user_id is not None:\n        return User.query.get(user_id)\n    return None\n\n\n@login_manager.unauthorized_handler\ndef unauthorized():\n    \"\"\"Redirect unauthorized users to Login page.\"\"\"\n    flash('You must be logged in to view that page.')\n    return redirect(url_for('auth_bp.login_page'))\n\n\nOur first route, logout_page, handles the logic of users logging out. This will\nsimply end the user's session and redirect them to the login screen.\n\nload_user  is critical for making our app work: before every page load, our app\nmust verify whether or not the user is logged in (or still  logged in after time\nhas elapsed). user_loader  loads users by their unique ID. If a user is\nreturned, this signifies a logged-out user. Otherwise, when None  is returned,\nthe user is logged out.\n\nLastly, we have the unauthorized  route, which uses the unauthorized_handler \ndecorator for dealing with unauthorized users. Any time a user attempts to hit\nour app and is unauthorized, this route will fire.\n\nThe Last Piece: routes.py\nThe last thing we'll cover is how to protect parts of our app from unauthorized\nusers. Here's what we have in routes.py:\n\nimport os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask_login import current_user\nfrom flask import current_app as app\nfrom .models import User\nfrom flask_login import login_required\n\n\n# Blueprint Configuration\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@main_bp.route('/', methods=['GET'])\n@login_required\ndef dashboard():\n    \"\"\"Serve logged in Dashboard.\"\"\"\n    return render_template('dashboard.html',\n                           title='Flask-Login Tutorial.',\n                           template='dashboard-template',\n                           current_user=current_user,\n                           body=\"You are now logged in!\")\n\n\nThe magic here is all contained within the @login_required  decorator. When this\ndecorator is present on a route, the following things happen:\n\n * The @login_manager.user_loader  route we created determines whether or not\n   the user is authorized to view the page (logged in). If the user is logged\n   in, they'll be permitted to view the page.\n * If the user is not logged in, the user will be redirected as per the logic in\n   the route decorated with @login_manager.unauthorized_handler.\n * The name of the route the user attempted to access will be stored in the URL\n   as ?url=[name-of-route]. This what allows next  to work.\n\nThere You Have It\nIf you've made it this far, I commend you for your courage. To reward your\naccomplishments, I've published the source code for this tutorial on Github\n[https://github.com/toddbirchard/flasklogin-tutorial]  for your reference.\nGodspeed, brave adventurer.","html":"<p>We’ve covered a lot of Flask goodness in this series thus far. We fully understand how to structure a sensible application; we can serve up <a href=\"https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/\"><strong>complex page templates</strong></a>, and have dived into <a href=\"https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/\"><strong>interacting with databases using Flask-SQLAlchemy</strong></a>. For our next challenge, we’re going to need <em>all</em> of the knowledge we've acquired thus far and much, much more. Welcome to the Super Bowl of Flask development. This. Is. Flask-Login.</p><p><a href=\"https://flask-login.readthedocs.io/en/latest/\"><strong>Flask-Login</strong></a> is a dope library which handles all aspects of user management, including vital nuances you might not expect. Some noteworthy features include securing parts of our app behind login walls, encrypting passwords, and handling sessions. Moreover, It plays nicely with other Flask libraries we’re already familiar with: <a href=\"https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/\"><strong>Flask-SQLAlchemy</strong></a> to create and fetch accounts, and <a href=\"https://hackersandslackers.com/guide-to-building-forms-in-flask/\"><strong>Flask-WTForms</strong></a> for handling intelligent sign-up &amp; log-in forms. This tutorial assumes you have <em>some </em>working knowledge of these things.</p><p>Flask-Login is shockingly quite easy to use after the initial learning curve... but therein lies the catch. Perhaps I’m not the only one to have noticed, but most Flask-related documentation tends to be, well, God-awful. The community is riddled with helplessly outdated information; if you ever come across <code>flask.ext</code> in a tutorial, it is inherently worthless to anybody developing in 2019. To make matters worse, official Flask-Login documentation contains some artifacts which are just plain wrong. The documentation contradicts itself (I’ll show you what I mean), and offers little to no code examples to speak of. My only hope is that I might save somebody the endless headaches I’ve experienced myself.</p><h2 id=\"structuring-our-application\"><strong>Structuring Our Application</strong></h2><p>Let’s start with installing dependencies. This should give you an idea of what you’re in for:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ pip3 install flask flask-login flask-sqlalchemy psycopg2-binary python-dotenv\n</code></pre>\n<!--kg-card-end: markdown--><p>Sweet. Let’s take this one step at a time, starting with our project file structure:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">flasklogin-tutorial\n├── /login_tutorial\n│   ├── __init__.py\n│   ├── auth.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── routes.py\n│   ├── /static\n│   │   ├── /dist\n│   │   │   ├── /css\n│   │   │   │   ├── account.css\n│   │   │   │   └── dashboard.css\n│   │   │   └── /js\n│   │   │       └── main.min.js\n│   │   └── /src\n│   │       ├── /js\n│   │       │   └── main.js\n│   │       └── /less\n│   │           ├── account.less\n│   │           ├── dashboard.less\n│   │           └── vars.less\n│   └── /templates\n│       ├── dashboard.html\n│       ├── layout.html\n│       ├── login.html\n│       ├── meta.html\n│       ├── scripts.html\n│       └── signup.html\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n</code></pre>\n<!--kg-card-end: markdown--><p>Of course, I wouldn't be a gentleman unless I revealed my <strong>config.py</strong> as well:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\n\n\nclass Config:\n    &quot;&quot;&quot;Set Flask configuration vars from .env file.&quot;&quot;&quot;\n\n    # General Config\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    FLASK_APP = os.environ.get('FLASK_APP')\n    FLASK_ENV = os.environ.get('FLASK_ENV')\n    FLASK_DEBUG = os.environ.get('FLASK_DEBUG')\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get('SQLALCHEMY_TRACK_MODIFICATIONS')\n</code></pre>\n<!--kg-card-end: markdown--><p>The configuration values live in a <code>.env</code> file, a practice I highly encourage. Of these configuration variables, <strong>SECRET_KEY</strong> is where we should turn our attention. SECRET_KEY is the equivalent of a password used to secure our app; it should be as long, nonsensical, and impossible-to-remember as humanly possible. Seriously: having your secret key compromised is the equivalent of feeding gremlins after midnight.</p><h2 id=\"initializing-flask-login\">Initializing Flask-Login</h2><p>With a standard \"application factory\" app, setting up Flask-Login is no different from other Flask plugins (or whatever they're called now). This makes setting up easy; all we need to do is make sure <strong>Flask-Login</strong> is initialized in <code>__init__.py</code> along with the rest of our plugins:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\n\n\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n\n    # Application Configuration\n    app.config.from_object('config.Config')\n\n    # Initialize Plugins\n    db.init_app(app)\n    login_manager.init_app(app)\n\n    with app.app_context():\n        # Import parts of our application\n        from . import routes\n        from . import login\n        app.register_blueprint(routes.main_bp)\n        app.register_blueprint(login.login_bp)\n\n        # Initialize Global db\n        db.create_all()\n\n        return app\n</code></pre>\n<!--kg-card-end: markdown--><p>In the above example, we're using the minimal number of plug-ins to get logins working: <strong>Flask-SQLAlchemy</strong> and <strong>Flask-Login</strong>.</p><p>To keep our sanity, we're going to separate our login routes from our main application routes and logic. This is why we register a Blueprint called <strong>auth_bp</strong>, imported from a file called <code>auth.py</code>. Our “main” application (AKA anything that isn’t logging in) will instead live in <code>routes.py</code>, in a Blueprint called <strong>main_bp</strong>. We'll come back to these in a moment</p><h2 id=\"creating-a-user-model\">Creating a User Model</h2><p>We'll save our <strong>User</strong> model in <code>models.py</code>. There are a few things to keep in mind when creating models compatible with Flask-Login- the most important being the utilization of <code>UserMixin</code> from the <code>flask_login</code> library. When we inherit our class from <strong>UserMixin,</strong> our model is immediately extended to include all the methods necessary for Flask-Login to work. This is by far the easiest way of creating a User model. I won't bother getting into details of what these methods do, because if you simply begin your class with <code>class User(UserMixin, db.Model):</code>, you genuinely don't need to understand any of it:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from . import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n\nclass User(UserMixin, db.Model):\n    &quot;&quot;&quot;Model for user accounts.&quot;&quot;&quot;\n\n    __tablename__ = 'flasklogin-users'\n\n    id = db.Column(db.Integer,\n                   primary_key=True,\n                   )\n    name = db.Column(db.String,\n                     nullable=False,\n                     unique=False)\n    email = db.Column(db.String(40),\n                      unique=True,\n                      nullable=False\n                      )\n    password = db.Column(db.String(200),\n                         primary_key=False,\n                         unique=False,\n                         nullable=False\n                         )\n    website = db.Column(db.String(60),\n                        index=False,\n                        unique=False,\n                        nullable=True\n                        )\n    created_on = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n    last_login = db.Column(db.DateTime,\n                           index=False,\n                           unique=False,\n                           nullable=True\n                           )\n\n    def set_password(self, password):\n        &quot;&quot;&quot;Create hashed password.&quot;&quot;&quot;\n        self.password = generate_password_hash(password, method='sha256')\n\n    def check_password(self, password):\n        &quot;&quot;&quot;Check hashed password.&quot;&quot;&quot;\n        return check_password_hash(self.password, password)\n\n    def __repr__(self):\n        return '&lt;User {}&gt;'.format(self.username)\n</code></pre>\n<!--kg-card-end: markdown--><p>The <code>set_password</code> and <code>check_password</code> methods don't necessarily need to live inside our User model, but it's nice to keep related logic bundled together and out of our routes.</p><p>You may notice that our password field explicitly allows 200 characters: this is because our database will be storing hashed passwords. Thus, even if a user's password is 8 characters long, the string in our database will look much different.</p><h2 id=\"creating-log-in-and-sign-up-forms\">Creating Log-in and Sign-up Forms</h2><p>If you're well versed in <strong>WTForms</strong>, our form logic in <strong>forms.py</strong> probably looks as you'd expect. Of course, the constraints we set here are to handle front-end validation only:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from wtforms import Form, StringField, PasswordField, validators, SubmitField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length, Optional\n\n\nclass SignupForm(Form):\n    &quot;&quot;&quot;User Signup Form.&quot;&quot;&quot;\n\n    name = StringField('Name',\n                        validators=[DataRequired(message=('Enter a fake name or something.'))])\n    email = StringField('Email',\n                        validators=[Length(min=6, message=('Please enter a valid email address.')),\n                                    Email(message=('Please enter a valid email address.')),\n                                    DataRequired(message=('Please enter a valid email address.'))])\n    password = PasswordField('Password',\n                             validators=[DataRequired(message='Please enter a password.'),\n                                         Length(min=6, message=('Please select a stronger password.')),\n                                         EqualTo('confirm', message='Passwords must match')])\n    confirm = PasswordField('Confirm Your Password',)\n    website = StringField('Website',\n                          validators=[Optional()])\n    submit = SubmitField('Register')\n\n\nclass LoginForm(Form):\n    &quot;&quot;&quot;User Login Form.&quot;&quot;&quot;\n\n    email = StringField('Email', validators=[DataRequired('Please enter a valid email address.'),\n                                             Email('Please enter a valid email address.')])\n    password = PasswordField('Password', validators=[DataRequired('Uhh, your password tho?')])\n    submit = SubmitField('Log In')\n</code></pre>\n<!--kg-card-end: markdown--><p>With those out of the way, let's look at how we implement these on the Jinja side.</p><h3 id=\"signup-html\">signup.html</h3><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block pagestyles %}\n    &lt;link href=&quot;{{ url_for('static', filename='dist/css/account.css') }}&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;\n{% endblock %}\n\n{% block content %}\n  &lt;div class=&quot;formwrapper&quot;&gt;\n    &lt;form method=post&gt;\n      &lt;div class=&quot;logo&quot;&gt;\n        &lt;img src=&quot;{{ url_for('static', filename='dist/img/logo.png') }}&quot;&gt;\n      &lt;/div&gt;\n      {% for message in get_flashed_messages() %}\n        &lt;div class=&quot;alert alert-warning&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;\n            {{ message }}\n        &lt;/div&gt;\n      {% endfor %}\n      &lt;h1&gt;Sign Up&lt;/h1&gt;\n      &lt;div class=&quot;name&quot;&gt;\n        {{ form.name.label }}\n        {{ form.name(placeholder='John Smith') }}\n        {% if form.name.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;email&quot;&gt;\n        {{ form.email.label }}\n        {{ form.email(placeholder='youremail@example.com') }}\n        {% if form.email.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;password&quot;&gt;\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.password.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;confirm&quot;&gt;\n        {{ form.confirm.label }}\n        {{ form.confirm }}\n        {% if form.confirm.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.confirm.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;website&quot;&gt;\n        {{ form.website.label }}\n        {{ form.website(placeholder='http://example.com') }}\n      &lt;/div&gt;\n      &lt;div class=&quot;submitbutton&quot;&gt;\n        &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n      &lt;/div&gt;\n    &lt;/form&gt;\n    &lt;div class=&quot;loginsignup&quot;&gt;\n      &lt;span&gt;Already have an account? &lt;a href=&quot;{{ url_for('auth_bp.login_page') }}&quot;&gt;Log in.&lt;/a&gt;&lt;span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n{% endblock %}\n\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"login-py\">login.py</h3><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block pagestyles %}\n  &lt;link href=&quot;{{ url_for('static', filename='dist/css/account.css') }}&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;\n{% endblock %}\n\n{% block content %}\n  &lt;div class=&quot;formwrapper&quot;&gt;\n    &lt;form method=post&gt;\n      &lt;div class=&quot;logo&quot;&gt;\n        &lt;img src=&quot;{{ url_for('static', filename='dist/img/logo.png') }}&quot;&gt;\n      &lt;/div&gt;\n      {% for message in get_flashed_messages() %}\n        &lt;div class=&quot;alert alert-warning&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;\n            {{ message }}\n        &lt;/div&gt;\n      {% endfor %}\n      &lt;h1&gt;Log In&lt;/h1&gt;\n      &lt;div class=&quot;email&quot;&gt;\n         {{ form.email.label }}\n         {{ form.email(placeholder='youremail@example.com') }}\n         {% if form.email.errors %}\n           &lt;ul class=&quot;errors&quot;&gt;\n             {% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n           &lt;/ul&gt;\n         {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;password&quot;&gt;\n        {{ form.password.label }}\n        {{ form.password }}\n        {% if form.email.errors %}\n          &lt;ul class=&quot;errors&quot;&gt;\n            {% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}\n          &lt;/ul&gt;\n        {% endif %}\n      &lt;/div&gt;\n      &lt;div class=&quot;submitbutton&quot;&gt;\n        &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;loginsignup&quot;&gt;\n        &lt;span&gt;Don't have an account? &lt;a href=&quot;{{ url_for('auth_bp.signup_page') }}&quot;&gt;Sign up.&lt;/a&gt;&lt;span&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n{% endblock %}\n\n</code></pre>\n<!--kg-card-end: markdown--><p>Excellent: the stage is set to start kicking some ass.</p><h2 id=\"creating-our-login-routes\">Creating Our Login Routes</h2><p>Let us turn our attention to the heart of the logic we'll be writing in <strong>auth.py</strong>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nfrom flask import redirect, render_template, flash, Blueprint, request, session, url_for\nfrom flask_login import login_required, logout_user, current_user, login_user\nfrom flask import current_app as app\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom .forms import LoginForm, SignupForm\nfrom .models import db, User\nfrom . import login_manager\n\n\n# Blueprint Configuration\nauth_bp = Blueprint('auth_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    &quot;&quot;&quot;User login page.&quot;&quot;&quot;\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        ...\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=&quot;Log in with your User account.&quot;)\n\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    &quot;&quot;&quot;User sign-up page.&quot;&quot;&quot;\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        ...\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=&quot;Sign up for a user account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Here we find two separate skeleton routes for <strong>Sign up</strong> and <strong>Log in</strong>. Without the authentication logic added quite yet, these routes look almost identical thus far.</p><p>Each time a user visits a page in your app, the corresponding route is sent a <code>request</code> object. This object contains contextual information about the request made by the user, such as the type of request (GET or POST), any form data which was submitted, etc. We leverage this to see whether the user is just arriving at the page for the first time (a GET request), or if they're attempting to sign in (a POST request). The fairly clever takeaway here is that our login pages verify users by making POST requests to themselves: this allows us to keep all logic related to logging in or signing up in a single route.</p><h3 id=\"signing-up\">Signing Up</h3><p>We're able to validate the submitted form by importing the <code>SignupForm</code> class and passing <code>request.form</code> as the form in question. <code>if signup_form.validate()</code> checks the information submitted by the user against all the form's validators. If any of the validators are not met, the user is redirected back to the signup form with error messages present.</p><p>Assuming that our user isn't inept, we can move on with our logic. First, we need to make sure a user with the provided email doesn't already exist:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">...\n\n@auth_bp.route('/signup', methods=['GET', 'POST'])\ndef signup_page():\n    &quot;&quot;&quot;User sign-up page.&quot;&quot;&quot;\n    signup_form = SignupForm(request.form)\n    # POST: Sign user in\n    if request.method == 'POST':\n        if signup_form.validate():\n            # Get Form Fields\n            name = request.form.get('name')\n            email = request.form.get('email')\n            password = request.form.get('password')\n            website = request.form.get('website')\n            existing_user = User.query.filter_by(email=email).first()\n            if existing_user is None:\n                user = User(name=name,\n                            email=email,\n                            password=generate_password_hash(password, method='sha256'),\n                            website=website)\n                db.session.add(user)\n                db.session.commit()\n                login_user(user)\n                return redirect(url_for('main_bp.dashboard'))\n            flash('A user already exists with that email address.')\n            return redirect(url_for('auth_bp.signup_page'))\n    # GET: Serve Sign-up page\n    return render_template('/signup.html',\n                           title='Create an Account | Flask-Login Tutorial.',\n                           form=SignupForm(),\n                           template='signup-page',\n                           body=&quot;Sign up for a user account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>If <code>existing_user is None</code>, we're all clear to actually clear to create a new user record. We create an instance of our User model via <code>user = User(...)</code>. We then add the user via standard SQLAlchemy syntax and finally use the imported method <code>login_user()</code> to log the user in.</p><p>If everything goes well, the user will finally be redirected to the main application, which is handled by <code>return redirect(url_for('main_bp.dashboard'))</code>:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/signup.gif\" class=\"kg-image\"><figcaption>A successful user log in.</figcaption></figure><!--kg-card-end: image--><p>And here's what will happen if we log out and try to sign up with the same information:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/signupfailed.gif\" class=\"kg-image\"><figcaption>Attempting to sign up with an existing email</figcaption></figure><!--kg-card-end: image--><h3 id=\"logging-in\">Logging In</h3><p>Moving on to our login route:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login_page():\n    &quot;&quot;&quot;User login page.&quot;&quot;&quot;\n    # Bypass Login screen if user is logged in\n    if current_user.is_authenticated:\n        return redirect(url_for('main_bp.dashboard'))\n    login_form = LoginForm(request.form)\n    # POST: Create user and redirect them to the app\n    if request.method == 'POST':\n        if login_form.validate():\n            # Get Form Fields\n            email = request.form.get('email')\n            password = request.form.get('password')\n            # Validate Login Attempt\n            user = User.query.filter_by(email=email).first()\n            if user:\n                if user.check_password(password=password):\n                    login_user(user)\n                    next = request.args.get('next')\n                    return redirect(next or url_for('main_bp.dashboard'))\n        flash('Invalid username/password combination')\n        return redirect(url_for('auth_bp.login_page'))\n    # GET: Serve Log-in page\n    return render_template('login.html',\n                           form=LoginForm(),\n                           title='Log in | Flask-Login Tutorial.',\n                           template='login-page',\n                           body=&quot;Log in with your User account.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>This should mostly look the same! our logic is identical up until the point where we check to see if the user exists. This time, a match results in success as opposed to a failure. Continuing, we then use <code>user.check_password()</code> to check the hashed password we created earlier with <code>user.generate_password_hash()</code>. Both of these methods handle the encrypting and decrypting of passwords on their own (based on that SECRET_KEY we created earlier) to ensure that nobody (not even us) has any business looking at user passwords.</p><p>As with last time, a successful login ends in <code>login_user(user)</code>. Our redirect logic is little more sophisticated this time around: instead of always sending the user back to the dashboard, we check for <code>next</code>, which is a parameter stored in the query string of the current user. If the user attempted to access our app before logging in, <code>next</code> would equal the page they had attempted to reach: this allows us wall-off our app from unauthorized users, and then drop users off at the page they attempted to reach before they logged in:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/login.gif\" class=\"kg-image\"><figcaption>A successful log in</figcaption></figure><!--kg-card-end: image--><h3 id=\"important-login-helpers\">IMPORTANT: Login Helpers</h3><p>Before your app can work like the above, we need to finish <strong>auth.py</strong> by providing a few more routes:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">@auth_bp.route(&quot;/logout&quot;)\n@login_required\ndef logout_page():\n    &quot;&quot;&quot;User log-out logic.&quot;&quot;&quot;\n    logout_user()\n    return redirect(url_for('auth_bp.login_page'))\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    &quot;&quot;&quot;Check if user is logged-in on every page load.&quot;&quot;&quot;\n    if user_id is not None:\n        return User.query.get(user_id)\n    return None\n\n\n@login_manager.unauthorized_handler\ndef unauthorized():\n    &quot;&quot;&quot;Redirect unauthorized users to Login page.&quot;&quot;&quot;\n    flash('You must be logged in to view that page.')\n    return redirect(url_for('auth_bp.login_page'))\n</code></pre>\n<!--kg-card-end: markdown--><p>Our first route, <code>logout_page</code>, handles the logic of users logging out. This will simply end the user's session and redirect them to the login screen.</p><p><code>load_user</code> is critical for making our app work: before every page load, our app must verify whether or not the user is logged in (or <em>still</em> logged in after time has elapsed). <code>user_loader</code> loads users by their unique ID. If a user is returned, this signifies a logged-out user. Otherwise, when <code>None</code> is returned, the user is logged out.</p><p>Lastly, we have the <code>unauthorized</code> route, which uses the <code>unauthorized_handler</code> decorator for dealing with unauthorized users. Any time a user attempts to hit our app and is unauthorized, this route will fire.</p><h2 id=\"the-last-piece-routes-py\">The Last Piece: routes.py</h2><p>The last thing we'll cover is how to protect parts of our app from unauthorized users. Here's what we have in <strong>routes.py</strong>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask_login import current_user\nfrom flask import current_app as app\nfrom .models import User\nfrom flask_login import login_required\n\n\n# Blueprint Configuration\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\n\n\n@main_bp.route('/', methods=['GET'])\n@login_required\ndef dashboard():\n    &quot;&quot;&quot;Serve logged in Dashboard.&quot;&quot;&quot;\n    return render_template('dashboard.html',\n                           title='Flask-Login Tutorial.',\n                           template='dashboard-template',\n                           current_user=current_user,\n                           body=&quot;You are now logged in!&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>The magic here is all contained within the <code>@login_required</code> decorator. When this decorator is present on a route, the following things happen:</p><ul><li>The <code>@login_manager.user_loader</code> route we created determines whether or not the user is authorized to view the page (logged in). If the user is logged in, they'll be permitted to view the page.</li><li>If the user is not logged in, the user will be redirected as per the logic in the route decorated with <code>@login_manager.unauthorized_handler</code>.</li><li>The name of the route the user attempted to access will be stored in the URL as <code>?url=[name-of-route]</code>. This what allows <code>next</code> to work.</li></ul><h3 id=\"there-you-have-it\">There You Have It</h3><p>If you've made it this far, I commend you for your courage. To reward your accomplishments, I've published the <a href=\"https://github.com/toddbirchard/flasklogin-tutorial\">source code for this tutorial on Github</a> for your reference. Godspeed, brave adventurer.</p>","url":"https://hackersandslackers.com/authenticating-users-with-flask-login/","uuid":"23a82e0a-31e7-49ea-8cc1-fecdd466bcfd","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c779ffbc380a221de39c7cf"}},{"node":{"id":"Ghost__Post__5c5a3e362c71af62216fd45e","title":"Manage Database Models with Flask-SQLAlchemy","slug":"manage-database-models-with-flask-sqlalchemy","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-sqlalchemy2.jpg","excerpt":"Connect your Flask app to a database using Flask-SQLAlchemy.","custom_excerpt":"Connect your Flask app to a database using Flask-SQLAlchemy.","created_at_pretty":"06 February, 2019","published_at_pretty":"06 February, 2019","updated_at_pretty":"03 April, 2019","created_at":"2019-02-05T20:53:58.000-05:00","published_at":"2019-02-06T08:00:00.000-05:00","updated_at":"2019-04-03T11:38:02.000-04:00","meta_title":"Manage Database Models with Flask-SQLAlchemy | Hackers and Slackers","meta_description":"Connect your Flask application to a database using the Flask-SQLAlchemy library. The most important Flask library you'll ever use.","og_description":"Connect your Flask application to a database using the Flask-SQLAlchemy library. The most important Flask library you'll ever use.","og_image":"https://hackersandslackers.com/content/images/2019/03/flask-sqlalchemy2.jpg","og_title":"Manage Database Models with Flask-SQLAlchemy | Hackers and Slackers","twitter_description":"Connect your Flask application to a database using the Flask-SQLAlchemy library. The most important Flask library you'll ever use.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/flask-sqlalchemy2.jpg","twitter_title":"Manage Database Models with Flask-SQLAlchemy | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"By now you're surely familiar with the benefits of Python's core SQLAlchemy\nlibrary\n[https://hackersandslackers.com/pythonic-database-management-with-sqlalchemy/]:\nthe all-in-one solution for basically anything database related. Like most major\nPython libraries, SQLAlchemy has been ported into a version specifically\ncompatible with Flask, aptly named Flask-SQLAlchemy.\n\nSimilar to the core SQLAlchemy package, Flask-SQLAlchemy provides an ORM for us\nto modify application data by easily creating defined models. Regardless of what\nyour database of choice might be, Flask-SQLAlchemy will ensure that the models\nwe create in Python will translate to the syntax of our chosen database. Given\nthe ease-of-use and one-size-fits-all  nature of Flask-SQLAlchemy, it's no\nwonder that the library has been the de facto database library of choice for\nFlask since the very beginning (seriously, is there even another option?)\n\nConfiguring Flask-SQLAlchemy For Your Application\nThere are a few essential configuration variables we need to set upfront before\ninteracting with our database. As is standard, we'll be using a class defined in\n config.py  to handle our Flask config:\n\nimport os\n\n\nclass Config:\n    \"\"\"Set Flask configuration vars from .env file.\"\"\"\n    \n    # General\n    TESTING = os.environ[\"TESTING\"]\n    FLASK_DEBUG = os.environ[\"FLASK_DEBUG\"]\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get(\"SQLALCHEMY_DATABASE_URI\")\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get(\"SQLALCHEMY_TRACK_MODIFICATIONS\")\n\n\nLet's break these down:\n\n * SQLALCHEMY_DATABASE_URI: the connection string we need to connect to our\n   database. This follows the standard convention: \n   [db_type]+[db_connector]://[username]:[password]@[host]:[port]/[db_name]\n * SQLALCHEMY_ECHO: When set to 'True', Flask-SQLAlchemy will log all database\n   activity to Python's stderr for debugging purposes.\n * SQLALCHEMY_TRACK_MODIFICATIONS: Honestly, I just always set this to 'False,'\n   otherwise an obnoxious warning appears every time you run your app reminding\n   you that this option takes a lot of system resources.\n\nThose are the big ones we should worry about. If you're into some next-level\ndatabase shit, there are a few other pro-mode configuration variables which you\ncan find here [http://flask-sqlalchemy.pocoo.org/2.3/config/].\n\nBy using the exact naming conventions for the variables above, simply having\nthem in our config file will automatically configure our database connections\nfor us. We will never have to create engines, sessions, or connections.\nInitiating Flask-SQLAlchemy With Our App\nAs always, we're going to use the Flask Application Factory method\n[https://hackersandslackers.com/structuring-your-flask-app/]  for initiating our\napp. If you're unfamiliar with the term, you're going to find this tutorial to\nbe confusing and pretty much useless.\n\nThe most basic __init__.py  file for Flask applications using Flask-SQLAlchemy\nshould look like this:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n    db.init_app(app)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Imports\n        from . import routes\n        \n        # Create tables for our models\n        db.create_all()\n\n        return app\n\n\nNote the presence of db  and its location: this our database object being set as\na global  variable outside of create_app(). Inside of create_app(), on the other\nhand, contains the line db.init_app(app). Even though we've set our db object\nglobally, this means nothing until we initialize it after creating our\napplication. We accomplish this by calling init_app()  within create_app(), and\npassing our app as the parameter. Within the actual 'application context' is\nwhere we'll call create_all(), which we'll cover in a bit.\n\nIf that last paragraph sounded like total gibberish to you, you are not alone. \nThe Flask Application Factory is perhaps one of the most odd and poorly\nexplained concepts in Python software development- my best advice is to not\nbecome frustrated, take the copy + paste code above, and blindly accept the\nspoon-fed nonsense enough times until it becomes second nature. That's what I\ndid, and even as I worked through this tutorial, I still  came across obnoxious\nquirks that caught me off-guard.\n\nTake note of import we make inside of the application context called routes.\nThis is one of two files we haven't written just yet: once we create them, our\napplication file structure will look something like this:\n\nmy-app\n├── /application\n│   ├── __init__.py\n│   ├── routes.py\n│   ├── models.py\n├── .env\n├── config.py\n└── wsgi.py\n\n\nCreating Database Models\nCreate a models.py  file in our application directory. Here we'll import the db \nobject that we created in __init__.py. Now we can create database models by\ndefining classes in this file.\n\nA common example would be to start with a User  model. The first variable we\ncreate is __tablename__, which will correspond to the name of the SQL table new\nusers will be saved. Each additional variable we create within this model class\nwill correspond a column in the database:\n\nfrom . import db\n\n\nclass User(db.Model):\n    \"\"\"Model for user accounts.\"\"\"\n\n    __tablename__ = 'users'\n    id = db.Column(db.Integer,\n                   primary_key=True\n                   )\n    username = db.Column(db.String(64),\n                         index=False,\n                         unique=True,\n                         nullable=False\n                         )\n    email = db.Column(db.String(80),\n                      index=True,\n                      unique=True,\n                      nullable=False\n                      )\n    created = db.Column(db.DateTime,\n                        index=False,\n                        unique=False,\n                        nullable=False\n                        )\n    bio = db.Column(db.Text,\n                    index=False,\n                    unique=False,\n                    nullable=True\n                    )\n    admin = db.Column(db.Boolean,\n                      index=False,\n                      unique=False,\n                      nullable=False\n                      )\n    \n    def __repr__(self):\n        return '<User {}>'.format(self.username)\n\n\nEach \"column\" accepts the following attributes:\n\n * Data Type:  Accepts one of the following: String(size), Text, DateTime, Float\n   , Boolean, PickleType, or LargeBinary.\n * primary_key: Whether or not the column should serve as the primary key.\n * unique: Whether or not to enforce unique values for the column.\n * nullable: Denotes required fields.\n\nWith our first model created, you're already way closer to interacting with your\ndatabase than you might think.\n\nCreating Our First Entry\nLet's create a user in our routes.py  file.\n\nfrom flask import request, render_template, make_response\nfrom datetime import datetime as dt\nfrom flask import current_app as app\nfrom .models import db, User\n\n\n@app.route('/', methods=['GET'])\ndef entry():\n    \"\"\"Endpoint to create a user.\"\"\"\n    new_user = User(username='myuser',\n                    email='myuser@example.com',\n                    created=dt.now(),\n                    bio=\"In West Philadelphia born and raised, on the playground is where I spent most of my days\",\n                    admin=False\n                    )\n    db.session.add(new_user)\n    db.session.commit()\n    return make_response(\"User created!\")\n\n\nCheck out how easy this is! All it takes to create a user is create an instance\nof the User  class from models.py, add it to our session via \ndb.session.add(new_user), and commit the changes with db.session.commit()! Let's\nsee what happens when we run this app:\n\nUser Created!\n\n\nThat's what we like to see! If we access our database at this point, we can see\nthat this exact record was created in our users  table.\n\nQuerying Our New Data\nCreating information is dope, but how can we confirm it exists? I've added a few\nthings to routes.py  to show us what's up:\n\nfrom flask import request, render_template\nfrom datetime import datetime as dt\nfrom flask import current_app as app\nfrom .models import db, User\n\n\n@app.route('/', methods=['GET'])\ndef entry():\n    \"\"\"Endpoint to create a user.\"\"\"\n    new_user = User(username='myuser',\n                    email='myuser@example.com',\n                    created=dt.now(),\n                    bio=\"In West Philadelphia born and raised, on the playground is where I spent most of my days\",\n                    admin=False\n                    )\n    db.session.add(new_user)\n    db.session.commit()\n    users = User.query.all()\n    return render_template('users.html', users=users, title=\"Show Users\")\n\n\n  The statement User.query.all()  will return all instances of User  in our\ndatabase. I created a Jinja template to show us all records nicely:\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n  {% for user in users %}\n    <ul id=\"user.username\">\n      <li>Username: {{ user.username }}</li>\n      <li>Email: {{ user.email }}</li>\n      <li>Created: {{ user.created }}</li>\n      <li>Bio: {{ user.bio }}</li>\n      <li>Admin: {{ user.admin }}</li>\n    </ul>\n  {% endfor %}\n{% endblock %}\n\n\nThus, our app gives us:\n\nWe have liftoff!So we can get a single user, but what about a whole table full\nof users? Well, all we need to do is keep changing the username and email\naddress (our unique keys, to avoid a clash) when firing up the app, and each\ntime it runs, it'll create a new user. Here's what comes back after running the\napp a few times with different values:\n\nI Can't Believe It's Not Error Messages.™Here, Take All My Stuff\nSure, Flask-SQLAlchemy is great once you get going, but as we've already seen\n\"getting set up\" isn't always a walk in the park. This is one of those things\nthat always seems to be wrong no matter how many times you've done it from\nmemory.\n\nAs a parting gift, I've put the source for this tutorial up on Github\n[https://github.com/toddbirchard/flasksqlalchemy-tutorial]  for you to treasure\nand enjoy. No seriously, take it. Get it away from me. I'm done with Flask for\ntoday. I need to go play some Rocket League.\n\nPS: Add me on PSN","html":"<p>By now you're surely familiar with the benefits of Python's <a href=\"https://hackersandslackers.com/pythonic-database-management-with-sqlalchemy/\">core SQLAlchemy library</a>: the all-in-one solution for basically anything database related. Like most major Python libraries, SQLAlchemy has been ported into a version specifically compatible with Flask, aptly named <strong>Flask-SQLAlchemy</strong>.</p><p>Similar to the core SQLAlchemy package, Flask-SQLAlchemy provides an ORM for us to modify application data by easily creating defined models. Regardless of what your database of choice might be, Flask-SQLAlchemy will ensure that the models we create in Python will translate to the syntax of our chosen database. Given the ease-of-use and one-size-fits-all  nature of Flask-SQLAlchemy, it's no wonder that the library has been the de facto database library of choice for Flask since the very beginning (seriously, is there even another option?)</p><h2 id=\"configuring-flask-sqlalchemy-for-your-application\">Configuring Flask-SQLAlchemy For Your Application</h2><p>There are a few essential configuration variables we need to set upfront before interacting with our database. As is standard, we'll be using a class defined in <code>config.py</code> to handle our Flask config:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\n\n\nclass Config:\n    &quot;&quot;&quot;Set Flask configuration vars from .env file.&quot;&quot;&quot;\n    \n    # General\n    TESTING = os.environ[&quot;TESTING&quot;]\n    FLASK_DEBUG = os.environ[&quot;FLASK_DEBUG&quot;]\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ.get(&quot;SQLALCHEMY_DATABASE_URI&quot;)\n    SQLALCHEMY_TRACK_MODIFICATIONS = os.environ.get(&quot;SQLALCHEMY_TRACK_MODIFICATIONS&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Let's break these down:</p><ul><li><code>SQLALCHEMY_DATABASE_URI</code>: the connection string we need to connect to our database. This follows the standard convention: <code>[db_type]+[db_connector]://[username]:[password]@[host]:[port]/[db_name]</code></li><li><code>SQLALCHEMY_ECHO</code>: When set to 'True', Flask-SQLAlchemy will log all database activity to Python's stderr for debugging purposes.</li><li><code>SQLALCHEMY_TRACK_MODIFICATIONS</code>: Honestly, I just always set this to 'False,' otherwise an obnoxious warning appears every time you run your app reminding you that this option takes a lot of system resources.</li></ul><p>Those are the big ones we should worry about. If you're into some next-level database shit, there are a few other pro-mode configuration variables which you can find <a href=\"http://flask-sqlalchemy.pocoo.org/2.3/config/\">here</a>.</p><!--kg-card-begin: html--><div class=\"protip\">By using the exact naming conventions for the variables above, simply having them in our config file will automatically configure our database connections for us. We will never have to create engines, sessions, or connections.</div><!--kg-card-end: html--><h2 id=\"initiating-flask-sqlalchemy-with-our-app\">Initiating Flask-SQLAlchemy With Our App</h2><p>As always, we're going to use the <a href=\"https://hackersandslackers.com/structuring-your-flask-app/\">Flask Application Factory method</a> for initiating our app. If you're unfamiliar with the term, you're going to find this tutorial to be confusing and pretty much useless.</p><p>The most basic <code>__init__.py</code> file for Flask applications using Flask-SQLAlchemy should look like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n    db.init_app(app)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Imports\n        from . import routes\n        \n        # Create tables for our models\n        db.create_all()\n\n        return app\n</code></pre>\n<!--kg-card-end: markdown--><p>Note the presence of <code>db</code> and its location: this our database object being set as a <em>global</em> variable outside of <code>create_app()</code>. Inside of <code>create_app()</code>, on the other hand, contains the line <code>db.init_app(app)</code>. Even though we've set our db object globally, this means nothing until we initialize it after creating our application. We accomplish this by calling <code>init_app()</code> within <code>create_app()</code>, and passing our app as the parameter. Within the actual 'application context' is where we'll call <code>create_all()</code>, which we'll cover in a bit.</p><p>If that last paragraph sounded like total gibberish to you, <em>you are not alone.</em> The Flask Application Factory is perhaps one of the most odd and poorly explained concepts in Python software development- my best advice is to not become frustrated, take the copy + paste code above, and blindly accept the spoon-fed nonsense enough times until it becomes second nature. That's what I did, and even as I worked through this tutorial, I <em>still</em> came across obnoxious quirks that caught me off-guard.</p><p>Take note of import we make inside of the application context called <strong>routes</strong>. This is one of two files we haven't written just yet: once we create them, our application file structure will look something like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">my-app\n├── /application\n│   ├── __init__.py\n│   ├── routes.py\n│   ├── models.py\n├── .env\n├── config.py\n└── wsgi.py\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"creating-database-models\">Creating Database Models</h2><p>Create a <code>models.py</code> file in our application directory. Here we'll import the <code>db</code> object that we created in <code>__init__.py</code>. Now we can create database models by defining classes in this file.</p><p>A common example would be to start with a <strong>User</strong> model. The first variable we create is <code>__tablename__</code>, which will correspond to the name of the SQL table new users will be saved. Each additional variable we create within this model class will correspond a column in the database:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from . import db\n\n\nclass User(db.Model):\n    &quot;&quot;&quot;Model for user accounts.&quot;&quot;&quot;\n\n    __tablename__ = 'users'\n    id = db.Column(db.Integer,\n                   primary_key=True\n                   )\n    username = db.Column(db.String(64),\n                         index=False,\n                         unique=True,\n                         nullable=False\n                         )\n    email = db.Column(db.String(80),\n                      index=True,\n                      unique=True,\n                      nullable=False\n                      )\n    created = db.Column(db.DateTime,\n                        index=False,\n                        unique=False,\n                        nullable=False\n                        )\n    bio = db.Column(db.Text,\n                    index=False,\n                    unique=False,\n                    nullable=True\n                    )\n    admin = db.Column(db.Boolean,\n                      index=False,\n                      unique=False,\n                      nullable=False\n                      )\n    \n    def __repr__(self):\n        return '&lt;User {}&gt;'.format(self.username)\n</code></pre>\n<!--kg-card-end: markdown--><p>Each \"column\" accepts the following attributes:</p><ul><li><strong>Data Type:</strong> Accepts one of the following: <code>String(size)</code>, <code>Text</code>, <code>DateTime</code>, <code>Float</code>, <code>Boolean</code>, <code>PickleType</code>, or <code>LargeBinary</code>.</li><li><strong>primary_key</strong>: Whether or not the column should serve as the primary key.</li><li><strong>unique</strong>: Whether or not to enforce unique values for the column.</li><li><strong>nullable: </strong>Denotes required fields.</li></ul><p>With our first model created, you're already way closer to interacting with your database than you might think.</p><h2 id=\"creating-our-first-entry\">Creating Our First Entry</h2><p>Let's create a user in our <code>routes.py</code> file.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import request, render_template, make_response\nfrom datetime import datetime as dt\nfrom flask import current_app as app\nfrom .models import db, User\n\n\n@app.route('/', methods=['GET'])\ndef entry():\n    &quot;&quot;&quot;Endpoint to create a user.&quot;&quot;&quot;\n    new_user = User(username='myuser',\n                    email='myuser@example.com',\n                    created=dt.now(),\n                    bio=&quot;In West Philadelphia born and raised, on the playground is where I spent most of my days&quot;,\n                    admin=False\n                    )\n    db.session.add(new_user)\n    db.session.commit()\n    return make_response(&quot;User created!&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Check out how easy this is! All it takes to create a user is create an instance of the <code>User</code> class from <code>models.py</code>, add it to our session via <code>db.session.add(new_user)</code>, and commit the changes with <code>db.session.commit()</code>! Let's see what happens when we run this app:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">User Created!\n</code></pre>\n<!--kg-card-end: markdown--><p>That's what we like to see! If we access our database at this point, we can see that this exact record was created in our <em>users</em> table.</p><h2 id=\"querying-our-new-data\">Querying Our New Data</h2><p>Creating information is dope, but how can we confirm it exists? I've added a few things to <code>routes.py</code> to show us what's up:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import request, render_template\nfrom datetime import datetime as dt\nfrom flask import current_app as app\nfrom .models import db, User\n\n\n@app.route('/', methods=['GET'])\ndef entry():\n    &quot;&quot;&quot;Endpoint to create a user.&quot;&quot;&quot;\n    new_user = User(username='myuser',\n                    email='myuser@example.com',\n                    created=dt.now(),\n                    bio=&quot;In West Philadelphia born and raised, on the playground is where I spent most of my days&quot;,\n                    admin=False\n                    )\n    db.session.add(new_user)\n    db.session.commit()\n    users = User.query.all()\n    return render_template('users.html', users=users, title=&quot;Show Users&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p> The statement <code>User.query.all()</code> will return all instances of <code>User</code> in our database. I created a Jinja template to show us all records nicely:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block content %}\n  {% for user in users %}\n    &lt;ul id=&quot;user.username&quot;&gt;\n      &lt;li&gt;Username: {{ user.username }}&lt;/li&gt;\n      &lt;li&gt;Email: {{ user.email }}&lt;/li&gt;\n      &lt;li&gt;Created: {{ user.created }}&lt;/li&gt;\n      &lt;li&gt;Bio: {{ user.bio }}&lt;/li&gt;\n      &lt;li&gt;Admin: {{ user.admin }}&lt;/li&gt;\n    &lt;/ul&gt;\n  {% endfor %}\n{% endblock %}\n</code></pre>\n<!--kg-card-end: markdown--><p>Thus, our app gives us:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/04/flasksqlalchemy-test.png\" class=\"kg-image\"><figcaption>We have liftoff!</figcaption></figure><!--kg-card-end: image--><p>So we can get a single user, but what about a whole table full of users? Well, all we need to do is keep changing the username and email address (our unique keys, to avoid a clash) when firing up the app, and each time it runs, it'll create a new user. Here's what comes back after running the app a few times with different values:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2019-02-06-at-12.39.07-AM.png\" class=\"kg-image\"><figcaption>I Can't Believe It's Not Error Messages.<b>™</b></figcaption></figure><!--kg-card-end: image--><h3 id=\"here-take-all-my-stuff\">Here, Take All My Stuff</h3><p>Sure, Flask-SQLAlchemy is great once you get going, but as we've already seen \"getting set up\" isn't always a walk in the park. This is one of those things that always seems to be wrong no matter how many times you've done it from memory.</p><p>As a parting gift, I've put the source for this tutorial up <a href=\"https://github.com/toddbirchard/flasksqlalchemy-tutorial\">on Github</a> for you to treasure and enjoy. No seriously, take it. Get it away from me. I'm done with Flask for today. I need to go play some Rocket League.</p><!--kg-card-begin: html--><span style=\"color: #a7a7a7;font-style: italic;font-size:.9em;\">PS: Add me on PSN</span><!--kg-card-end: html-->","url":"https://hackersandslackers.com/manage-database-models-with-flask-sqlalchemy/","uuid":"e9fdcb15-3289-472f-8892-2e01cdaced9d","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c5a3e362c71af62216fd45e"}},{"node":{"id":"Ghost__Post__5c3fc99b89c81d4ccc3f64b1","title":"The Hostile Extraction of Tableau Server Data","slug":"hostile-extraction-of-tableau-server-data","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-2.jpg","excerpt":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","custom_excerpt":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","created_at_pretty":"17 January, 2019","published_at_pretty":"17 January, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-16T19:17:31.000-05:00","published_at":"2019-01-17T07:43:00.000-05:00","updated_at":"2019-03-28T11:06:50.000-04:00","meta_title":"The Hostile Extraction of Tableau Server Data | Hackers and Slackers","meta_description":"How to create a Python application to take back your Tableau data. Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","og_description":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","og_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-2.jpg","og_title":"The Hostile Extraction of Tableau Server Data","twitter_description":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-1.jpg","twitter_title":"The Hostile Extraction of Tableau Server Data","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"},{"name":"#Hacking Tableau Server","slug":"hacking-tableau-server","description":"Break free from the constraints of the TSM CLI to bend Tableau Server to your will. Uncover Superadmin privileges, or even rewire Tableau to handle ETL.","feature_image":"https://hackersandslackers.com/content/images/2019/03/tableauseries-2.jpg","meta_description":"Break free from the constraints of the TSM CLI to bend Tableau Server to your will. Uncover Superadmin privileges, or even rewire Tableau to handle ETL.","meta_title":"Hacking Tableau Server","visibility":"internal"},{"name":"BI","slug":"business-intelligence","description":"Business Intelligence, otherwise known as \"making nice reports for executives to ignore.\"","feature_image":null,"meta_description":null,"meta_title":"Business Intelligence Tools | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"}],"plaintext":"I try my best not to hate on Tableau. It was the software’s combination of power\nand ease-of-use that drove me to purchase a license in the first place. Ever\nsince then, I’m finding new and exciting ways Tableau intentionally locks users\nout of their data. \n\nI gave the Tableau Server Client Python library\n[https://tableau.github.io/server-client-python/docs/]  a spin recently in hopes\nof finding something useful. I decided to (sigh, once more) allow Tableau the\nbenefit of the doubt: after pushing four updates in a single month, maybe things\nhad changed. On the contrary, the Tableau business strategy stands strong: to be\na raging, flaming turd pile. A perfect example of this is the View  object\nTableau allows you to interact with on your server. Those familiar know that \nviews  are slang for sheets  of workbooks  stored on Tableau server. \n\nConnecting to your Tableau instance via Python to retrieve your view objects is\na piece of cake:\n\nimport tableauserverclient as TSC\ntableau_auth = TSC.TableauAuth('username', 'password')\nserver = TSC.Server('http://servername')\n\nwith server.auth.sign_in(tableau_auth):\n  all_views, pagination_item = server.views.get()\n  print([view.name for view in all_views])\n\n\nThis simple snippet lists every view object on your server. Wow! Think of what\nwe can do with all that tabular data we worked so hard to transform, rig- WRONG.\nLook at what Tableau's Python 'View Object' actually contains:\n\n * id  The identifier of the view item.\n * name  The name of the view.\n * owner_id  The id for the owner of the view.\n * preview_image  The thumbnail image for the view.\n * total_views  The usage statistics for the view. Indicates the total number of\n   times the view has been accessed.\n * workbook_id  The id of the workbook associated with the view.\n\nHOLY MOSES STOP THE PRESSES, we can get a thumbnail image  of our data?! THANK\nYOU GENEROUS TABLEAU OVERLORDS!\n\nNotice how there's no mention of, you know, the actual data.\n\nWe're going to play a game. In the wake of my time has been wasted, I feel that\nwarm tickling feeling which seems to say \"Viciously dismantle the ambitions of\nan establishment!\"  May I remind you, we're talking about the kind of\nestablishment that bills customer licenses based on the number of CPUs being\nutilized by their server infrastructure.  This is effectively recognizing the\nhorrifying and inefficient codebase behind Tableau server, and leveraging this\nflaw for monetization. Yes, you're paying more money to incentivize worst\npractices.\n\nLet's Make a Flask App. An Angry One.\nIn our last post I shared a little script to help you get started stealing data\n[https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/] \n off your own Tableau Server. That doesn't quite scratch my itch anymore. I'm\ngoing to build an interface. I want to make it easy as possible for anybody to\nsystemically rob Tableau Server of every penny its got. That's a lot of pennies\nwhen we consider the equation: data = oil + new.\n\nBefore I bore you, here's a quick demo of the MVP we're building:\n\nEach table is a view being pulled from Tableau Server.This POC demonstrates that\nit is very  possible to automate the extraction of Tableau views from Tableau\nServer. The success  message is signaling that we've successfully taken a\nTableau view and created a corresponding table in an external database. Any data\nwe manipulate in Tableau is now truly ours: we can now leverage the transforms\nwe've applied in workbooks, use this data in other applications, and utilize an\nextract scheduler to keep the data coming. We've turned a BI tool into an ETL\ntool. In other words, you can kindly take those thumbnail previews and shove it.\n\nI'll be open sourcing all of this, as is my civic duty. Let us be clear to\nenterprises: withholding freedom to one's own data is an act of war. Pricing\nmodels which reward poor craftsmanship are an insult to our intellect. For every\narrogant atrocity committed against consumers, the war will wage twice as hard.\nI should probably mention these opinions are my own.\n\nThe Proletariat Strikes Back\nGet a feel for where we're heading with the obligatory project-file-structure\ntree:\n\ntableau-exporter\n├── application\n│   ├── __init__.py\n│   ├── database.py\n│   ├── tableau.py\n│   ├── routes.py\n│   ├── static\n│   │   ├── data\n│   │   │   └── view.csv\n│   │   ├── dist\n│   │   │   ├── all.css\n│   │   │   ├── packed.js\n│   │   ├── img\n│   │   │   └── tableaugithub.jpg\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── scss\n│   │       └── main.scss\n│   └── templates\n│       ├── export.html\n│       ├── index.html\n│       ├── layout.html\n│       └── view.html\n├── config.ini\n├── config.py\n├── app.yaml\n├── start.sh\n├── wsgi.py\n├── Pipfile\n├── README.md\n└── requirements.txt\n\n\nAs usual, we're using a classic Flask application factory  set up here.\n\nWeapons Of Choice\nLet's have a look at our core arsenal:\n\n * requests: We're achieving our goal by exploiting some loopholes exposed in\n   the Tableau REST API.\n * pandas: Will handle everything from extracting comma-separated data into a\n   CSV, render HTML tables, and output SQL.\n * flask_sqlalchemy: Used in tandem with pandas  to handle shipping our data off\n   elsewhere.\n * flask_redis: To handle session variables.\n\nInitiating our Application\nHere's how we construct our app:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_redis import FlaskRedis\n\n# Set global entities\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Initiate globals\n        db.init_app(app)\n        r.init_app(app, charset=\"utf-8\", decode_responses=True)\n\n        # Set global contexts\n        r.set('uri', app.config['SQLALCHEMY_DATABASE_URI'])\n        r.set('baseurl',  app.config['BASE_URL'])\n        r.set('username',  app.config['USERNAME'])\n        r.set('password', app.config['PASSWORD'])\n\n        # Import our modules\n        from . import routes\n        from . import tableau\n        app.register_blueprint(routes.home_blueprint)\n\n        return app\n\n\nThis should all feel like business-as-usual. The core of our application is\nsplit between routes.py, which handles views, and tableau.py, which handles the\nanti-establishment logic. Let's begin with the latter.\n\nLife, Liberty, and The Pursuit of Sick Data Pipelines\nOur good friend tableau.py  might look familiar to those who joined us last time\n[https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/]\n. tableau.py  has been busy hitting the gym since then and is looking sharp for\nprimetime:\n\nimport requests\nimport xml.etree.ElementTree as ET\nfrom . import r\nimport pandas as pd\nimport io\n\n\nclass ExtractTableauView:\n    \"\"\"Class for working in a Tableau instance.\"\"\"\n\n    __baseurl = r.get('baseurl')\n    __username = r.get('username')\n    __password = r.get('password')\n    __database = r.get('uri')\n    __contenturl = r.get('contenturl')\n\n    @classmethod\n    def get_view(cls, site, xml, view, token):\n        \"\"\"Extract contents of a single view.\"\"\"\n        headers = {'X-Tableau-Auth': token,\n                   'Content-Type': 'text/csv'\n                   }\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + str(site) +'/views/' + str(view) + '/data', headers=headers, stream=True)\n        csv_text = req.text\n        view_df = pd.read_csv(io.StringIO(csv_text), header=0)\n        return view_df\n\n    @classmethod\n    def list_views(cls, site, xml, token):\n        \"\"\"List all views belonging to a Tableau Site.\"\"\"\n        headers = {'X-Tableau-Auth': token}\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + site + '/views', auth=(cls.__username, cls.__password), headers=headers)\n        root = ET.fromstring(req.content)\n        views_arr = []\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}views':\n                for view in child:\n                    view_dict = {\n                        'name': view.attrib.get('name'),\n                        'id': view.attrib.get('id'),\n                        'url': cls.__baseurl + '/' + view.attrib.get('contentUrl'),\n                        'created': view.attrib.get('createdAt'),\n                        'updated': view.attrib.get('updatedAt')\n                    }\n                    views_arr.append(view_dict)\n        return views_arr\n\n    @classmethod\n    def get_token(cls, xml):\n        \"\"\"Receive Auth token to perform API requests.\"\"\"\n        for child in xml.iter('*'):\n            if child.tag == '{http://tableau.com/api}credentials':\n                token = child.attrib.get('token')\n                return token\n\n    @classmethod\n    def get_site(cls, xml):\n        \"\"\"Retrieve ID of Tableau 'site' instance.\"\"\"\n        root = xml\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}site':\n                site = child.attrib.get('id')\n                return site\n\n    @classmethod\n    def initialize_tableau_request(cls):\n        \"\"\"Retrieve core XML for interacting with Tableau.\"\"\"\n        headers = {'Content-Type': 'application/xml'}\n        body = '<tsRequest><credentials name=\"' + cls.__username + '\" password=\"' + cls.__password + '\" ><site contentUrl=\"' + cls.__contenturl + '\" /></credentials></tsRequest>'\n        req = requests.post(cls.__baseurl + '/api/3.2/auth/signin', auth=(cls.__username, cls.__password), headers=headers, data=body)\n        root = ET.fromstring(req.content)\n        return root\n\n\nI wish I could take full credit for what a shit show this class appears to be at\nfirst glance, but I assure you we've been left with no choice. For example: have\nI mentioned that Tableau's REST API returns XML so malformed that it breaks XML\nparsers? I can't tell incompetence from malicious intent at this point.\n\nHere's a method breakdown of our class:\n\n * initialize_tableau_request(): Handles initial auth and returns valuable\n   information such as site ID and API Token to be used thereafter.\n * get_site(): Extracts the site ID from XML returned by the above.\n * get_token(): Similarly extracts our token.\n * list_views(): Compiles a list of all views within a Tableau site, giving us a\n   chance to select ones for extraction.\n * get_view(): Takes a view of our choice and creates a DataFrame, which is to\n   be shipped off to a foreign database.\n\nOur Routing Logic\nMoving on we have routes.py  building the views and associated logic for our\napp:\n\nfrom flask import current_app as app\nfrom flask import render_template, Blueprint, request, Markup\nfrom flask_assets import Bundle, Environment\nfrom . import tableau\nfrom . import database\nimport pandas as pd\n\nhome_blueprint = Blueprint('home', __name__, template_folder='templates', static_folder='static')\n\nassets = Environment(app)\njs = Bundle('js/*.js', filters='jsmin', output='dist/packed.js')\nscss = Bundle('scss/*.scss', filters='libsass', output='dist/all.css')\nassets.register('scss_all', scss)\nassets.register('js_all', js)\nscss.build()\njs.build()\n\n\n@home_blueprint.route('/', methods=['GET', 'POST'])\ndef entry():\n    \"\"\"Homepage which lists all available views.\"\"\"\n    tableau_view_extractor = tableau.ExtractTableauView()\n    xml = tableau_view_extractor.initialize_tableau_request()\n    token = tableau_view_extractor.get_token(xml)\n    site = tableau_view_extractor.get_site(xml)\n    views = tableau_view_extractor.list_views(site, xml, token)\n    return render_template(\n        'index.html',\n        title=\"Here are your views.\",\n        template=\"home-template\",\n        views=views,\n        token=token,\n        xml=xml,\n        site=site\n    )\n\n\n@home_blueprint.route('/view', methods=['GET', 'POST'])\ndef view():\n    \"\"\"Displays a preview of a selected view.\"\"\"\n    site = request.args.get('site')\n    xml = request.args.get('xml')\n    view = request.args.get('view')\n    token = request.args.get('token')\n    tableau_view_extractor = tableau.ExtractTableauView()\n    view_df = tableau_view_extractor.get_view(site, xml, view, token)\n    view_df.to_csv('application/static/data/view.csv')\n    return render_template(\n        'view.html',\n        title='Your View',\n        template=\"home-template\",\n        view=view,\n        token=token,\n        xml=xml,\n        site=site,\n        view_df=Markup(view_df.to_html(index=False))\n    )\n\n\n@home_blueprint.route('/export', methods=['GET', 'POST'])\ndef export():\n    \"\"\"Exports view to external database.\"\"\"\n    view_df = pd.read_csv('application/static/data/view.csv')\n    view_df.to_sql(name='temp', con=database.engine, if_exists='replace', chunksize=50, index=True)\n    return render_template(\n        'export.html',\n        title='Success!',\n        template=\"success-template\",\n    )\n\n\nWe only have 3 pages to our application. They include our list of views, a\npreview of a single view, and a success page for when said view is exported.\nThis is all core Flask logic.\n\nPutting it On Display\nWe build our pages dynamically based on the values we pass our Jinja templates.\nThe homepage utilizes some nested loops to list the views we returned from \ntableau.py, and also makes use of query strings to pass values on to other\ntemplates.\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n<div class=\"extended-container {{template}}\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col s12\">\n        <h1>{{title}}</h1>\n      </div>\n      <div class=\"col s12 flex-container\">\n        {% for view in views %}\n        <div class=\"download\">\n          <a href=\"{{ url_for('home.view') }}?token={{token}}&site={{site}}&view={{view.id}}&xml={{xml}}\">\n            <ul>\n              {% for key, value in view.items() %}\n              <li><span class=\"key {{key}}\">{{key}}</span> {{ value }}</li>\n              {% endfor %}\n            </ul>\n          </a>\n        </div>\n        {% endfor %}\n      </div>\n    </div>\n  </div>\n  {% endblock %}\n\n\nMoving on: our humble view.html  page has two purposes: display the selected\nview, and export it in the name of justice.\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n<div class=\"extended-container {{template}}\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col s12\">\n        <h1>{{title}}</h1>\n        <a href=\"{{ url_for('home.export') }}\" class=\"export\"><i class=\"far fa-file-export\"></i></a>\n        {{view_df}}\n      </div>\n    </div>\n  </div>\n  {% endblock %}\n\n\nThe War is Not Over\nThis repository is open to the public and can be found here\n[https://github.com/toddbirchard/tableau-extraction]. There are still crusades\nleft ahead of us: for instance, building out this interface to accept\ncredentials via login as opposed to a config file, and the scheduling of view\nexports, as opposed to on-demand.\n\nWhere we go from here depends on what we the people decide. For all I know, I\ncould be shouting to an empty room here (I'm almost positive anybody who pays\nfor enterprise software prefers the blind eye of denial). If the opposite holds\ntrue, I dare say the revolution is only getting started.","html":"<p>I try my best not to hate on Tableau. It was the software’s combination of power and ease-of-use that drove me to purchase a license in the first place. Ever since then, I’m finding new and exciting ways Tableau intentionally locks users out of their data. </p><p>I gave the <a href=\"https://tableau.github.io/server-client-python/docs/\"><strong>Tableau Server Client</strong> Python library</a> a spin recently in hopes of finding something useful. I decided to (sigh, <em>once more</em>) allow Tableau the benefit of the doubt: after pushing <strong>four updates in a single month</strong>, maybe things had changed. On the contrary, the Tableau business strategy stands strong: to be a raging, flaming turd pile. A perfect example of this is the <strong>View</strong> object Tableau allows you to interact with on your server. Those familiar know that <strong>views</strong> are slang for <em>sheets</em> of <em>workbooks</em> stored on Tableau server. </p><p>Connecting to your Tableau instance via Python to retrieve your view objects is a piece of cake:</p><pre><code class=\"language-python\">import tableauserverclient as TSC\ntableau_auth = TSC.TableauAuth('username', 'password')\nserver = TSC.Server('http://servername')\n\nwith server.auth.sign_in(tableau_auth):\n  all_views, pagination_item = server.views.get()\n  print([view.name for view in all_views])\n</code></pre>\n<p>This simple snippet lists every view object on your server. Wow! Think of what we can do with all that tabular data we worked so hard to transform, rig- <strong>WRONG</strong>. Look at what Tableau's Python 'View Object' actually contains:</p><ul><li><code>id</code> The identifier of the view item.</li><li><code>name</code> The name of the view.</li><li><code>owner_id</code> The id for the owner of the view.</li><li><code>preview_image</code> The thumbnail image for the view.</li><li><code>total_views</code> The usage statistics for the view. Indicates the total number of times the view has been accessed.</li><li><code>workbook_id</code> The id of the workbook associated with the view.</li></ul><p>HOLY MOSES STOP THE PRESSES, we can get a <strong><em>thumbnail image</em></strong> of our data?! THANK YOU GENEROUS TABLEAU OVERLORDS!</p><p>Notice how there's no mention of, you know, the <em>actual data</em>.</p><p>We're going to play a game. In the wake of my time has been wasted, I feel that warm tickling feeling which seems to say <em>\"Viciously dismantle the ambitions of an establishment!\"</em> May I remind you, we're talking about the kind of establishment that bills customer licenses based on the <strong><em>number of CPUs being utilized by their server infrastructure.</em></strong> This is effectively recognizing the horrifying and inefficient codebase behind Tableau server, and leveraging this flaw for monetization. Yes, you're paying more money to incentivize worst practices.</p><h2 id=\"let-s-make-a-flask-app-an-angry-one-\">Let's Make a Flask App. An Angry One.</h2><p>In our last post I shared <a href=\"https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/\">a little script to help you get started stealing data</a> off your own Tableau Server. That doesn't quite scratch my itch anymore. I'm going to build an interface. I want to make it easy as possible for anybody to systemically rob Tableau Server of every penny its got. That's a lot of pennies when we consider the equation: <strong>data = oil + new</strong>.</p><p>Before I bore you, here's a quick demo of the MVP we're building:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/tableau.gif\" class=\"kg-image\"><figcaption>Each table is a view being pulled from Tableau Server.</figcaption></figure><p>This POC demonstrates that it is <em>very</em> possible to automate the extraction of Tableau views from Tableau Server. The <em>success</em> message is signaling that we've successfully taken a Tableau view and <strong>created a corresponding table in an external database</strong>. Any data we manipulate in Tableau is now truly ours: we can now leverage the transforms we've applied in workbooks, use this data in other applications, and utilize an extract scheduler to keep the data coming. We've turned a BI tool into an ETL tool. In other words, you can kindly take those thumbnail previews and shove it.</p><p>I'll be open sourcing all of this, as is my civic duty. Let us be clear to enterprises: withholding freedom to one's own data is an act of war. Pricing models which reward poor craftsmanship are an insult to our intellect. For every arrogant atrocity committed against consumers, the war will wage twice as hard. I should probably mention these opinions are my own.</p><h2 id=\"the-proletariat-strikes-back\">The Proletariat Strikes Back</h2><p>Get a feel for where we're heading with the obligatory project-file-structure tree:</p><pre><code class=\"language-bash\">tableau-exporter\n├── application\n│   ├── __init__.py\n│   ├── database.py\n│   ├── tableau.py\n│   ├── routes.py\n│   ├── static\n│   │   ├── data\n│   │   │   └── view.csv\n│   │   ├── dist\n│   │   │   ├── all.css\n│   │   │   ├── packed.js\n│   │   ├── img\n│   │   │   └── tableaugithub.jpg\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── scss\n│   │       └── main.scss\n│   └── templates\n│       ├── export.html\n│       ├── index.html\n│       ├── layout.html\n│       └── view.html\n├── config.ini\n├── config.py\n├── app.yaml\n├── start.sh\n├── wsgi.py\n├── Pipfile\n├── README.md\n└── requirements.txt\n</code></pre>\n<p>As usual, we're using a classic Flask <em>application factory</em> set up here.</p><h3 id=\"weapons-of-choice\">Weapons Of Choice</h3><p>Let's have a look at our core arsenal:</p><ul><li><code>requests</code>: We're achieving our goal by exploiting some loopholes exposed in the Tableau REST API.</li><li><code>pandas</code>: Will handle everything from extracting comma-separated data into a CSV, render HTML tables, and output SQL.</li><li><code>flask_sqlalchemy</code>: Used in tandem with <em>pandas</em> to handle shipping our data off elsewhere.</li><li><code>flask_redis</code>: To handle session variables.</li></ul><h3 id=\"initiating-our-application\">Initiating our Application</h3><p>Here's how we construct our app:</p><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_redis import FlaskRedis\n\n# Set global entities\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Initiate globals\n        db.init_app(app)\n        r.init_app(app, charset=&quot;utf-8&quot;, decode_responses=True)\n\n        # Set global contexts\n        r.set('uri', app.config['SQLALCHEMY_DATABASE_URI'])\n        r.set('baseurl',  app.config['BASE_URL'])\n        r.set('username',  app.config['USERNAME'])\n        r.set('password', app.config['PASSWORD'])\n\n        # Import our modules\n        from . import routes\n        from . import tableau\n        app.register_blueprint(routes.home_blueprint)\n\n        return app\n</code></pre>\n<p>This should all feel like business-as-usual. The core of our application is split between <code>routes.py</code>, which handles views, and <code>tableau.py</code>, which handles the anti-establishment logic. Let's begin with the latter.</p><h2 id=\"life-liberty-and-the-pursuit-of-sick-data-pipelines\">Life, Liberty, and The Pursuit of Sick Data Pipelines</h2><p>Our good friend <code>tableau.py</code> might look familiar to those who joined us <a href=\"https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/\">last time</a>. <code>tableau.py</code> has been busy hitting the gym since then and is looking sharp for primetime:</p><pre><code class=\"language-python\">import requests\nimport xml.etree.ElementTree as ET\nfrom . import r\nimport pandas as pd\nimport io\n\n\nclass ExtractTableauView:\n    &quot;&quot;&quot;Class for working in a Tableau instance.&quot;&quot;&quot;\n\n    __baseurl = r.get('baseurl')\n    __username = r.get('username')\n    __password = r.get('password')\n    __database = r.get('uri')\n    __contenturl = r.get('contenturl')\n\n    @classmethod\n    def get_view(cls, site, xml, view, token):\n        &quot;&quot;&quot;Extract contents of a single view.&quot;&quot;&quot;\n        headers = {'X-Tableau-Auth': token,\n                   'Content-Type': 'text/csv'\n                   }\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + str(site) +'/views/' + str(view) + '/data', headers=headers, stream=True)\n        csv_text = req.text\n        view_df = pd.read_csv(io.StringIO(csv_text), header=0)\n        return view_df\n\n    @classmethod\n    def list_views(cls, site, xml, token):\n        &quot;&quot;&quot;List all views belonging to a Tableau Site.&quot;&quot;&quot;\n        headers = {'X-Tableau-Auth': token}\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + site + '/views', auth=(cls.__username, cls.__password), headers=headers)\n        root = ET.fromstring(req.content)\n        views_arr = []\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}views':\n                for view in child:\n                    view_dict = {\n                        'name': view.attrib.get('name'),\n                        'id': view.attrib.get('id'),\n                        'url': cls.__baseurl + '/' + view.attrib.get('contentUrl'),\n                        'created': view.attrib.get('createdAt'),\n                        'updated': view.attrib.get('updatedAt')\n                    }\n                    views_arr.append(view_dict)\n        return views_arr\n\n    @classmethod\n    def get_token(cls, xml):\n        &quot;&quot;&quot;Receive Auth token to perform API requests.&quot;&quot;&quot;\n        for child in xml.iter('*'):\n            if child.tag == '{http://tableau.com/api}credentials':\n                token = child.attrib.get('token')\n                return token\n\n    @classmethod\n    def get_site(cls, xml):\n        &quot;&quot;&quot;Retrieve ID of Tableau 'site' instance.&quot;&quot;&quot;\n        root = xml\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}site':\n                site = child.attrib.get('id')\n                return site\n\n    @classmethod\n    def initialize_tableau_request(cls):\n        &quot;&quot;&quot;Retrieve core XML for interacting with Tableau.&quot;&quot;&quot;\n        headers = {'Content-Type': 'application/xml'}\n        body = '&lt;tsRequest&gt;&lt;credentials name=&quot;' + cls.__username + '&quot; password=&quot;' + cls.__password + '&quot; &gt;&lt;site contentUrl=&quot;' + cls.__contenturl + '&quot; /&gt;&lt;/credentials&gt;&lt;/tsRequest&gt;'\n        req = requests.post(cls.__baseurl + '/api/3.2/auth/signin', auth=(cls.__username, cls.__password), headers=headers, data=body)\n        root = ET.fromstring(req.content)\n        return root\n</code></pre>\n<p>I wish I could take full credit for what a shit show this class appears to be at first glance, but I assure you we've been left with no choice. For example: have I mentioned that Tableau's REST API returns XML so malformed that it breaks XML parsers? I can't tell incompetence from malicious intent at this point.</p><p>Here's a method breakdown of our class:</p><ul><li><code>initialize_tableau_request()</code>: Handles initial auth and returns valuable information such as site ID and API Token to be used thereafter.</li><li><code>get_site()</code>: Extracts the site ID from XML returned by the above.</li><li><code>get_token()</code>: Similarly extracts our token.</li><li><code>list_views()</code>: Compiles a list of all views within a Tableau site, giving us a chance to select ones for extraction.</li><li><code>get_view()</code>: Takes a view of our choice and creates a DataFrame, which is to be shipped off to a foreign database.</li></ul><h2 id=\"our-routing-logic\">Our Routing Logic</h2><p>Moving on we have <code>routes.py</code> building the views and associated logic for our app:</p><pre><code class=\"language-python\">from flask import current_app as app\nfrom flask import render_template, Blueprint, request, Markup\nfrom flask_assets import Bundle, Environment\nfrom . import tableau\nfrom . import database\nimport pandas as pd\n\nhome_blueprint = Blueprint('home', __name__, template_folder='templates', static_folder='static')\n\nassets = Environment(app)\njs = Bundle('js/*.js', filters='jsmin', output='dist/packed.js')\nscss = Bundle('scss/*.scss', filters='libsass', output='dist/all.css')\nassets.register('scss_all', scss)\nassets.register('js_all', js)\nscss.build()\njs.build()\n\n\n@home_blueprint.route('/', methods=['GET', 'POST'])\ndef entry():\n    &quot;&quot;&quot;Homepage which lists all available views.&quot;&quot;&quot;\n    tableau_view_extractor = tableau.ExtractTableauView()\n    xml = tableau_view_extractor.initialize_tableau_request()\n    token = tableau_view_extractor.get_token(xml)\n    site = tableau_view_extractor.get_site(xml)\n    views = tableau_view_extractor.list_views(site, xml, token)\n    return render_template(\n        'index.html',\n        title=&quot;Here are your views.&quot;,\n        template=&quot;home-template&quot;,\n        views=views,\n        token=token,\n        xml=xml,\n        site=site\n    )\n\n\n@home_blueprint.route('/view', methods=['GET', 'POST'])\ndef view():\n    &quot;&quot;&quot;Displays a preview of a selected view.&quot;&quot;&quot;\n    site = request.args.get('site')\n    xml = request.args.get('xml')\n    view = request.args.get('view')\n    token = request.args.get('token')\n    tableau_view_extractor = tableau.ExtractTableauView()\n    view_df = tableau_view_extractor.get_view(site, xml, view, token)\n    view_df.to_csv('application/static/data/view.csv')\n    return render_template(\n        'view.html',\n        title='Your View',\n        template=&quot;home-template&quot;,\n        view=view,\n        token=token,\n        xml=xml,\n        site=site,\n        view_df=Markup(view_df.to_html(index=False))\n    )\n\n\n@home_blueprint.route('/export', methods=['GET', 'POST'])\ndef export():\n    &quot;&quot;&quot;Exports view to external database.&quot;&quot;&quot;\n    view_df = pd.read_csv('application/static/data/view.csv')\n    view_df.to_sql(name='temp', con=database.engine, if_exists='replace', chunksize=50, index=True)\n    return render_template(\n        'export.html',\n        title='Success!',\n        template=&quot;success-template&quot;,\n    )\n</code></pre>\n<p>We only have 3 pages to our application. They include our list of views, a preview of a single view, and a success page for when said view is exported. This is all core Flask logic.</p><h2 id=\"putting-it-on-display\">Putting it On Display</h2><p>We build our pages dynamically based on the values we pass our Jinja templates. The homepage utilizes some nested loops to list the views we returned from <code>tableau.py</code>, and also makes use of query strings to pass values on to other templates.</p><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block content %}\n&lt;div class=&quot;extended-container {{template}}&quot;&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col s12&quot;&gt;\n        &lt;h1&gt;{{title}}&lt;/h1&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;col s12 flex-container&quot;&gt;\n        {% for view in views %}\n        &lt;div class=&quot;download&quot;&gt;\n          &lt;a href=&quot;{{ url_for('home.view') }}?token={{token}}&amp;site={{site}}&amp;view={{view.id}}&amp;xml={{xml}}&quot;&gt;\n            &lt;ul&gt;\n              {% for key, value in view.items() %}\n              &lt;li&gt;&lt;span class=&quot;key {{key}}&quot;&gt;{{key}}&lt;/span&gt; {{ value }}&lt;/li&gt;\n              {% endfor %}\n            &lt;/ul&gt;\n          &lt;/a&gt;\n        &lt;/div&gt;\n        {% endfor %}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  {% endblock %}\n</code></pre>\n<p>Moving on: our humble <code>view.html</code> page has two purposes: display the selected view, and export it in the name of justice.</p><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block content %}\n&lt;div class=&quot;extended-container {{template}}&quot;&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col s12&quot;&gt;\n        &lt;h1&gt;{{title}}&lt;/h1&gt;\n        &lt;a href=&quot;{{ url_for('home.export') }}&quot; class=&quot;export&quot;&gt;&lt;i class=&quot;far fa-file-export&quot;&gt;&lt;/i&gt;&lt;/a&gt;\n        {{view_df}}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  {% endblock %}\n</code></pre>\n<h2 id=\"the-war-is-not-over\">The War is Not Over</h2><p>This repository is open to the public and can be found <a href=\"https://github.com/toddbirchard/tableau-extraction\">here</a>. There are still crusades left ahead of us: for instance, building out this interface to accept credentials via login as opposed to a config file, and the scheduling of view exports, as opposed to on-demand.</p><p>Where we go from here depends on what we the people decide. For all I know, I could be shouting to an empty room here (I'm almost positive anybody who pays for enterprise software prefers the blind eye of denial). If the opposite holds true, I dare say the revolution is only getting started.</p>","url":"https://hackersandslackers.com/hostile-extraction-of-tableau-server-data/","uuid":"23914fde-b90e-4496-9a7d-56d6ae3765d9","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c3fc99b89c81d4ccc3f64b1"}},{"node":{"id":"Ghost__Post__5c1af93bffe54a660c58b85a","title":"Cracking Full Control Over Plot.ly Dash","slug":"gaining-full-control-over-plotly-dash","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/12/Dash@2x.jpg","excerpt":"Build apps with Plot.ly Dash on your own terms","custom_excerpt":"Build apps with Plot.ly Dash on your own terms","created_at_pretty":"20 December, 2018","published_at_pretty":"20 December, 2018","updated_at_pretty":"28 March, 2019","created_at":"2018-12-19T21:06:51.000-05:00","published_at":"2018-12-20T14:58:00.000-05:00","updated_at":"2019-03-28T05:19:31.000-04:00","meta_title":"Cracking Full Control Over Plot.ly Dash | Hackers and Slackers","meta_description":"Build apps with Plot.ly Dash on your own terms. Extend Flask functionality with Dash, not the other way around.","og_description":"Build apps with Plot.ly Dash on your own terms. Extend Flask functionality with Dash, not the other way around.","og_image":"https://hackersandslackers.com/content/images/2018/12/Dash@2x.jpg","og_title":"Cracking Full Control Over Plot.ly Dash","twitter_description":"Build apps with Plot.ly Dash on your own terms. Extend Flask functionality with Dash, not the other way around.","twitter_image":"https://hackersandslackers.com/content/images/2018/12/Dash@2x.jpg","twitter_title":"Cracking Full Control Over Plot.ly Dash","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Plotly","slug":"plotly","description":"Get intimate with a staple product in data visualization. Create charts with Plot.ly's core product, or become a pro with Plot.ly Dash.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Dash.jpg","meta_description":"Get intimate with a staple product in data visualization. Create charts with Plot.ly's core product, or become a pro with Plot.ly Dash.","meta_title":"Plotly for Data Visualization | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Plotly","slug":"plotly","description":"Get intimate with a staple product in data visualization. Create charts with Plot.ly's core product, or become a pro with Plot.ly Dash.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Dash.jpg","meta_description":"Get intimate with a staple product in data visualization. Create charts with Plot.ly's core product, or become a pro with Plot.ly Dash.","meta_title":"Plotly for Data Visualization | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Data Vis","slug":"datavis","description":"Visualize your data with charting tools like Matplotlib, Plotly, D3, Chart.js, Muze, Seaborn, and countless others. Primarily focused on programmatic visualization as opposed to Business Intelligence software.","feature_image":null,"meta_description":"Visualize your data with charting tools like Matplotlib, Plotly, D3, Chart.js, Muze, Seaborn, and countless others. Focused on programmatic visualization.","meta_title":"Data Visualization | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Using Plotly Dash Like a Pro","slug":"plotly-dash","description":"Push the limits of Plot.ly Dash to create data-driven applications with ease. Take on Python, Pandas, Flask, and Data Visualization all at once.","feature_image":"https://hackersandslackers.com/content/images/2019/03/Dash.jpg","meta_description":"Push the limits of Plot.ly Dash to create data-driven applications with ease. Take on Python, Pandas, Flask, and Data Visualization all at once.","meta_title":"Using Plotly Dash Like a Pro","visibility":"internal"}],"plaintext":"Ahh, Plot.ly [http://plot.ly/]; typing that name into a post headline triggers\nan emotional cocktail of pride and embarrassment. Over the years Plotly has been\nat the core of some of the most influential products I’ve worked on: a\nhodgepodge of Fintech and humanitarian clients, all of which are still proudly\nwaving their charts and dashboards around the world. Yet, my mind is boggled by\na simple question: what the hell  took us so long to write our first post about\nPlotly? We've been operating Hackers and Slackers for over a full year now...\ndid I seriously write a  post about JQuery\n[https://hackersandslackers.com/making-ajax-calls-with-jquery/]  in that time\nbefore reaching this point?\n\nMuch has changed in the last year or so for our friends in Montreal. Number 1 in\nmy book is the price reduction of their core product: from 300 dollars  to zero.\nI paid the 300 dollars. We really need to get a “donate” button around here. \n\nA close second is undoubtedly the introduction of Plot.ly Dash\n[https://plot.ly/products/dash/]. Dash  tickles a sentiment which has danced\nthrough many young and helplessly naïve Pythonistas' minds: what if we could\nwrite only  in Python, like, forever?  As awful of an idea it is to start\nGoogling Python-to-frontend code interpreters (they exist; I checked), Plotly's\nDash does a shockingly good job of breathing life into that romantic fantasy of\ncommitting to Python forever.\n\nBut we're not here to deliver a recycled 'What is Plotly?'  synopsis. We're not\neven interested in the obligatory 'How to Get Started Using This\nAlready-Well-Documented-Technology' post. Plotly deserves better than that.\nInstead, we're coming hot out of the gate swinging: we're going to show you how\nto beat Plotly down, break it, and make it bend to your will. Welcome to a\nmagical edition of Hacking Plotly. It must be Christmas, folks.\n\nLet's Make a Plotly + Flask Lovechild from Hell\nLike almost every single advancement to come out of Python-geared architecture\nthis year, Dash has a little secret: it's gotten here with a little help from\nFlask. Alright, perhaps more than a little: Dash actually extends Flask. Sounds\nsensible, and perhaps even exciting at first; its almost as though every crush\nyou've ever had decided it be best to simply put their differences aside to\nstart a group chat with you in the interest of making your sexual well-being an\nequal team effort out of sheer love. As you've already guessed, life doesn't\nwork like that.\n\nDash hijacks Flask from the beginning, starting with the way we instantiate the\napp. Any code monkey who has laid eyes upon a wsgi.py file can tell you\nsomething is up before you can even say app = dash.Dash(__name__). Check out the\nrecommended startup boilerplate:\n\nfrom dash import Dash\nimport dash_core_components as dcc\nimport dash_html_components as html\n\nexternal_stylesheets = ['https://codepen.io/fgdsgfhgfh/pen/IHvjvb.css']\n\napp = Dash(__name__, external_stylesheets=external_stylesheets)\n\napp.layout = html.Div(\n        id='example-div-element'\n        )\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n\n\nIf you were to attempt to take this boilerplate and attempt to add core Flask\nlogic, such as authentication with Flask-Login, generating assets with \nFlask-Assets, or just creating a global database, where would you start? Plotly\ncleverly suggests reserving the app  namespace for your app- the very same that\nwe would do with Flask. Yet if we attempt to modify the app  object the same as\nwe would with Flask, nothing will work: Dash has declared an ecosystem, and\nnowhere in that ecosystem are you invited to add custom Flask application logic\nout of the box.\n\nDash does what it was intended to do very well: building dashboard-based\napplications. The issue is that applications which can only display data  aren't\nentirely useful as end products. What if we wanted to create a fully-featured\napp, where data visualization was simply a feature  of said app?\n\nCreating a Fully-Featured App (Where Data Vis is Simply a Feature of Said App)\nA common \"workaround\" you'll find in the community is passing Flask to Dash as\nthe underlying \"server\", something like this:\n\nfrom flask import Flask\nfrom dash import Dash\nimport dash_core_components as dcc\nimport dash_html_components as html\n\nserver = Flask(__name__)\napp = dash.Dash(__name__, server=server, url_base_pathname='/path')\napp.layout = html.Div(id='example-div-element')\n\n@server.route(\"/dash\")\ndef MyDashApp():\n    return app.index()\n\n\nMake no mistake: this method sucks. Sure, you've regained the ability to create\nroutes here and there, but let's not forget:\n\n * Your app will always start on a Dash-served page: if anything, we'd want our\n   start page to be something we have full control over to then dive into the\n   Dash components.\n * Access to globally available Flask plugins are still unavailable in this\n   method. Notice how we never set an application context?\n * Your ability to style your application with static assets and styles is\n   completely out of your hands.\n * Container architecture built on Flask, such as Google App Engine, won't play\n   nicely when we start something that isn't Flask. So there's a good chance\n   that playing by the rules means losing the ability to deploy.\n\nIf we want to do these things, we cannot start our app as an instance of Dash\nand attempt to work around it. Instead, we must create a Flask app, and put Dash\nin its place as an app embedded in our  app. This gives us full control over\nwhen users can enter the Dash interface, and even within that interface, we can\nstill manage database connections or user sessions as we see fit. Welcome to the\nbig leagues.\n\nTurning the Tables: Dash Inside Flask\nFirst things first, let's get our wsgi.py  file back. Pretty much any hosted\nPython application expects this, so please: enough with the app.py  nonsense.\n\nfrom plotly_flask_tutorial import create_app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', debug=True)\n\n\nLook familiar? Not only do we get Flask back, but we get our entire application\nfactory and all that it includes. Take a look at application/__init__.py:\n\nfrom flask import Flask\nfrom . import dash_view\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n    dash_app = dash_view.Add_Dash(app)\n\n    with app.app_context():\n        # Construct the core application\n        from . import routes\n        app.register_blueprint(routes.main_bp)\n\n        return app\n\n\nIt's almost as though nothing changed! In fact, the only line we have regarding\nDash here is dash_app = plotly_dash_views.Add_Dash(app). \n\nWe import dash_view  at the start of __init.py__. What is this, you might ask?\nIt's actually a file which contains our Dash app! Dash apps typically like to\nhave a single .py  file per view, which turns out to work great for us. Let's\nlook at why this works by checking dash_view.py:\n\nimport glob\nfrom dash import Dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\n\n\ndef Add_Dash(server):\n    \"\"\"Plot.ly Dash view which populates the screen with loaded DataFrames.\"\"\"\n    external_stylesheets = ['https://hackers.nyc3.cdn.digitaloceanspaces.com/css/plotly-flask-tutorial.css']\n    dash_app = Dash(server=server,\n                    external_stylesheets=external_stylesheets,\n                    routes_pathname_prefix='/dash_view/')\n\n    # Create Dash Layout\n    dash_app.layout = html.Div(\n        id='dash-container'\n      )\n\n    return dash_app.server\n\n\nWe pass our Flask instance to Add_Dash  as a parameter called server. Unlike the\nprevious examples, it's actually server  running the show this time, with Dash\npiggybacking as a module. This is our most important line of code:\n\ndash_app = Dash(server=server, routes_pathname_prefix='/dash_view/')\n\n\nDash doesn't handle routes like Flask does (or at all, really). That's fine! We\nstart dash_app  with URL prefix, which means the Dash logic here is confined to\nthat single page. This means we can build a sprawling Flask app with hundreds of\nfeatures and views, and oh yeah, if we want a Dash view, we can just create a\nfile for that to chill on its own, not touching anything else.\n\nNow you're thinking with portals™.\n\nWhat Our App Looks Like\nIf you're following along, it would probably help to have a top-level view of\nwhat's going on so far:\n\nplotlydash-flask-tutorial\n├── /plotly_flask_tutorial\n│   ├── __init__.py\n│   ├── dash_view.py\n│   ├── routes.py\n│   ├── /data\n│   │   ├── chicago_taxis.csv\n│   │   ├── citibike_trips.csv\n│   │   ├── cities.csv\n│   │   └── pocket.csv\n│   ├── /static\n│   │   ├── dist\n│   │   │   └── css\n│   │   │       └── plotly-flask-tutorial.css\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── less\n│   │       ├── global.less\n│   │       ├── header.less\n│   │       └── table.less\n│   ├── /templates\n│   │   ├── index.html\n│   │   └── nav.html\n│   └── /data\n│       ├── chicago_taxis.csv\n│       ├── citibike_trips.csv\n│       ├── cities.csv\n│       └── pocket.csv\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n\n\nWe're storing our app within a directory called plotly_flask_tutorial. In that\ndirectory, we have our typical Flask stuff (/templates, /static, etc) as well as\ntwo notable files: routes.py  and dash_view.py.\n\nroutes.py\nroutes.py  can contain anything we want. Our application will default to serving\na Flask page, not  a Dash page, so our routes can be an entire standalone\napplication. Here's what I tossed in there: \n\nimport os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask import current_app as app\nimport lesscpy\n\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\nEnvironment.auto_build = True\nEnvironment.debug = False\nless_bundle = Bundle('less/*.less',\n                     filters='less,cssmin',\n                     output='dist/css/plotly-flask-tutorial.css.css',\n                     extra={'rel': 'stylesheet/less'})\njs_bundle = Bundle('js/*.js',\n                   filters='jsmin',\n                   output='dist/js/main.js')\nassets.register('less_all', less_bundle)\nassets.register('js_all', js_bundle)\nless_bundle.build(force=True)\njs_bundle.build()\n\n\n# Landing Page\n@main_bp.route('/', methods=['GET'])\ndef home():\n    return render_template('index.html',\n                           title='Plotly Flask Tutorial.',\n                           template='home-template',\n                           body=\"This is an example homepage, served with Flask.\")\n\n\nAll this is doing is serving up index.html.\n\ndash_view.py\ndash_view.py  is the Dash app we have living within  our Flask app. But how does\nFlask know which url to serve our application at? Wasn't it missing from \nroutes.py? Indeed it was, good fellow! Because we set routes_pathname_prefix, we\n don't need  to create a route for dash_view.py: it will always be served\nwhenever we navigate to 127.0.01/dash_view. Thus, we can create a navigation\ntemplate like this:\n\n<nav>\n  <a href=\"/\"><i class=\"fas fa-home\"></i> Home</a>\n  <a href=\"/dash_view/\"><i class=\"fas fa-chart-line\"></i> Embdedded Plotly Dash</a>\n</nav>\n\n\nCreating Something Useful\nHere's a fun little thing I was able to do with Dash, while in the context of\nrunning under a Flask app. In our file dash_view.py, I have the app look at a\nfolder of extracted datasets (called  /data). For each dataset, I use Pandas to\ngenerate a preview, and Dash's \"data table\" component to render said previews in\nour Dash app. This lets us quickly cruise through the data an app depends on\nwith a cool interface:\n\nA bit rough around the edges, but you get the point.If you're hungry for some\nsource code to get started building your own Plotly Dash views, here's the\nsource I used to create the page above:\n\nimport glob\nfrom pathlib import Path, PurePath\nfrom dash import Dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\n\np = Path('.')\n\n\ndef Add_Dash(server):\n    \"\"\"Plot.ly Dash view which populates the screen with loaded DataFrames.\"\"\"\n    external_stylesheets = ['https://hackers.nyc3.cdn.digitaloceanspaces.com/css/plotly-flask-tutorial.css',\n                            'https://fonts.googleapis.com/css?family=Lato',\n                   'https://use.fontawesome.com/releases/v5.8.1/css/all.css']\n    dash_app = Dash(server=server,\n                    external_stylesheets=external_stylesheets,\n                    routes_pathname_prefix='/dash_view/')\n\n    # Override the underlying HTML template\n    dash_app.index_string = '''<!DOCTYPE html>\n        <html>\n            <head>\n                {%metas%}\n                <title>{%title%}</title>\n                {%favicon%}\n                {%css%}\n            </head>\n            <body>\n                <nav>\n                  <a href=\"/\"><i class=\"fas fa-home\"></i> Home</a>\n                  <a href=\"/dash_view/\"><i class=\"fas fa-chart-line\"></i> Embdedded Plotly Dash</a>\n                </nav>\n                {%app_entry%}\n                <footer>\n                    {%config%}\n                    {%scripts%}\n                    {%renderer%}\n                </footer>\n            </body>\n        </html>'''\n\n    # Create Dash Layout comprised of Data Tables\n    dash_app.layout = html.Div(\n        children=get_datasets(),\n        id='flex-container'\n      )\n\n    return dash_app.server\n\n\ndef get_datasets():\n    \"\"\"Returns previews of all CSVs saved in /data directory.\"\"\"\n    data_filepath = list(p.glob('plotly_flask_tutorial/data/*.csv'))\n    arr = ['This is an example Plot.ly Dash App.']\n    for index, csv in enumerate(data_filepath):\n        print(PurePath(csv))\n        df = pd.read_csv(data_filepath[index]).head(10)\n        table_preview = dash_table.DataTable(\n            id='table_' + str(index),\n            columns=[{\"name\": i, \"id\": i} for i in df.columns],\n            data=df.to_dict(\"rows\"),\n            sorting=True,\n        )\n        arr.append(table_preview)\n    return arr\n\n\nI've gone ahead and uploaded the source code for this working example up on\nGithub [https://github.com/toddbirchard/plotlydash-flask-tutorial]. Please steal\nit: it's all yours.\n\nNeedless to say, there's way more cool shit we can accomplish with Plotly Dash.\nStick around long enough, and chances are we'll cover all of them.","html":"<p>Ahh, <a href=\"http://plot.ly/\"><strong>Plot.ly</strong></a>; typing that name into a post headline triggers an emotional cocktail of pride and embarrassment. Over the years Plotly has been at the core of some of the most influential products I’ve worked on: a hodgepodge of Fintech and humanitarian clients, all of which are still proudly waving their charts and dashboards around the world. Yet, my mind is boggled by a simple question: what the <em>hell</em> took us so long to write our first post about Plotly? We've been operating Hackers and Slackers for over a full year now... did I seriously write a<a href=\"https://hackersandslackers.com/making-ajax-calls-with-jquery/\"> post about JQuery</a> in that time before reaching this point?</p><p>Much has changed in the last year or so for our friends in Montreal. Number 1 in my book is the price reduction of their core product: from <em><strong>300 dollars</strong></em> to <em><strong>zero</strong></em>. I paid the 300 dollars. We really need to get a “donate” button around here. </p><p>A close second is undoubtedly the introduction of <strong><a href=\"https://plot.ly/products/dash/\">Plot.ly Dash</a></strong>. <strong>Dash</strong> tickles a sentiment which has danced through many young and helplessly naïve Pythonistas' minds: <em>what if we could write </em><strong><em>only</em></strong><em> in Python, like, </em><strong><em>forever</em></strong><em>?</em> As awful of an idea it is to start Googling Python-to-frontend code interpreters (they exist; I checked), Plotly's Dash does a shockingly good job of breathing life into that romantic fantasy of committing to Python forever.</p><p>But we're not here to deliver a recycled 'W<em>hat is Plotly?'</em> synopsis. We're not even interested in the obligatory '<em>How to Get Started Using This Already-Well-Documented-Technology' </em>post<em>. </em>Plotly deserves better than that. Instead, we're coming hot out of the gate swinging: we're going to show you how to beat Plotly down, break it, and make it bend to your will. Welcome to a magical edition of Hacking Plotly. It must be Christmas, folks.</p><h2 id=\"let-s-make-a-plotly-flask-lovechild-from-hell\">Let's Make a Plotly + Flask Lovechild from Hell</h2><p>Like almost every single advancement to come out of Python-geared architecture this year, Dash has a little secret: it's gotten here with a little help from Flask. Alright, perhaps more than a little: Dash actually extends Flask. Sounds sensible, and perhaps even exciting at first; its almost as though every crush you've ever had decided it be best to simply put their differences aside to start a group chat with you in the interest of making your sexual well-being an equal team effort out of sheer love. As you've already guessed, life doesn't work like that.</p><p>Dash hijacks Flask from the beginning, starting with the way we instantiate the app. Any code monkey who has laid eyes upon a <strong>wsgi.py </strong>file can tell you something is up before you can even say <code>app = dash.Dash(__name__)</code>. Check out the recommended startup boilerplate:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from dash import Dash\nimport dash_core_components as dcc\nimport dash_html_components as html\n\nexternal_stylesheets = ['https://codepen.io/fgdsgfhgfh/pen/IHvjvb.css']\n\napp = Dash(__name__, external_stylesheets=external_stylesheets)\n\napp.layout = html.Div(\n        id='example-div-element'\n        )\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n</code></pre>\n<!--kg-card-end: markdown--><p>If you were to attempt to take this boilerplate and attempt to add core Flask logic, such as authentication with <code>Flask-Login</code>, generating assets with <code>Flask-Assets</code>, or just creating a global database, where would you start? Plotly cleverly suggests reserving the <code>app</code> namespace for your app- the very same that we would do with Flask. Yet if we attempt to modify the <code>app</code> object the same as we would with Flask, nothing will work: Dash has declared an ecosystem, and nowhere in that ecosystem are you invited to add custom Flask application logic out of the box.</p><p>Dash does what it was intended to do very well: building dashboard-based applications. The issue is that applications which can <em>only display data</em> aren't entirely useful as end products. What if we wanted to create a fully-featured app, where data visualization was simply a <em>feature</em> of said app?</p><h2 id=\"creating-a-fully-featured-app-where-data-vis-is-simply-a-feature-of-said-app-\">Creating a Fully-Featured App (Where Data Vis is Simply a Feature of Said App)</h2><p>A common \"workaround\" you'll find in the community is passing Flask to Dash as the underlying \"server\", something like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask\nfrom dash import Dash\nimport dash_core_components as dcc\nimport dash_html_components as html\n\nserver = Flask(__name__)\napp = dash.Dash(__name__, server=server, url_base_pathname='/path')\napp.layout = html.Div(id='example-div-element')\n\n@server.route(&quot;/dash&quot;)\ndef MyDashApp():\n    return app.index()\n</code></pre>\n<!--kg-card-end: markdown--><p>Make no mistake: this method <em>sucks. </em>Sure, you've regained the ability to create routes here and there, but let's not forget:</p><ul><li>Your app will always start on a Dash-served page: if anything, we'd want our start page to be something we have full control over to then dive into the Dash components.</li><li>Access to globally available Flask plugins are still unavailable in this method. Notice how we never set an application context?</li><li>Your ability to style your application with static assets and styles is completely out of your hands.</li><li>Container architecture built on Flask, such as Google App Engine, won't play nicely when we start something that isn't Flask. So there's a good chance that playing by the rules means losing the ability to deploy.</li></ul><p>If we want to do these things, we cannot start our app as an instance of Dash and attempt to work around it. Instead, we must create a Flask app, and put Dash in its place as an app embedded in <em>our</em> app. This gives us full control over when users can enter the Dash interface, and even within that interface, we can still manage database connections or user sessions as we see fit. Welcome to the big leagues.</p><h2 id=\"turning-the-tables-dash-inside-flask\">Turning the Tables: Dash Inside Flask</h2><p>First things first, let's get our <strong>wsgi.py</strong> file back. Pretty much any hosted Python application expects this, so please: enough with the <strong>app.py</strong> nonsense.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from plotly_flask_tutorial import create_app\n\napp = create_app()\n\nif __name__ == &quot;__main__&quot;:\n    app.run(host='0.0.0.0', debug=True)\n</code></pre>\n<!--kg-card-end: markdown--><p>Look familiar? Not only do we get Flask back, but we get our entire application factory and all that it includes. Take a look at <code>application/__init__.py</code><em>:</em></p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask\nfrom . import dash_view\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n    dash_app = dash_view.Add_Dash(app)\n\n    with app.app_context():\n        # Construct the core application\n        from . import routes\n        app.register_blueprint(routes.main_bp)\n\n        return app\n</code></pre>\n<!--kg-card-end: markdown--><p>It's almost as though nothing changed! In fact, the only line we have regarding Dash here is <code>dash_app = plotly_dash_views.Add_Dash(app)</code>. </p><p>We import <code>dash_view</code> at the start of <code>__init.py__</code>. What is this, you might ask? It's actually a file which contains our Dash app! Dash apps typically like to have a single <em>.py</em> file per view, which turns out to work great for us. Let's look at why this works by checking <code>dash_view.py</code>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import glob\nfrom dash import Dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\n\n\ndef Add_Dash(server):\n    &quot;&quot;&quot;Plot.ly Dash view which populates the screen with loaded DataFrames.&quot;&quot;&quot;\n    external_stylesheets = ['https://hackers.nyc3.cdn.digitaloceanspaces.com/css/plotly-flask-tutorial.css']\n    dash_app = Dash(server=server,\n                    external_stylesheets=external_stylesheets,\n                    routes_pathname_prefix='/dash_view/')\n\n    # Create Dash Layout\n    dash_app.layout = html.Div(\n        id='dash-container'\n      )\n\n    return dash_app.server\n</code></pre>\n<!--kg-card-end: markdown--><p>We pass our Flask instance to <code>Add_Dash</code> as a parameter called <em>server. </em>Unlike the previous examples, it's actually <em>server</em> running the show this time, with Dash piggybacking as a module. This is our most important line of code:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">dash_app = Dash(server=server, routes_pathname_prefix='/dash_view/')\n</code></pre>\n<!--kg-card-end: markdown--><p>Dash doesn't handle routes like Flask does (or at all, really). That's fine! We start <code>dash_app</code> with URL prefix, which means the Dash logic here is confined to that single page. This means we can build a sprawling Flask app with hundreds of features and views, and oh yeah, if we want a Dash view, we can just create a file for that to chill on its own, not touching anything else.</p><p>Now you're thinking with portals<strong>™.</strong></p><h2 id=\"what-our-app-looks-like\">What Our App Looks Like</h2><p>If you're following along, it would probably help to have a top-level view of what's going on so far:</p><!--kg-card-begin: markdown--><pre><code>plotlydash-flask-tutorial\n├── /plotly_flask_tutorial\n│   ├── __init__.py\n│   ├── dash_view.py\n│   ├── routes.py\n│   ├── /data\n│   │   ├── chicago_taxis.csv\n│   │   ├── citibike_trips.csv\n│   │   ├── cities.csv\n│   │   └── pocket.csv\n│   ├── /static\n│   │   ├── dist\n│   │   │   └── css\n│   │   │       └── plotly-flask-tutorial.css\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── less\n│   │       ├── global.less\n│   │       ├── header.less\n│   │       └── table.less\n│   ├── /templates\n│   │   ├── index.html\n│   │   └── nav.html\n│   └── /data\n│       ├── chicago_taxis.csv\n│       ├── citibike_trips.csv\n│       ├── cities.csv\n│       └── pocket.csv\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── config.py\n├── requirements.txt\n├── setup.py\n├── start.sh\n└── wsgi.py\n</code></pre>\n<!--kg-card-end: markdown--><p>We're storing our app within a directory called <code>plotly_flask_tutorial</code>. In that directory, we have our typical Flask stuff (<strong>/templates</strong>, <strong>/static</strong>, etc) as well as two notable files: <code>routes.py</code> and <code>dash_view.py</code>.</p><h3 id=\"routes-py\">routes.py</h3><p><code>routes.py</code> can contain anything we want. Our application will default to serving a Flask page, <em>not</em> a Dash page, so our routes can be an entire standalone application. Here's what I tossed in there: </p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nfrom flask import Blueprint, render_template\nfrom flask_assets import Environment, Bundle\nfrom flask import current_app as app\nimport lesscpy\n\nmain_bp = Blueprint('main_bp', __name__,\n                    template_folder='templates',\n                    static_folder='static')\nassets = Environment(app)\nEnvironment.auto_build = True\nEnvironment.debug = False\nless_bundle = Bundle('less/*.less',\n                     filters='less,cssmin',\n                     output='dist/css/plotly-flask-tutorial.css.css',\n                     extra={'rel': 'stylesheet/less'})\njs_bundle = Bundle('js/*.js',\n                   filters='jsmin',\n                   output='dist/js/main.js')\nassets.register('less_all', less_bundle)\nassets.register('js_all', js_bundle)\nless_bundle.build(force=True)\njs_bundle.build()\n\n\n# Landing Page\n@main_bp.route('/', methods=['GET'])\ndef home():\n    return render_template('index.html',\n                           title='Plotly Flask Tutorial.',\n                           template='home-template',\n                           body=&quot;This is an example homepage, served with Flask.&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>All this is doing is serving up <code>index.html</code>.</p><h3 id=\"dash_view-py\">dash_view.py</h3><p><code>dash_view.py</code> is the Dash app we have living <em>within</em> our Flask app. But how does Flask know which url to serve our application at? Wasn't it missing from <code>routes.py</code>? Indeed it was, good fellow! Because we set <strong>routes_pathname_prefix</strong>, we <em>don't need</em> to create a route for <code>dash_view.py</code>: it will always be served whenever we navigate to <code>127.0.01/dash_view</code>. Thus, we can create a navigation template like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;nav&gt;\n  &lt;a href=&quot;/&quot;&gt;&lt;i class=&quot;fas fa-home&quot;&gt;&lt;/i&gt; Home&lt;/a&gt;\n  &lt;a href=&quot;/dash_view/&quot;&gt;&lt;i class=&quot;fas fa-chart-line&quot;&gt;&lt;/i&gt; Embdedded Plotly Dash&lt;/a&gt;\n&lt;/nav&gt;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"creating-something-useful\">Creating Something Useful</h2><p>Here's a fun little thing I was able to do with Dash, while in the context of running under a Flask app. In our file <code>dash_view.py</code>, I have the app look at a folder of extracted datasets (called<em> /data</em>). For each dataset, I use Pandas to generate a preview, and Dash's \"data table\" component to render said previews in our Dash app. This lets us quickly cruise through the data an app depends on with a cool interface:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/dataframes.gif\" class=\"kg-image\"><figcaption>A bit rough around the edges, but you get the point.</figcaption></figure><!--kg-card-end: image--><p>If you're hungry for some source code to get started building your own Plotly Dash views, here's the source I used to create the page above:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import glob\nfrom pathlib import Path, PurePath\nfrom dash import Dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\n\np = Path('.')\n\n\ndef Add_Dash(server):\n    &quot;&quot;&quot;Plot.ly Dash view which populates the screen with loaded DataFrames.&quot;&quot;&quot;\n    external_stylesheets = ['https://hackers.nyc3.cdn.digitaloceanspaces.com/css/plotly-flask-tutorial.css',\n                            'https://fonts.googleapis.com/css?family=Lato',\n                   'https://use.fontawesome.com/releases/v5.8.1/css/all.css']\n    dash_app = Dash(server=server,\n                    external_stylesheets=external_stylesheets,\n                    routes_pathname_prefix='/dash_view/')\n\n    # Override the underlying HTML template\n    dash_app.index_string = '''&lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {%metas%}\n                &lt;title&gt;{%title%}&lt;/title&gt;\n                {%favicon%}\n                {%css%}\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;nav&gt;\n                  &lt;a href=&quot;/&quot;&gt;&lt;i class=&quot;fas fa-home&quot;&gt;&lt;/i&gt; Home&lt;/a&gt;\n                  &lt;a href=&quot;/dash_view/&quot;&gt;&lt;i class=&quot;fas fa-chart-line&quot;&gt;&lt;/i&gt; Embdedded Plotly Dash&lt;/a&gt;\n                &lt;/nav&gt;\n                {%app_entry%}\n                &lt;footer&gt;\n                    {%config%}\n                    {%scripts%}\n                    {%renderer%}\n                &lt;/footer&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;'''\n\n    # Create Dash Layout comprised of Data Tables\n    dash_app.layout = html.Div(\n        children=get_datasets(),\n        id='flex-container'\n      )\n\n    return dash_app.server\n\n\ndef get_datasets():\n    &quot;&quot;&quot;Returns previews of all CSVs saved in /data directory.&quot;&quot;&quot;\n    data_filepath = list(p.glob('plotly_flask_tutorial/data/*.csv'))\n    arr = ['This is an example Plot.ly Dash App.']\n    for index, csv in enumerate(data_filepath):\n        print(PurePath(csv))\n        df = pd.read_csv(data_filepath[index]).head(10)\n        table_preview = dash_table.DataTable(\n            id='table_' + str(index),\n            columns=[{&quot;name&quot;: i, &quot;id&quot;: i} for i in df.columns],\n            data=df.to_dict(&quot;rows&quot;),\n            sorting=True,\n        )\n        arr.append(table_preview)\n    return arr\n</code></pre>\n<!--kg-card-end: markdown--><p>I've gone ahead and uploaded the source code for this working example up <a href=\"https://github.com/toddbirchard/plotlydash-flask-tutorial\">on Github</a>. Please steal it: it's all yours.</p><p>Needless to say, there's way more cool shit we can accomplish with Plotly Dash. Stick around long enough, and chances are we'll cover all of them.</p>","url":"https://hackersandslackers.com/gaining-full-control-over-plotly-dash/","uuid":"535768b9-34b6-4a80-b5fa-b69b50cf3a68","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c1af93bffe54a660c58b85a"}},{"node":{"id":"Ghost__Post__5c192cdba632c8240cad3869","title":"Globally Accessible Variables in Flask: Demystifying the 'Application Context'","slug":"demystifying-flasks-application-context","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/04/flask_factory-2.jpg","excerpt":"Breaking down the nuances of the ‘app context’ in Flask's Application Factory.","custom_excerpt":"Breaking down the nuances of the ‘app context’ in Flask's Application Factory.","created_at_pretty":"18 December, 2018","published_at_pretty":"19 December, 2018","updated_at_pretty":"10 April, 2019","created_at":"2018-12-18T12:22:35.000-05:00","published_at":"2018-12-19T08:00:00.000-05:00","updated_at":"2019-04-09T23:49:27.000-04:00","meta_title":"Demystifying Flask's Application Context | Hackers and Slackers","meta_description":"A guide breaking down the cryptic nuances of Flask's 'Application Context.' Putting an end to \"RuntimeError: working outside of application context\".","og_description":"A guide breaking down the cryptic nuances of Flask's 'Application Context.' Putting an end to \"RuntimeError: working outside of application context\".","og_image":"https://hackersandslackers.com/content/images/2019/04/flask_factory-2-2.jpg","og_title":"Demystifying Flask's Application Context","twitter_description":"A guide breaking down the cryptic nuances of Flask's 'Application Context.' Putting an end to \"RuntimeError: working outside of application context\".","twitter_image":"https://hackersandslackers.com/content/images/2019/04/flask_factory-2-1.jpg","twitter_title":"Demystifying Flask's Application Context","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"A 'skill' that's always fascinated me is just how long some engineers can make\nit in their career while carrying glaringly obvious gaps in their knowledge of\nthe systems they use every day. To my surprise, I've turned corners where I\nmyself have been that engineer all along, and there's perhaps no better example\nof this then the time I've spent with Flask.\n\nWARNING! Highly opinionated statement incoming: Flask is everything a framework\nshould be. That is to say, it isn't really  a framework a fully-fledged\nframework at all. Sure, the term microframework might seem like a cute PR term,\nbut that doesn't negate the fact that there's something about Flask that's\ndifferent. When I write apps in Flask,  I feel as though I'm writing apps in \nPython.  On the other hand, when I write apps in Django,  I feel like I'm just\nwriting apps in Django.  A disciplined programmer might feel that overly\nstructured frameworks damper creativity and they're probably right: these are\nthe backbones of businesses, thus it makes sense to keep people from deviating\nfrom the norm. \n\nThe upside of Flask is also its downside: there's nearly an infinite number of\nways to solve a single problem. Every Stackoverflow regular has their own\npreference, and sometimes, just none of them seem... right. The problem is\ncompounded by some of the phrasing coming from Flask's documentation itself.\nFlask touts the importance of structuring apps with factories and Blueprints,\nwhile simultaneously expressing the power behind the application context.  What\nyou'll notice over time is that in Flask's own examples, these two 'very\nimportant things' never both appear at the same time: that's because they're\nsimply incompatible with one another.  This is a highly understated\ncontradiction of philosophies.\n\nCommunication Breakdown?\nHere's Flask's take on Application factories\n[http://flask.pocoo.org/docs/1.0/patterns/appfactories/]:\n\n> If you are already using packages and blueprints for your application (Modular\nApplications with Blueprints) there are a couple of really nice ways to further\nimprove the experience. A common pattern is creating the application object when\nthe blueprint is imported.\n\n\nAnd here's their description of the Application context\n[http://flask.pocoo.org/docs/1.0/appcontext/]:\n\n> The application context keeps track of the application-level data during a\nrequest, CLI command, or other activity. Rather than passing the application\naround to each function, the current_app and g proxies are accessed instead.\n\n\nConsidering g  is intended to stand for \"global\" it seems safe from the previous\nstatements that setting attributes of g  can be accessed globally within an\napplication... but they can't. This is where we backpedal and get into messy\nterritory:\n\n> However, importing the app instance within the modules in your project is prone\nto circular import issues. When using the app factory pattern or writing\nreusable blueprints or extensions there won’t be an app instance to import at\nall.\n\nFlask solves this issue with the application context. Rather than referring to\nan app directly, you use the the current_app  proxy, which points to the\napplication handling the current activity.\n\n\nOkay, fine. So if I instantiate an application factory with app.app_context(): \n(which is the only sensible way to create a factory at all)  I should be able to\nregister blueprints within that context, and reference the app context, correct?\n\nI could be crazy but this never seems to work  within blueprints. Whether they\nexist as peer modules or submodules, the words 'from application import\ncurrent_app as app' always seems to result in the same \"missing application\ncontext\" error. Conveniently it seems, all working examples of the application\ncontext seem to be when the Flask developers opt to serve single-file app\nexamples. This stranger from Stackoverflow\n[https://stackoverflow.com/questions/50233118/access-to-flask-global-variables-in-blueprint-apps] \n clears things up a bit:\n\n> This happens because the data are lost when the context (with app.app_context())\nends (doc).\nInside the context, everything is ok :\n\nfrom flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n   print(g.my_db)\n\nthis prints 'database ok'\n\n\nBut outside, you cannot access the attribute:\n\nfrom flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n\nprint(g.my_db)\n\n\nthis throws RuntimeError: Working outside of application context\n\neven if you create a new context:\n\nfrom flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n\nwith app.app_context():\n   print(g.my_db)\n\n\nthis throws AttributeError: '_AppCtxGlobals' object has no attribute 'my_db'\n\n\nAlas, here I am. Doomed writing posts to fill in the blanks of documentation\nleft behind by others. \n\nFlask Sessions: The REAL Slim Shady\nFlask-Session  is the MVP when it comes sharing temporary information across\nmodularized parts of our program. In fact, it's a bit odd this isn't encouraged\nmore-so than g. But whatever. We're here to heal.\n\nSessions  can handled in a number of different ways besides cookies. Take a look\nat the choices we have for storing session-based values in an instance of Flask:\n\nSESSION_TYPE\n Specifies which type of session interface to\nuse. Built-in session types:\n\n * null: NullSessionInterface (default)\n * redis: RedisSessionInterface\n * memcached: MemcachedSessionInterface\n * filesystem: FileSystemSessionInterface\n * mongodb: MongoDBSessionInterface\n * sqlalchemy: SqlAlchemySessionInterface\n\nSESSION_PERMANENT\n Whether use permanent session or not, default\nto be True\n SESSION_USE_SIGNER\n Whether sign the session cookie sid or not,\nif set to True, you have to set\n flask.Flask.secret_key\n[http://flask.pocoo.org/docs/api/#flask.Flask.secret_key], default to be\n False\n SESSION_KEY_PREFIX\n A prefix that is added before all session keys.\nThis makes it possible to use the same backend\nstorage server for different apps, default\n“session:”\n SESSION_REDIS\n A redis.Redis  instance, default connect to\n 127.0.0.1:6379\n SESSION_MEMCACHED\n A memcache.Client  instance, default connect\nto 127.0.0.1:11211\n SESSION_FILE_DIR\n The directory where session files are stored.\nDefault to use flask_session  directory under\ncurrent working directory.\n SESSION_FILE_THRESHOLD\n The maximum number of items the session stores\nbefore it starts deleting some, default 500\n SESSION_FILE_MODE\n The file mode wanted for the session files,\ndefault 0600\n SESSION_MONGODB\n A pymongo.MongoClient  instance, default\nconnect to 127.0.0.1:27017\n SESSION_MONGODB_DB\n The MongoDB database you want to use, default\n“flask_session”\n SESSION_MONGODB_COLLECT\n The MongoDB collection you want to use, default\n“sessions”\n SESSION_SQLALCHEMY\n A flask.ext.sqlalchemy.SQLAlchemy  instance\nwhose database connection URI is configured\nusing the SQLALCHEMY_DATABASE_URI  parameter\n SESSION_SQLALCHEMY_TABLE\n The name of the SQL table you want to use,\ndefault “sessions”\n Using Redis For Cached Session Information\nFor the sake of trying something different, I've opted to pick up a tiny Redis\ninstance from redislabs [https://redislabs.com/]. I can't help myself but\nwasting money on new services to play with; after all, check out how cool this\nlittle red box looks:\n\nRedis Enterprise: A Unique Primary Database\nPerfomance at Scale\n * 50M ops/sec,\n    Symmetric shared–nothing architecture ensures no performance overheads while\n   scaling, auto-sharding and re-balancing\n    Enhanced connection management, pipeline execution and request scheduling\n    \n\nBuilt-in high performance search\n * High performance, real-time indexing with items available for search within\n   1ms\n * Predictable high performance querying while maintaining concurrent loads of\n   indexing and querying\n * Highly scalable across multiple nodes to billions of items per second \n\nFailsafe high availability\n * Cross-rack/zone/datacenter/geo replication\n * Instant auto-failover in single digit second\n * Zero impact on throughput and latency during cluster operations such as\n   scaling, upgrades, re-sharding and rebalancing\n * Out-of-the box support for backup, restore and DR\n\nActive-active geo distribution\n * Reads/Writes in multiple geo regions to the same dataset\n * Local latencies, global availability\n * Built-in conflict resolution for simple and complex data types\n * Based on revolutionary CRDT academic research\n\nBuilt-in persistence\n * Enhanced storage engine for parallel access to any persistent storage\n * Multiple options for enhanced data persistence\n * Reliable persistence configurations on both master and slave shards with zero\n   performance impact\n\nMulti-model\n * Graph, JSON, Machine Learning and Bloom filter modules set industry standards\n   for high performance\n * Multi-shard coordination\n * Extensibility with custom modules\n\nIntelligent tiered access to memory\n * Up to 80% lower infrastructure costs by running Redis on Flash\n * Automatic management of data tiering between RAM & Flash with no code changes\n * Supports all new persistent memory technologies\n\nFlexible deployment options\n * Hybrid clusters can span on-prem infrastructure and multiple clouds\n * Most efficient use of resources with maximized core usage, multi-tenancy,\n   re-sharding and re-balancing to avoid noisy neighbors in every environment\n\nPerfomance at Scale\n Built-in persistence\n Failsafe high availability\n Active-active geo distribution\n Built-in high performance search\n Multi-model\n Intelligent tiered access to memory\n \n(RAM and Flash)\n Flexible deployment options\n \n(cloud, on-prem, hybrid)\n Fast\nPerformance at scale\n Built-in high performance search\n Reliable\nBuilt-in persistence\n Failsafe high availability\n Active-active geo distribution\n Flexible\nMulti-model\n Flexible deployment options (cloud, hybrid, on-prem)\n Intelligent tiered access to memory (ram and flash)\n (Why am I not getting paid for this? Why did I take the time to even make that\nmodule?)Redis  is NoSQL datastore written in C intended to temporarily hold data in\nmemory for users as they blaze mindlessly through your site. Other use cases\ninclude serving as the foundation for real-time chat apps via the\npublish/subscribe messaging paradigm; popular amongst stupid chat or dating apps\nslowly destroying our abilities as human beings to interact face-to-face.\nPowerful stuff.\n\nStructuring init.py Correctly\nConsider this to be the guide to Flask Application factories I wish I had months\nago. A healthy application factory should:\n\n * Derive all app configuration values from a class or environment variables.\n * Allow Database interactions to occur at any point within the app.\n * Pass values globally outside of the application context.\n\nThis does all of those things:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_session import Session\nfrom flask_redis import FlaskRedis\n\n# Globally accessible libraries\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    \"\"\"Initialize the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Set global session variables\n        r.set('endpoint', str(app.config['ENDPOINT']).encode('utf-8'))\n        r.set('post_query', str(app.config['POST_QUERY']).encode('utf-8'))\n        \n        # Initialize Global Libraries\n        redis_store.init_app(app)\n        db.init_app(app)\n\n        # Include our Routes\n        from . import routes\n\n        return app\n\n\nThe order of operations here is critical.\n\nBefore we do anything related to the app itself, we create instances of \nflask_sqlalchemy  and flask_redis. This will be initialized with our app once we\nactually have one created.\n\nThe first two lines of create_app()  should be no surprise: we're just creating\nour Flask app, and stating that it should be configured using a class called \nConfig  in a file named config.py.\n\napp = Flask(__name__, instance_relative_config=False)\napp.config.from_object('config.Config')\n\n\nMoving down the function comes the moment of truth: creating the app context. \nWhat happens in the app context stays in the app context... except for our sick\nnew Redis setup. By using the Redis .set()  method, we can assign key/value\npairs  for Redis hang on to, such as values from our app config which might be\nneeded elsewhere in our app: r.set('endpoint',\nstr(app.config['ENDPOINT']).encode('utf-8')).\n\nRedis stores information as bytes by default, thus attempting to pass values\nsuch as strings will result in the infamous `b'leading letter b'` phenomenon. Be\nsure to encode your values as utf-8 when using set(), and decode when using\nget().Making Redis Globally Available\nThe next part is important: we need to 'initialize' the services we want to use\nglobally (such as database access or Redis) by using init_app(). This must \nhappen inside the application context, with the parameter being app. This is our\nway of achieving singularity into inter-dimensional travel, thus breaking out of\nthe dreaded application context long after it dies.\n\nLet's Access Some Variables, Baby\nThe moment of truth: will this actually work? Or am I actually a filthy liar\nflooding the internet with more uselessly outdated Flask advice? Let's see:\n\n# routes.py\n\nfrom flask import current_app as app\nfrom flask import make_response\nimport json\nfrom . import models\nfrom . import r\n\nheaders = { 'Access-Control-Allow-Headers': 'Content-Type' }\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef entry():\n    readers = models.Readers.query.filter_by(username='john').all()\n    print(readers)\n    print(r.get('uri').decode('utf-8'))\n    return make_response(str('readers'), 200, headers)\n\n\nEureka! This worthless entry-point prints two things: the value we assigned to\nour Redis block, and all records in our database of people named John:\n\n>> [<User john>]\n>> https://us1-hackersandslackers-543.cloudfunctions.net/link-endpoint?url=\n\n\nAs simple and stupid as it seems, developing an app to this point while\nunderstanding why it works  is a victory for any developer. I complain about\nthis nearly every post, but the fact of the matter is that the heroes who build\nmuch of today's technologies commonly fail to explain their own art in\nunderstandable terms. It's an understandable phenomenon resulting from isolated\nspurts of genius, perhaps, but it damages the growth of companies and humanity\nalike.\n\nSo I guess this is my calling: writing documentation for other people's\naccomplishments. \"Marginally less confusing than 4 open Stackoverflow tabs.\" \nThat's what I hope to have engraved on my gravestone.\n\nMerry Christmas.","html":"<p>A 'skill' that's always fascinated me is just how long some engineers can make it in their career while carrying glaringly obvious gaps in their knowledge of the systems they use every day. To my surprise, I've turned corners where I myself have been that engineer all along, and there's perhaps no better example of this then the time I've spent with Flask.</p><p><strong>WARNING! Highly opinionated statement incoming</strong>: Flask is everything a framework should be. That is to say, it <em>isn't really</em> a framework a fully-fledged framework at all. Sure, the term <em>microframework </em>might seem like a cute PR term, but that doesn't negate the fact that there's something about Flask that's different. When I write apps in <strong>Flask,</strong> I feel as though I'm writing apps in <strong>Python.</strong> On the other hand, when I write apps in <strong>Django,</strong> I feel like I'm just writing apps in <strong>Django.</strong> A disciplined programmer might feel that overly structured frameworks damper creativity and they're probably right: these are the backbones of businesses, thus it makes sense to keep people from deviating from the norm. </p><p>The upside of Flask is also its downside: there's nearly an infinite number of ways to solve a single problem. Every Stackoverflow regular has their own preference, and sometimes, just none of them seem... <em>right. </em>The problem is compounded by some of the phrasing coming from Flask's documentation itself. Flask touts the importance of structuring apps with factories and Blueprints, while simultaneously expressing the power behind the <strong><em>application context.</em></strong> What you'll notice over time is that in Flask's own examples, these two 'very important things' never both appear at the same time: that's because they're simply <em>incompatible with one another.</em> This is a highly understated contradiction of philosophies.</p><h2 id=\"communication-breakdown\">Communication Breakdown?</h2><p>Here's <a href=\"http://flask.pocoo.org/docs/1.0/patterns/appfactories/\">Flask's take on Application factories</a>:</p><blockquote>\n<p>If you are already using packages and blueprints for your application (Modular Applications with Blueprints) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported.</p>\n</blockquote>\n<p>And here's their <a href=\"http://flask.pocoo.org/docs/1.0/appcontext/\">description of the Application context</a>:</p><blockquote>\n<p>The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the current_app and g proxies are accessed instead.</p>\n</blockquote>\n<p>Considering <code>g</code> is intended to stand for \"global\" it seems safe from the previous statements that setting attributes of <code>g</code> can be accessed globally within an application... but they can't. This is where we backpedal and get into messy territory:</p><blockquote>\n<p>However, importing the app instance within the modules in your project is prone to circular import issues. When using the app factory pattern or writing reusable blueprints or extensions there won’t be an app instance to import at all.</p>\n<p>Flask solves this issue with the application context. Rather than referring to an app directly, you use the the <strong>current_app</strong> proxy, which points to the application handling the current activity.</p>\n</blockquote>\n<p>Okay, fine. So if I instantiate an application factory with <code>app.app_context():</code> (which is the only sensible way to create a factory at all)  I should be able to register blueprints within that context, and reference the app context, correct?</p><p>I could be crazy but this <em>never seems to work</em> within blueprints. Whether they exist as peer modules or submodules, the words 'from application import current_app as app' always seems to result in the same \"missing application context\" error. Conveniently it seems, all working examples of the application context seem to be when the Flask developers opt to serve single-file app examples. This <a href=\"https://stackoverflow.com/questions/50233118/access-to-flask-global-variables-in-blueprint-apps\">stranger from Stackoverflow</a> clears things up a bit:</p><blockquote>\n<p>This happens because the data are lost when the context (with app.app_context()) ends (doc).<br>\nInside the context, everything is ok :</p>\n<pre><code class=\"language-python\">from flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n   print(g.my_db)\n\nthis prints 'database ok'\n</code></pre>\n<p>But outside, you cannot access the attribute:</p>\n<pre><code class=\"language-python\">from flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n\nprint(g.my_db)\n</code></pre>\n<p>this throws RuntimeError: Working outside of application context</p>\n<p>even if you create a new context:</p>\n<pre><code class=\"language-python\">from flask import Flask, g\napp = Flask(__name__)\nwith app.app_context():\n   g.my_db = 'database ok'\n\nwith app.app_context():\n   print(g.my_db)\n</code></pre>\n<p>this throws AttributeError: '_AppCtxGlobals' object has no attribute 'my_db'</p>\n</blockquote>\n<p>Alas, here I am. Doomed writing posts to fill in the blanks of documentation left behind by others. </p><h2 id=\"flask-sessions-the-real-slim-shady\">Flask Sessions: The REAL Slim Shady</h2><p><code>Flask-Session</code> is the MVP when it comes sharing temporary information across modularized parts of our program. In fact, it's a bit odd this isn't encouraged more-so than <code>g</code>. But whatever. We're here to heal.</p><p><strong>Sessions</strong> can handled in a number of different ways besides cookies. Take a look at the choices we have for storing session-based values in an instance of Flask:</p><style>\n    tr td:first-child{\n    text-align: left;\n    text-align: top;\n    }\n    \n    tr td:first-child {\n    text-align: left;\n    text-align: top;\n    font-weight: 500;\n    background: #646c82 !important;\n    color: white;\n    border-bottom: 1px solid #747d92;\n    max-width: 70px;\n}\n    \n    table td {\n        font-size:.9em;\n    }\n    \n    td {\n       text-align: left;\n        font-size:.9em;\n        \n    }\n   \n    \n    tr td:nth-of-type(2){\n        font-weight: 100;\n            padding: 20px;\n    }\n    @media (max-width: 800px) {\n        \n        tr td {\n    \t\tpadding: 10px 0;\n        }\n        \n        tbody {\n            margin-left: 0 !important;\n        }\n        \n      tr td:first-child {\n       width: 100%;\n       white-space: nowrap;\n    padding: 10px 0 !important;\n    text-overflow: ellipsis;\n          max-width: none;\n    }\n        \n        tr:first-child td{\n       \t    min-width: 300px;\n            max-width: -webkit-fill-available !important;\n        }\n        \n        th {\n            \n        }\n        \n        tr {\n            padding: 0px !important;\n            overflow-x: hidden;\n        }\n        \n        td {\n            line-height:1.5;\n        }\n        \n        td:nth-of-type(2) {\n            width: 100%;\n            padding: 20px !important;\n        }\n        \n        tr td:nth-of-type(2){\n        font-weight: 100;\n        padding: 15px !important;\n    \t}\n    }\n    \n        \n</style>\n\n<div class=\"tableContainer\">\n  <table>\n  <tbody valign=\"top\">\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_TYPE</span></td>\n      <td>\n        <p class=\"first\">Specifies which type of session interface to\n          use. Built-in session types:</p>\n        <ul class=\"last simple\">\n          <li><strong>null</strong>: NullSessionInterface (default)</li>\n          <li><strong>redis</strong>: RedisSessionInterface</li>\n          <li><strong>memcached</strong>: MemcachedSessionInterface</li>\n          <li><strong>filesystem</strong>: FileSystemSessionInterface</li>\n          <li><strong>mongodb</strong>: MongoDBSessionInterface</li>\n          <li><strong>sqlalchemy</strong>: SqlAlchemySessionInterface</li>\n        </ul>\n      </td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_PERMANENT</span></td>\n      <td>Whether use permanent session or not, default\n        to be <span class=\"pre\">True</span></td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_USE_SIGNER</span></td>\n      <td>Whether sign the session cookie sid or not,\n        if set to <span class=\"pre\">True</span>, you have to set\n        <a class=\"reference external\" href=\"http://flask.pocoo.org/docs/api/#flask.Flask.secret_key\" title=\"(in Flask v0.12-dev)\"><tt class=\"xref py py-attr docutils literal\"><span class=\"pre\">flask.Flask.secret_key</span></tt></a>, default to be\n        <span class=\"pre\">False</span></td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_KEY_PREFIX</span></td>\n      <td>A prefix that is added before all session keys.\n        This makes it possible to use the same backend\n        storage server for different apps, default\n        “session:”</td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_REDIS</span></td>\n      <td>A <span class=\"pre\">redis.Redis</span> instance, default connect to\n        <span class=\"pre\">127.0.0.1:6379</span></td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_MEMCACHED</span></td>\n      <td>A <span class=\"pre\">memcache.Client</span> instance, default connect\n        to <span class=\"pre\">127.0.0.1:11211</span></td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_FILE_DIR</span></td>\n      <td>The directory where session files are stored.\n        Default to use <cite>flask_session</cite> directory under\n        current working directory.</td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_FILE_THRESHOLD</span></td>\n      <td>The maximum number of items the session stores\n        before it starts deleting some, default 500</td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_FILE_MODE</span></td>\n      <td>The file mode wanted for the session files,\n        default 0600</td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_MONGODB</span></td>\n      <td>A <span class=\"pre\">pymongo.MongoClient</span> instance, default\n        connect to <span class=\"pre\">127.0.0.1:27017</span></td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_MONGODB_DB</span></td>\n      <td>The MongoDB database you want to use, default\n        “flask_session”</td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_MONGODB_COLLECT</span></td>\n      <td>The MongoDB collection you want to use, default\n        “sessions”</td>\n    </tr>\n    <tr class=\"row-odd\">\n      <td><span class=\"pre\">SESSION_SQLALCHEMY</span></td>\n      <td>A <span class=\"pre\">flask.ext.sqlalchemy.SQLAlchemy</span> instance\n        whose database connection URI is configured\n        using the <span class=\"pre\">SQLALCHEMY_DATABASE_URI</span> parameter</td>\n    </tr>\n    <tr class=\"row-even\">\n      <td><span class=\"pre\">SESSION_SQLALCHEMY_TABLE</span></td>\n      <td>The name of the SQL table you want to use,\n        default “sessions”</td>\n    </tr>\n  </tbody>\n    </table>\n</div>\n<h3 id=\"using-redis-for-cached-session-information\">Using Redis For Cached Session Information</h3><p>For the sake of trying something different, I've opted to pick up a tiny Redis instance from <a href=\"https://redislabs.com/\"><strong>redislabs</strong></a>. I can't help myself but wasting money on new services to play with; after all, check out how cool this little red box looks:</p>\n<!-- Strengths -->\n<div id=\"unique\">\n  <!-- Headline -->\n  <h2>Redis Enterprise: A Unique Primary Database</h2>\n  <div class=\"item-scale item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-performance-reverse.svg\">\n    <h3>Perfomance at Scale</h3>\n    <ul>\n      <li>50M ops/sec,\n        <1ms 26=\"\" latency,=\"\" with=\"\" only=\"\" cloud=\"\" instances<=\"\" li=\"\"> <li>Symmetric shared–nothing architecture ensures no performance overheads while scaling, auto-sharding and re-balancing</li>\n      <li>Enhanced connection management, pipeline execution and request scheduling</li>\n    </1ms></li></ul>\n  </div>\n  <div class=\"item-search item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-search-reverse.svg\">\n    <h3>Built-in high performance search</h3>\n    <ul>\n      <li>High performance, real-time indexing with items available for search within 1ms</li>\n      <li>Predictable high performance querying while maintaining concurrent loads of indexing and querying</li>\n      <li>Highly scalable across multiple nodes to billions of items per second </li>\n    </ul>\n  </div>\n  <div class=\"item-fail item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-fail-reverse.svg\" class=\"popup-image\">\n    <h3>Failsafe high availability</h3>\n    <ul>\n      <li>Cross-rack/zone/datacenter/geo replication</li>\n      <li>Instant auto-failover in single digit second</li>\n      <li>Zero impact on throughput and latency during cluster operations such as scaling, upgrades, re-sharding and rebalancing</li>\n      <li>Out-of-the box support for backup, restore and DR</li>\n    </ul>\n  </div>\n  <div class=\"item-geo item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-geo-reverse.svg\" class=\"popup-image\">\n    <h3>Active-active geo distribution</h3>\n    <ul>\n      <li>Reads/Writes in multiple geo regions to the same dataset</li>\n      <li>Local latencies, global availability</li>\n      <li>Built-in conflict resolution for simple and complex data types</li>\n      <li>Based on revolutionary CRDT academic research</li>\n    </ul>\n  </div>\n  <div class=\"item-persist item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-persist-reverse.svg\" class=\"popup-image\">\n    <h3>Built-in persistence</h3>\n    <ul>\n      <li>Enhanced storage engine for parallel access to any persistent storage</li>\n      <li>Multiple options for enhanced data persistence</li>\n      <li>Reliable persistence configurations on both master and slave shards with zero performance impact</li>\n    </ul>\n  </div>\n  <div class=\"item-multi item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-multi-reverse.svg\" class=\"popup-image\">\n    <h3>Multi-model</h3>\n    <ul>\n      <li>Graph, JSON, Machine Learning and Bloom filter modules set industry standards for high performance</li>\n      <li>Multi-shard coordination</li>\n      <li>Extensibility with custom modules</li>\n    </ul>\n  </div>\n  <div class=\"item-tiered item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-tiered-reverse.svg\" class=\"popup-image\">\n    <h3>Intelligent tiered access to memory</h3>\n    <ul>\n      <li>Up to 80% lower infrastructure costs by running Redis on Flash</li>\n      <li>Automatic management of data tiering between RAM &amp; Flash with no code changes</li>\n      <li>Supports all new persistent memory technologies</li>\n    </ul>\n  </div>\n  <div class=\"item-deploy item hidden\">\n    <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-deploy-reverse.svg\" class=\"popup-image\">\n    <h3>Flexible deployment options</h3>\n    <ul>\n      <li>Hybrid clusters can span on-prem infrastructure and multiple clouds</li>\n      <li>Most efficient use of resources with maximized core usage, multi-tenancy, re-sharding and re-balancing to avoid noisy neighbors in every environment</li>\n    </ul>\n  </div>\n  <!-- Categories -->\n  <!-- Desktop Grid -->\n  <div class=\"strengths\">\n    <!-- Grid - Row -->\n\n    <div class=\"main-flex\">\n      <div class=\"columns medium-4 left parent\">\n        <div class=\"columns feature item-fast scale\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Perfomance at Scale\n          </div>\n        </div>\n\n        <div class=\"columns feature item-durable persistence\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Built-in persistence\n          </div>\n        </div>\n\n        <div class=\"columns feature item-durable failsafe\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Failsafe high availability\n          </div>\n        </div>\n\n        <div class=\"columns feature item-durable geo\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Active-active geo distribution\n          </div>\n        </div>\n\n      </div>\n      <div class=\"columns medium-4 center parent\">\n        <div class=\"redis red-strengths\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/redis-e-logo.svg\" alt=\"Redis Labs\">\n        </div>\n      </div>\n      <div class=\"columns medium-4 right parent\">\n        <div class=\"columns feature right item-fast search\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Built-in high performance search\n          </div>\n        </div>\n\n        <div class=\"columns feature item-flex multi\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Multi-model\n          </div>\n        </div>\n\n        <div class=\"columns feature item-flex vert tiered\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Intelligent tiered access to memory\n            <br>(RAM and Flash)\n          </div>\n        </div>\n\n        <div class=\"columns feature item-flex vert deploy\">\n          <div class=\"img\">\n          </div>\n          <div class=\"text\">\n            Flexible deployment options\n            <br>(cloud, on-prem, hybrid)\n          </div>\n        </div>\n\n\n      </div>\n\n    </div>\n\n    <!-- Grid - Redis Logo-->\n\n  </div>\n  <!-- End Desktop Grid -->\n\n\n\n  <div class=\"grid-container mobile-grid\">\n    <div class=\"redis-mobile red-strengths\">\n      <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/redis-e-logo.svg\" alt=\"Redis Labs\">\n    </div>\n    <!-- Column 1 -->\n    <div class=\"mobile-flex\">\n      <div class=\"columns small-12 medium-4\">\n        <h3>Fast</h3>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-performance.svg\">\n          <span class=\"text short\">\n            Performance at scale\n          </span>\n        </div>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-search.svg\">\n          <span class=\"text med\">\n            Built-in high performance search\n          </span>\n        </div>\n      </div>\n      <!-- End Column 1 -->\n      <!-- Column 2 -->\n      <div class=\"columns small-12 medium-4\">\n        <h3>Reliable</h3>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-persist.svg\">\n          <span class=\"text short\">\n            Built-in persistence\n          </span>\n        </div>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-fail.svg\">\n          <span class=\"text short med\">\n            Failsafe high availability\n          </span>\n        </div>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-geo.svg\">\n          <span class=\"text med\">\n            Active-active geo distribution\n          </span>\n        </div>\n      </div>\n      <!-- End Column 2 -->\n      <!-- Column 3 -->\n      <div class=\"columns small-12 medium-4\">\n        <h3>Flexible</h3>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-multi.svg\">\n          <span class=\"text short\">\n            Multi-model\n          </span>\n        </div>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-deploy.svg\">\n          <span class=\"text long\">\n            Flexible deployment options <span class=\"small\">(cloud, hybrid, on-prem)</span>\n          </span>\n        </div>\n        <div class=\"columns\">\n          <img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/ico-front-tiered.svg\">\n          <span class=\"text long\">\n            Intelligent tiered access to memory <span class=\"small\">(ram and flash)</span>\n          </span>\n        </div>\n      </div>\n    </div>\n    <!-- End Column 3 -->\n  </div>\n</div>\n<span style=\"color: #969696;\n    text-align: center;\n    display: block;\n    font-weight: 100;\n    font-style: italic;\n    margin-bottom: 30px;\n    font-size: .9em;\">(Why am I not getting paid for this? Why did I take the time to even make that module?)</span><p><strong>Redis</strong> is NoSQL datastore written in C intended to temporarily hold data in memory for users as they blaze mindlessly through your site. Other use cases include serving as the foundation for real-time chat apps via the publish/subscribe messaging paradigm; popular amongst stupid chat or dating apps slowly destroying our abilities as human beings to interact face-to-face. Powerful stuff.</p><h2 id=\"structuring-init-py-correctly\">Structuring <strong>init</strong>.py Correctly</h2><p>Consider this to be the guide to Flask Application factories I wish I had months ago. A healthy application factory should:</p><ul><li>Derive all app configuration values from a class or environment variables.</li><li>Allow Database interactions to occur at any point within the app.</li><li>Pass values globally outside of the application context.</li></ul><p>This does all of those things:</p><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_session import Session\nfrom flask_redis import FlaskRedis\n\n# Globally accessible libraries\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    &quot;&quot;&quot;Initialize the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Set global session variables\n        r.set('endpoint', str(app.config['ENDPOINT']).encode('utf-8'))\n        r.set('post_query', str(app.config['POST_QUERY']).encode('utf-8'))\n        \n        # Initialize Global Libraries\n        redis_store.init_app(app)\n        db.init_app(app)\n\n        # Include our Routes\n        from . import routes\n\n        return app\n</code></pre>\n<p>The order of operations here is critical.</p><p>Before we do anything related to the app itself, we create instances of <code>flask_sqlalchemy</code> and <code>flask_redis</code>. This will be initialized with our app once we actually have one created.</p><p>The first two lines of <code>create_app()</code> should be no surprise: we're just creating our Flask app, and stating that it should be configured using a class called <strong>Config</strong> in a file named <strong>config.py.</strong></p><pre><code class=\"language-python\">app = Flask(__name__, instance_relative_config=False)\napp.config.from_object('config.Config')\n</code></pre>\n<p>Moving down the function comes the moment of truth: <strong>creating the app context.</strong> What happens in the app context stays in the app context... except for our sick new Redis setup. By using the Redis <code>.set()</code> method, we can assign <em>key/value pairs</em> for Redis hang on to, such as values from our app config which might be needed elsewhere in our app: <code>r.set('endpoint', str(app.config['ENDPOINT']).encode('utf-8'))</code>.</p><div class=\"protip\">\n    Redis stores information as bytes by default, thus attempting to pass values such as strings will result in the infamous `b'leading letter b'` phenomenon. Be sure to encode your values as utf-8 when using set(), and decode when using get().\n</div><h3 id=\"making-redis-globally-available\">Making Redis Globally Available</h3><p>The next part is important: we need to 'initialize' the services we want to use globally (such as database access or Redis) by using <code>init_app()</code>. This <em>must </em>happen inside the application context, with the parameter being <code>app</code>. This is our way of achieving singularity into inter-dimensional travel, thus breaking out of the dreaded application context long after it dies.</p><h2 id=\"let-s-access-some-variables-baby\">Let's Access Some Variables, Baby</h2><p>The moment of truth: will this actually work? Or am I actually a filthy liar flooding the internet with more uselessly outdated Flask advice? Let's see:</p><pre><code class=\"language-python\"># routes.py\n\nfrom flask import current_app as app\nfrom flask import make_response\nimport json\nfrom . import models\nfrom . import r\n\nheaders = { 'Access-Control-Allow-Headers': 'Content-Type' }\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef entry():\n    readers = models.Readers.query.filter_by(username='john').all()\n    print(readers)\n    print(r.get('uri').decode('utf-8'))\n    return make_response(str('readers'), 200, headers)\n</code></pre>\n<p>Eureka! This worthless entry-point prints two things: the value we assigned to our Redis block, and all records in our database of people named John:</p><pre><code class=\"language-bash\">&gt;&gt; [&lt;User john&gt;]\n&gt;&gt; https://us1-hackersandslackers-543.cloudfunctions.net/link-endpoint?url=\n</code></pre>\n<p>As simple and stupid as it seems, developing an app to this point <em>while understanding why it works</em> is a victory for any developer. I complain about this nearly every post, but the fact of the matter is that the heroes who build much of today's technologies commonly fail to explain their own art in understandable terms. It's an understandable phenomenon resulting from isolated spurts of genius, perhaps, but it damages the growth of companies and humanity alike.</p><p>So I guess this is my calling: writing documentation for other people's accomplishments. <strong>\"Marginally less confusing than 4 open Stackoverflow tabs.\"</strong> That's what I hope to have engraved on my gravestone.</p><p>Merry Christmas.</p>","url":"https://hackersandslackers.com/demystifying-flasks-application-context/","uuid":"ede882df-a696-43ef-a392-9430d98a961e","page":false,"codeinjection_foot":"<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/autoNumeric.min.js\"></script>\n\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/underscore-min.js\"></script>\n\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/mustache.min.js\"></script>\n\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/owl.js\"></script>\n\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/jquery.counterup.min.js\"></script>\n\n\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/foundation.js\"></script>\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/docker.js\"></script>\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/jquery.fancybox.pack.js\"></script>\n<script type=\"text/javascript\" async=\"\" src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/scripts.js\"></script>","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/redis/redislast2.css\">","comment_id":"5c192cdba632c8240cad3869"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673734","title":"Scraping Data on the Web with BeautifulSoup","slug":"scraping-urls-with-beautifulsoup","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/11/beauitfulsoup2@2x.jpg","excerpt":"The honest act of systematically stealing data without permission.","custom_excerpt":"The honest act of systematically stealing data without permission.","created_at_pretty":"11 November, 2018","published_at_pretty":"11 November, 2018","updated_at_pretty":"05 January, 2019","created_at":"2018-11-11T04:53:44.000-05:00","published_at":"2018-11-11T08:35:09.000-05:00","updated_at":"2019-01-05T13:21:06.000-05:00","meta_title":"Scraping URLs with BeautifulSoup | Hackers and Slackers","meta_description":"Using Python's BeautifulSoup library to scrape the web. This tutorial covers scraping links for metadata to generate link previews.","og_description":"Using Python's BeautifulSoup library to scrape the web. This tutorial covers scraping links for metadata to generate link previews.","og_image":"https://hackersandslackers.com/content/images/2018/11/beauitfulsoup2@2x.jpg","og_title":"Scraping URLs with BeautifulSoup | Hackers and Slackers","twitter_description":"Using Python's BeautifulSoup library to scrape the web. This tutorial covers scraping links for metadata to generate link previews.","twitter_image":"https://hackersandslackers.com/content/images/2018/11/beauitfulsoup2@2x.jpg","twitter_title":"Scraping URLs with BeautifulSoup | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"}],"plaintext":"There are plenty of reliable and open sources of data on the web. Datasets are\nfreely released to the public domain by the likes of Kaggle, Google Cloud, and\nof course local & federal government. Like most things free and open, however,\nfollowing the rules to obtain public data can be a bit... boring. I'm not\nsuggesting we go and blatantly break some grey-area laws by stealing data, but\nthis blog isn't exactly called People Who Play It Safe And Slackers, either. \n\nMy personal Python roots can actually be traced back to an ambitious\nside-project: to aggregate all new music from across the web and deliver it the\nmasses. While that project may have been abandoned (after realizing it already\nexisted), BeautifulSoup  was more-or-less my first ever experience with Python. \n\nThe Tool(s) for the Job(s)\nBefore going any further, we'd be ill-advised to not at least mention Python's\nother web-scraping behemoth, Scrapy [https://scrapy.org/]. BeautifulSoup  and \nScrapy  have two very different agendas. BeautifulSoup is intended to parse or\nextract data one page at a time, with each page being served up via the requests \n library or equivalent. Scrapy,  on the other hand, is for creating crawlers: or\nrather absolute monstrosities unleashed upon the web like a swarm, loosely\nfollowing links and haste-fully grabbing data where data exists to be grabbed.\nTo put this in perspective, Google Cloud functions will not even let you import\nScrapy as a usable library.\n\nThis isn't to say that BeautifulSoup  can't be made into a similar monstrosity\nof its own. For now, we'll focus on a modest task: generating link previews for\nURLs by grabbing their metadata.\n\nStep 1: Stalk Your Prey\nBefore we steal any data, we should take a look at the data we're hoping to\nsteal.\n\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape(url):\n    \"\"\"Scrape URLs to generate previews.\"\"\"\n    headers = requests.utils.default_headers()\n    headers.update({\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n    })\n    r = requests.get(url, headers)\n    raw_html = r.content\n    soup = BeautifulSoup(raw_html, 'html.parser')\n    print(soup.prettify())\n\n\nThe above is the minimum needed to retrieve the DOM structure of an HTML page. \nBeautifulSoup  accepts the .content  output from a request, from which we can\ninvestigate the contents.\n\nUsing BeauitfulSoup will often result in different results for your scaper than\nyou might see as a human, such as 403 errors or blocked content. An easy way\naround this faking your headers into looking like normal browser agents, as we\ndo here: \nheaders.update({\n'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101\nFirefox/52.0',\n})`The result of print(soup.prettify())  will predictably output a \"pretty\" printed\nversion of your target DOM structure:\n\n<html class=\"gr__example_com\"><head>\n    <title>Example Domain</title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <meta property=\"og:site_name\" content=\"Example dot com\">\n    <meta property=\"og:type\" content=\"website\">\n    <meta property=\"og:title\" content=\"Example\">\n    <meta property=\"og:description\" content=\"An Example website.\">\n    <meta property=\"og:image\" content=\"http://example.com/img/image.jpg\">\n    <meta name=\"twitter:title\" content=\"Hackers and Slackers\">\n    <meta name=\"twitter:description\" content=\"An Example website.\">\n    <meta name=\"twitter:url\" content=\"http://example.com/\">\n    <meta name=\"twitter:image\" content=\"http://example.com/img/image.jpg\">\n</head>\n\n<body data-gr-c-s-loaded=\"true\">\n  <div>\n    <h1>Example Domain</h1>\n      <p>This domain is established to be used for illustrative examples in documents.</p>\n      <p>You may use this domain in examples without prior coordination or asking for permission.</p>\n    <p><a href=\"http://www.iana.org/domains/example\">More information...</a></p>\n  </div>\n</body>\n    \n</html>\n\n\nStep 2: The Extraction\nAfter turning our request content into a BeautifulSoup object, we access items\nin the DOM via dot notation as such:\n\ntitle = soup.title.string\n\n\n.string  gives us the actual content of the tag which is Example Domain, whereas\n soup.title  would return the entirety of the tag as <title>Example\nDomain</title>. \n\nDot notation is fine when pages have predictable hierarchies or structures, but\nbecomes much less useful for extracting patterns we see in the document. soup.a \nwill only return the first instance of a link, and probably isn't what we want.\n\nIf we wanted to extract all  <a>  tags of a page's content while avoiding the\nnoise of nav links etc, we can use CSS selectors to return a list of all\nelements matching the selection. soup.select('body p > a')  retrieves all links\nembedded in paragraph text, limited to the body of the page. \n\nSome other methods of grabbing elements:\n\n * soup.find(id=\"example\"): Useful for when a single element is expected.\n * soup.find_all('a'):  Returns a list of all elements matching the selection\n   after searching the document recursively.\n * .parent and .child: Relative selectors to a currently engaged element.\n\nGet Some Attributes\nChances are we'll almost always want the contents or the attributes of a tag, as\nopposed to the entire <a>  tag's HTML. A common example of going after a tag's\nattributes would be in the cases of img  and a  tags. Chances are we're most\ninterested in the src  and href  attributes of such tags, respectively. \n\nThe .get  method refers specifically to getting the value of attributes on a\ntag. For example, soup.find('.logo').get('href')  would find an element with the\nclass \"logo\", and return the url to that image.\n\nPesky Tags to Deal With\nIn our example of creating link previews, a good first source of information\nwould obviously be the page's meta tags: specifically the og  tags they've\nspecified to openly provide the bite-sized information we're looking for.\nGrabbing these tags are a bit more difficult to deal with:\n\nsoup.find(\"meta\", property=\"og:description\").get('content')\n\n\nOh yeah, now that's some ugly shit right there. Meta tags are especially\ninteresting because they're all uselessly dubbed 'meta', thus we need a second\ndifferentiator in addition to the tag name to specify which meta tag we care\nabout. Only then can we bother to get  the actual content of said tag.\n\nStep 3: Realizing Something Will Always Break\nIf we were to try the above selector on an HTML page which did not contain an \nog:description, our script would break unforgivingly. Not only do we miss this\ndata, but we miss out on everything entirely - this means we always need to\nbuild in a plan B, and at the very least deal with a lack of tag altogether.\n\nIt's best to break out this logic one tag at a time. First, let's look at an\nexample for a base scraper with all the knowledge we have so far:\n\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape(url):\n    \"\"\"Scrape scheduled link previews.\"\"\"\n    headers = requests.utils.default_headers()\n    headers.update({\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n    })\n    r = requests.get(url)\n    raw_html = r.content\n    soup = BeautifulSoup(raw_html, 'html.parser')\n    links = soup.select('body p > a')\n    previews = []\n    for link in links:\n        url = link.get('href')\n        r2 = requests.get(url, headers=headers)\n        link_html = r2.content\n        embedded_link = BeautifulSoup(link_html, 'html.parser')\n        link_preview_dict = {\n            'title': getTitle(embedded_link),\n            'description': getDescription(embedded_link),\n            'image': getImage(embedded_link),\n            'sitename': getSiteName(embedded_link, url),\n            'url': url\n            }\n        previews.append(link_preview_dict)\n        print(link_preview_dict)\n\n\nGreat - there's a base function for snatching all links out of the body of a\npage. Ultimately we'll create a JSON object for each of these links containing\npreview data, link_preview_dict.\n\nTo handle each value of our dict, we have individual functions:\n\ndef getTitle(link):\n    \"\"\"Attempt to get a title.\"\"\"\n    title = ''\n    if link.title.string is not None:\n        title = link.title.string\n    elif link.find(\"h1\") is not None:\n        title = link.find(\"h1\")\n    return title\n\n\ndef getDescription(link):\n    \"\"\"Attempt to get description.\"\"\"\n    description = ''\n    if link.find(\"meta\", property=\"og:description\") is not None:\n        description = link.find(\"meta\", property=\"og:description\").get('content')\n    elif link.find(\"p\") is not None:\n        description = link.find(\"p\").content\n    return description\n\n\ndef getImage(link):\n    \"\"\"Attempt to get a preview image.\"\"\"\n    image = ''\n    if link.find(\"meta\", property=\"og:image\") is not None:\n        image = link.find(\"meta\", property=\"og:image\").get('content')\n    elif link.find(\"img\") is not None:\n        image = link.find(\"img\").get('href')\n    return image\n\n\ndef getSiteName(link, url):\n    \"\"\"Attempt to get the site's base name.\"\"\"\n    sitename = ''\n    if link.find(\"meta\", property=\"og:site_name\") is not None:\n        sitename = link.find(\"meta\", property=\"og:site_name\").get('content')\n    else:\n        sitename = url.split('//')[1]\n        name = sitename.split('/')[0]\n        name = sitename.rsplit('.')[1]\n        return name.capitalize()\n    return sitename\n\n\nIn case you're wondering:\n\n * getTitle tries to get the <title>  tag, and falls back to the page's first \n   <h1>  tag (surprisingly enough some pages are in fact missing a title).\n * getDescription  looks for the OG description, and falls back to the content\n   of the page's first paragraph.\n * getImage looks for the OG image, and falls back to the page's first image.\n * getSiteName similarly tries to grab the OG attribute, otherwise it does it's\n   best to extract the domain name from the URL string under the assumption that\n   this is the origin's name (look, it ain't perfect).\n\nWhat Did We Just Build?\nBelieve it or not, the above is considered to be enough logic to be a paid\nservice with a monthly fee. Go ahead and Google it; or better yet, just steal my\nsource code entirely:\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom flask import make_response\n\n\ndef getTitle(link):\n    \"\"\"Attempt to get a title.\"\"\"\n    title = ''\n    if link.title.string is not None:\n        title = link.title.string\n    elif link.find(\"h1\") is not None:\n        title = link.find(\"h1\")\n    return title\n\n\ndef getDescription(link):\n    \"\"\"Attempt to get description.\"\"\"\n    description = ''\n    if link.find(\"meta\", property=\"og:description\") is not None:\n        description = link.find(\"meta\", property=\"og:description\").get('content')\n    elif link.find(\"p\") is not None:\n        description = link.find(\"p\").content\n    return description\n\n\ndef getImage(link):\n    \"\"\"Attempt to get image.\"\"\"\n    image = ''\n    if link.find(\"meta\", property=\"og:image\") is not None:\n        image = link.find(\"meta\", property=\"og:image\").get('content')\n    elif link.find(\"img\") is not None:\n        image = link.find(\"img\").get('href')\n    return image\n\n\ndef getSiteName(link, url):\n    \"\"\"Attempt to get the site's base name.\"\"\"\n    sitename = ''\n    if link.find(\"meta\", property=\"og:site_name\") is not None:\n        sitename = link.find(\"meta\", property=\"og:site_name\").get('content')\n    else:\n        sitename = url.split('//')[1]\n        name = sitename.split('/')[0]\n        name = sitename.rsplit('.')[1]\n        return name.capitalize()\n    return sitename\n\n\ndef scrape(request):\n    \"\"\"Scrape scheduled link previews.\"\"\"\n    if request.method == 'POST':\n        # Allows POST requests from any origin with the Content-Type\n        # header and caches preflight response for an 3600s\n        headers = {\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Methods': 'POST',\n            'Access-Control-Allow-Headers': 'Content-Type',\n            'Access-Control-Max-Age': '3600'\n        }\n        request_json = request.get_json()\n        target_url = request_json['url']\n        headers.update({\n            'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n        })\n        r = requests.get(target_url)\n        raw_html = r.content\n        soup = BeautifulSoup(raw_html, 'html.parser')\n        links = soup.select('.post-content p > a')\n        previews = []\n        for link in links:\n            url = link.get('href')\n            r2 = requests.get(url, headers=headers)\n            link_html = r2.content\n            embedded_link = BeautifulSoup(link_html, 'html.parser')\n            preview_dict = {\n                'title': getTitle(embedded_link),\n                'description': getDescription(embedded_link),\n                'image': getImage(embedded_link),\n                'sitename': getSiteName(embedded_link, url),\n                'url': url\n                }\n            previews.append(preview_dict)\n        return make_response(str(previews), 200, headers)\n    return make_response('bruh pls', 400, headers)","html":"<p>There are plenty of reliable and open sources of data on the web. Datasets are freely released to the public domain by the likes of Kaggle, Google Cloud, and of course local &amp; federal government. Like most things free and open, however, following the rules to obtain public data can be a bit... boring. I'm not suggesting we go and blatantly break some grey-area laws by stealing data, but this blog isn't exactly called <strong>People Who Play It Safe And Slackers</strong>, either. </p><p>My personal Python roots can actually be traced back to an ambitious side-project: to aggregate all new music from across the web and deliver it the masses. While that project may have been abandoned (after realizing it already existed), <strong>BeautifulSoup</strong> was more-or-less my first ever experience with Python. </p><h2 id=\"the-tool-s-for-the-job-s-\">The Tool(s) for the Job(s)</h2><p>Before going any further, we'd be ill-advised to not at least mention Python's other web-scraping behemoth, <strong><a href=\"https://scrapy.org/\">Scrapy</a></strong>. <strong>BeautifulSoup</strong> and <strong>Scrapy</strong> have two very different agendas. BeautifulSoup is intended to parse or extract data one page at a time, with each page being served up via the <strong>requests</strong> library or equivalent. <strong>Scrapy,</strong> on the other hand, is for creating crawlers: or rather absolute monstrosities unleashed upon the web like a swarm, loosely following links and haste-fully grabbing data where data exists to be grabbed. To put this in perspective, Google Cloud functions will not even let you import Scrapy as a usable library.</p><p>This isn't to say that <strong>BeautifulSoup</strong> can't be made into a similar monstrosity of its own. For now, we'll focus on a modest task: generating link previews for URLs by grabbing their metadata.</p><h2 id=\"step-1-stalk-your-prey\">Step 1: Stalk Your Prey</h2><p>Before we steal any data, we should take a look at the data we're hoping to steal.</p><pre><code class=\"language-python\">import requests\nfrom bs4 import BeautifulSoup\n\ndef scrape(url):\n    &quot;&quot;&quot;Scrape URLs to generate previews.&quot;&quot;&quot;\n    headers = requests.utils.default_headers()\n    headers.update({\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n    })\n    r = requests.get(url, headers)\n    raw_html = r.content\n    soup = BeautifulSoup(raw_html, 'html.parser')\n    print(soup.prettify())\n</code></pre>\n<p>The above is the minimum needed to retrieve the DOM structure of an HTML page. <strong>BeautifulSoup</strong> accepts the <code>.content</code> output from a request, from which we can investigate the contents.</p><div class=\"protip\">\n    Using BeauitfulSoup will often result in different results for your scaper than you might see as a human, such as 403 errors or blocked content. An easy way around this faking your headers into looking like normal browser agents, as we do here: <br><code>headers.update({\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n    })`</code>\n</div><p>The result of <code>print(soup.prettify())</code> will predictably output a \"pretty\" printed version of your target DOM structure:</p><pre><code class=\"language-html\">&lt;html class=&quot;gr__example_com&quot;&gt;&lt;head&gt;\n    &lt;title&gt;Example Domain&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n    &lt;meta property=&quot;og:site_name&quot; content=&quot;Example dot com&quot;&gt;\n    &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;\n    &lt;meta property=&quot;og:title&quot; content=&quot;Example&quot;&gt;\n    &lt;meta property=&quot;og:description&quot; content=&quot;An Example website.&quot;&gt;\n    &lt;meta property=&quot;og:image&quot; content=&quot;http://example.com/img/image.jpg&quot;&gt;\n    &lt;meta name=&quot;twitter:title&quot; content=&quot;Hackers and Slackers&quot;&gt;\n    &lt;meta name=&quot;twitter:description&quot; content=&quot;An Example website.&quot;&gt;\n    &lt;meta name=&quot;twitter:url&quot; content=&quot;http://example.com/&quot;&gt;\n    &lt;meta name=&quot;twitter:image&quot; content=&quot;http://example.com/img/image.jpg&quot;&gt;\n&lt;/head&gt;\n\n&lt;body data-gr-c-s-loaded=&quot;true&quot;&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Example Domain&lt;/h1&gt;\n      &lt;p&gt;This domain is established to be used for illustrative examples in documents.&lt;/p&gt;\n      &lt;p&gt;You may use this domain in examples without prior coordination or asking for permission.&lt;/p&gt;\n    &lt;p&gt;&lt;a href=&quot;http://www.iana.org/domains/example&quot;&gt;More information...&lt;/a&gt;&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n    \n&lt;/html&gt;\n</code></pre>\n<h2 id=\"step-2-the-extraction\">Step 2: The Extraction</h2><p>After turning our request content into a BeautifulSoup object, we access items in the DOM via dot notation as such:</p><pre><code class=\"language-python\">title = soup.title.string\n</code></pre>\n<p><code>.string</code> gives us the actual content of the tag which is <code>Example Domain</code>, whereas <code>soup.title</code> would return the entirety of the tag as <code>&lt;title&gt;Example Domain&lt;/title&gt;</code>. </p><p>Dot notation is fine when pages have predictable hierarchies or structures, but becomes much less useful for extracting patterns we see in the document. <code>soup.a</code> will only return the first instance of a link, and probably isn't what we want.</p><p>If we wanted to extract <em>all</em> <code>&lt;a&gt;</code> tags of a page's content while avoiding the noise of nav links etc, we can use CSS selectors to return a list of all elements matching the selection. <code>soup.select('body p &gt; a')</code> retrieves all links embedded in paragraph text, limited to the body of the page. </p><p>Some other methods of grabbing elements:</p><ul><li><strong>soup.find(id=\"example\")</strong>: Useful for when a single element is expected.</li><li><strong>soup.find_all('a')</strong>:<strong> </strong>Returns a list of all elements matching the selection after searching the document recursively.</li><li><strong>.parent </strong>and <strong>.child</strong>: Relative selectors to a currently engaged element.</li></ul><h3 id=\"get-some-attributes\">Get Some Attributes</h3><p>Chances are we'll almost always want the contents or the attributes of a tag, as opposed to the entire <code>&lt;a&gt;</code> tag's HTML. A common example of going after a tag's attributes would be in the cases of <code>img</code> and <code>a</code> tags. Chances are we're most interested in the <code>src</code> and <code>href</code> attributes of such tags, respectively. </p><p>The <code>.get</code> method refers specifically to getting the value of attributes on a tag. For example, <code>soup.find('.logo').get('href')</code> would find an element with the class \"logo\", and return the url to that image.</p><h3 id=\"pesky-tags-to-deal-with\">Pesky Tags to Deal With</h3><p>In our example of creating link previews, a good first source of information would obviously be the page's meta tags: specifically the <code>og</code> tags they've specified to openly provide the bite-sized information we're looking for. Grabbing these tags are a bit more difficult to deal with:</p><pre><code class=\"language-python\">soup.find(&quot;meta&quot;, property=&quot;og:description&quot;).get('content')\n</code></pre>\n<p>Oh yeah, now that's some ugly shit right there. Meta tags are especially interesting because they're all uselessly dubbed 'meta', thus we need a second differentiator in addition to the tag name to specify <em>which </em>meta tag we care about. Only then can we bother to <em>get</em> the actual content of said tag.</p><h2 id=\"step-3-realizing-something-will-always-break\">Step 3: Realizing Something Will Always Break</h2><p>If we were to try the above selector on an HTML page which did not contain an <code>og:description</code>, our script would break unforgivingly. Not only do we miss this data, but we miss out on everything entirely - this means we always need to build in a plan B, and at the very least deal with a lack of tag altogether.</p><p>It's best to break out this logic one tag at a time. First, let's look at an example for a base scraper with all the knowledge we have so far:</p><pre><code class=\"language-python\">import requests\nfrom bs4 import BeautifulSoup\n\ndef scrape(url):\n    &quot;&quot;&quot;Scrape scheduled link previews.&quot;&quot;&quot;\n    headers = requests.utils.default_headers()\n    headers.update({\n        'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n    })\n    r = requests.get(url)\n    raw_html = r.content\n    soup = BeautifulSoup(raw_html, 'html.parser')\n    links = soup.select('body p &gt; a')\n    previews = []\n    for link in links:\n        url = link.get('href')\n        r2 = requests.get(url, headers=headers)\n        link_html = r2.content\n        embedded_link = BeautifulSoup(link_html, 'html.parser')\n        link_preview_dict = {\n            'title': getTitle(embedded_link),\n            'description': getDescription(embedded_link),\n            'image': getImage(embedded_link),\n            'sitename': getSiteName(embedded_link, url),\n            'url': url\n            }\n        previews.append(link_preview_dict)\n        print(link_preview_dict)\n</code></pre>\n<p>Great - there's a base function for snatching all links out of the body of a page. Ultimately we'll create a JSON object for each of these links containing preview data, <code>link_preview_dict</code>.</p><p>To handle each value of our dict, we have individual functions:</p><pre><code class=\"language-python\">def getTitle(link):\n    &quot;&quot;&quot;Attempt to get a title.&quot;&quot;&quot;\n    title = ''\n    if link.title.string is not None:\n        title = link.title.string\n    elif link.find(&quot;h1&quot;) is not None:\n        title = link.find(&quot;h1&quot;)\n    return title\n\n\ndef getDescription(link):\n    &quot;&quot;&quot;Attempt to get description.&quot;&quot;&quot;\n    description = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:description&quot;) is not None:\n        description = link.find(&quot;meta&quot;, property=&quot;og:description&quot;).get('content')\n    elif link.find(&quot;p&quot;) is not None:\n        description = link.find(&quot;p&quot;).content\n    return description\n\n\ndef getImage(link):\n    &quot;&quot;&quot;Attempt to get a preview image.&quot;&quot;&quot;\n    image = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:image&quot;) is not None:\n        image = link.find(&quot;meta&quot;, property=&quot;og:image&quot;).get('content')\n    elif link.find(&quot;img&quot;) is not None:\n        image = link.find(&quot;img&quot;).get('href')\n    return image\n\n\ndef getSiteName(link, url):\n    &quot;&quot;&quot;Attempt to get the site's base name.&quot;&quot;&quot;\n    sitename = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:site_name&quot;) is not None:\n        sitename = link.find(&quot;meta&quot;, property=&quot;og:site_name&quot;).get('content')\n    else:\n        sitename = url.split('//')[1]\n        name = sitename.split('/')[0]\n        name = sitename.rsplit('.')[1]\n        return name.capitalize()\n    return sitename\n</code></pre>\n<p>In case you're wondering:</p><ul><li><strong>getTitle </strong>tries to get the <code>&lt;title&gt;</code> tag, and falls back to the page's first <code>&lt;h1&gt;</code> tag (surprisingly enough some pages are in fact missing a title).</li><li><strong>getDescription</strong> looks for the OG description, and falls back to the content of the page's first paragraph.</li><li><strong>getImage </strong>looks for the OG image, and falls back to the page's first image.</li><li><strong>getSiteName </strong>similarly tries to grab the OG attribute, otherwise it does it's best to extract the domain name from the URL string under the assumption that this is the origin's name (look, it ain't perfect).</li></ul><h2 id=\"what-did-we-just-build\">What Did We Just Build?</h2><p>Believe it or not, the above is considered to be enough logic to be a paid service with a monthly fee. Go ahead and Google it; or better yet, just steal my source code entirely:</p><pre><code class=\"language-python\">import requests\nfrom bs4 import BeautifulSoup\nfrom flask import make_response\n\n\ndef getTitle(link):\n    &quot;&quot;&quot;Attempt to get a title.&quot;&quot;&quot;\n    title = ''\n    if link.title.string is not None:\n        title = link.title.string\n    elif link.find(&quot;h1&quot;) is not None:\n        title = link.find(&quot;h1&quot;)\n    return title\n\n\ndef getDescription(link):\n    &quot;&quot;&quot;Attempt to get description.&quot;&quot;&quot;\n    description = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:description&quot;) is not None:\n        description = link.find(&quot;meta&quot;, property=&quot;og:description&quot;).get('content')\n    elif link.find(&quot;p&quot;) is not None:\n        description = link.find(&quot;p&quot;).content\n    return description\n\n\ndef getImage(link):\n    &quot;&quot;&quot;Attempt to get image.&quot;&quot;&quot;\n    image = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:image&quot;) is not None:\n        image = link.find(&quot;meta&quot;, property=&quot;og:image&quot;).get('content')\n    elif link.find(&quot;img&quot;) is not None:\n        image = link.find(&quot;img&quot;).get('href')\n    return image\n\n\ndef getSiteName(link, url):\n    &quot;&quot;&quot;Attempt to get the site's base name.&quot;&quot;&quot;\n    sitename = ''\n    if link.find(&quot;meta&quot;, property=&quot;og:site_name&quot;) is not None:\n        sitename = link.find(&quot;meta&quot;, property=&quot;og:site_name&quot;).get('content')\n    else:\n        sitename = url.split('//')[1]\n        name = sitename.split('/')[0]\n        name = sitename.rsplit('.')[1]\n        return name.capitalize()\n    return sitename\n\n\ndef scrape(request):\n    &quot;&quot;&quot;Scrape scheduled link previews.&quot;&quot;&quot;\n    if request.method == 'POST':\n        # Allows POST requests from any origin with the Content-Type\n        # header and caches preflight response for an 3600s\n        headers = {\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Methods': 'POST',\n            'Access-Control-Allow-Headers': 'Content-Type',\n            'Access-Control-Max-Age': '3600'\n        }\n        request_json = request.get_json()\n        target_url = request_json['url']\n        headers.update({\n            'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',\n        })\n        r = requests.get(target_url)\n        raw_html = r.content\n        soup = BeautifulSoup(raw_html, 'html.parser')\n        links = soup.select('.post-content p &gt; a')\n        previews = []\n        for link in links:\n            url = link.get('href')\n            r2 = requests.get(url, headers=headers)\n            link_html = r2.content\n            embedded_link = BeautifulSoup(link_html, 'html.parser')\n            preview_dict = {\n                'title': getTitle(embedded_link),\n                'description': getDescription(embedded_link),\n                'image': getImage(embedded_link),\n                'sitename': getSiteName(embedded_link, url),\n                'url': url\n                }\n            previews.append(preview_dict)\n        return make_response(str(previews), 200, headers)\n    return make_response('bruh pls', 400, headers)\n</code></pre>\n","url":"https://hackersandslackers.com/scraping-urls-with-beautifulsoup/","uuid":"c933218e-6bbf-44b7-8f01-bfd188c71d89","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5be7fc282ec6e0035b4b16bc"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736ee","title":"Structuring Your Flask Application","slug":"structuring-your-flask-app","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","excerpt":"Leverage Blueprints, Flask-Assets, and the Application Factory.","custom_excerpt":"Leverage Blueprints, Flask-Assets, and the Application Factory.","created_at_pretty":"02 September, 2018","published_at_pretty":"15 October, 2018","updated_at_pretty":"23 February, 2019","created_at":"2018-09-02T03:02:29.000-04:00","published_at":"2018-10-15T08:00:00.000-04:00","updated_at":"2019-02-23T11:21:49.000-05:00","meta_title":"Structuring your Flask Application | Hackers and Slackers","meta_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","og_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","og_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","og_title":"Structuring your Flask App Like an Adult | Hackers and Slackers","twitter_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","twitter_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","twitter_title":"Structuring your Flask App Like an Adult | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"When we first started developing in Flask, most of us took the 5 lines of code\nin the quick-start guide and ran with it. Compared to every other web framework,\ngetting a \"Hello world\" to flash on screen without being hassled with database\nconfigurations, template preferences, or reverse proxy setups felt a lot like\nrobbing a bank.\n\nAt some point or another, we inevitably pause the party and take a look around.\nAll of our views are smashed into a single file named something meaningless like\n app.py. All logic lives in the root directory. We're in our 30s and the app\nwe've just created looks as terrible as our bathrooms. It's time to get our shit\ntogether.\n\nThe Flask Application Factory\nThe overwhelming preference to start a Flask application is to use a structure\ndubbed the Application Factory\n[http://flask.pocoo.org/docs/1.0/patterns/appfactories/]. The gist is to keep\nthe initialization preferences of our application in a single __init__.py  file,\nsometimes borrowing help from peer files such as db.py  or models.py. Either\nway, the gist is to keep global logic separated from the other parts.\n\nA simple app using the application factory method might look something like\nthis:\n\n[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── views.py\n│   ├── static/\n│   └── templates/\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n\n\nThe main takeaway here being the presence of the myapp  directory which now\nhouses our app logic, and the presence of our good friend __init__.py.\n\nAn example of what might live in __init.py__  could be something like this:\n\nimport os\nimport sys\nfrom flask import Flask, g\nfrom config import BaseConfig\nfrom flask_login import LoginManager\nfrom flask_pymongo import PyMongo\n\n\ndef create_app():\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_object('config.BaseConfig')\n    login = LoginManager()\n\n    with app.app_context():\n        from . import views\n        from . import auth\n        login.init_app(app)\n        mongo = PyMongo(app, app.config['MONGO_URI'])\n        app.register_blueprint(views.main)\n        app.register_blueprint(admin.admin)\n\n        return app\n\n\nHere we initialize our app and the dependencies we'd like to initialize within a\nsingle function. Most familiar might be the first two lines of our function: The\nfirst creating our app object, and the second loading a config from a class in a\nconfig file.\n\nAnother common practice is to keep libraries which need to run init_app  in this\nfile as well. This could be something like the LoginManager  seen in the example\nabove, or a global database configuration. Lastly, this is also where we would\nregister any Blueprints  as well.\n\nUsing Blueprints in Flask\nWhile the Application Factory is an excellent first step to building cohesive\napps, we haven't solved the problem of organizing our app into separation of\nconcerns. Blueprints  are a way for us to separate our app into parts which\nshare very little with one another. Prime examples would include apps with an \nadmin  panel with an accompanying client-facing  side, or apps where the \"logged\nin\" state is vastly different from the app's \"logged out\"  state. In these\ncases, it seems silly to mix both logic and static assets into a single lump,\nwhich is where Blueprints come in.\n\nNOTE:  If you're a Django person and this is all starting to sound familiar,\nthat's because we can equate Flask's Blueprints  to Django's concept of apps. \nThere are differences and added flexibility, but the concept remains the same.\n\nRegistering a part of your app as a Blueprint begins with the following two\nlines:\n\nfrom flask import Blueprint\n\nauth = Blueprint('auth', __name__)\n\n\nWhen we registered the admin  Blueprint previously in __init__.py, the line \napp.register_blueprint(admin.admin)  is essentially saying \"look for a Blueprint \n named admin  in a module (either file or folder structure) called admin.\"  It's\nimportant not to overlook the concept that Blueprints can either be single files\nor entirely standalone file structures with their own templates and static\nfiles.  For instance, a Flask app with completely decoupled Blueprints might be\nstructured as follows:\n\n[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── admin/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/\n│   ├── frontend/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/  \n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   └── views.py\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n        \n\n\nIn the case above, each Blueprint  stands as though it were its own Python\nmodule. Each blueprint contains its own logic, templates, and static files -\npresumably encapsulated in a way which makes sense.\n\nUsing Flask-Assets with Blueprints\nWe've already forced a lot of information down your throat, but there's one last\nthing worth mentioning in this overview of working with Blueprints, which is\nworking with assets. We've previously looked at the Flask-Static-Compress \nlibrary for static asset management, but Blueprints  lend themselves better to \nFlask-Assets  way of thinking.\n\nFlask-Assets  is a library which creates a bundle (aka compressed) of assets\nupfront. Thus, the start of a Blueprint definition might now look something like\nthis:\n\nfrom flask import Blueprint\nfrom flask_assets import Environment, Bundle, build\nimport sass\n\nauth = Blueprint('admin', __name__)\n\nassets = Environment(admin)\nscss = Bundle('scss/main.scss', 'scss/forms.scss', filters='libsass', output='build/css/style.css')\nassets.register('scss_all', scss)\nscss.build()\n\n\nEnvironment  states the context of our asset bundle, which is admin, the current\nBlueprint. \n\nBundle  takes any number of files to compressed together as arguments. Then we\nmust pass the type of \"filter\" the assets are (typically a precompiler) and of\ncourse an output destination for the Bundle.\n\n.register()  registers the bundle we just created, not unlike the way we\nregistered our Blueprint.\n\n.build()  must be called explicitly in order to build the bundle at runtime.\nConversely, we could intentionally exclude .build()  if we expect our assets are\nnot to change.\n\nAnd Now You Know Everything\n...or not, really. The most we should take from this post is:\n\n * There's a better way to structure our apps.\n * There are many potential decisions we can make about the structure of our\n   app.\n * There's way more stuff we need to Google or look up on StackOverflow.\n\nTruthfully, there are plenty of resources within Flask's documentation\n[http://flask.pocoo.org/docs/1.0/tutorial/views/#]  or around the internet that\ncovers the topic of Flask app organization and its granular topics more than\nthis single post could ever hope to. Nonetheless, here's to hoping you're\nfeeling a sense of direction in these crazy, adult lives of ours.","html":"<p>When we first started developing in Flask, most of us took the 5 lines of code in the quick-start guide and ran with it. Compared to every other web framework, getting a \"Hello world\" to flash on screen without being hassled with database configurations, template preferences, or reverse proxy setups felt a lot like robbing a bank.</p><p>At some point or another, we inevitably pause the party and take a look around. All of our views are smashed into a single file named something meaningless like <code>app.py</code>. All logic lives in the root directory. We're in our 30s and the app we've just created looks as terrible as our bathrooms. It's time to get our shit together.</p><h2 id=\"the-flask-application-factory\">The Flask Application Factory</h2><p>The overwhelming preference to start a Flask application is to use a structure dubbed the <a href=\"http://flask.pocoo.org/docs/1.0/patterns/appfactories/\">Application Factory</a>. The gist is to keep the initialization preferences of our application in a single <code>__init__.py</code> file, sometimes borrowing help from peer files such as <code>db.py</code> or <code>models.py</code>. Either way, the gist is to keep global logic separated from the other parts.</p><p>A simple app using the application factory method might look something like this:</p><pre><code class=\"language-shell\">[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── views.py\n│   ├── static/\n│   └── templates/\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n</code></pre>\n<p>The main takeaway here being the presence of the <strong>myapp</strong> directory which now houses our app logic, and the presence of our good friend <code>__init__.py</code>.</p><p>An example of what might live in <code>__init.py__</code> could be something like this:</p><pre><code class=\"language-python\">import os\nimport sys\nfrom flask import Flask, g\nfrom config import BaseConfig\nfrom flask_login import LoginManager\nfrom flask_pymongo import PyMongo\n\n\ndef create_app():\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_object('config.BaseConfig')\n    login = LoginManager()\n\n    with app.app_context():\n        from . import views\n        from . import auth\n        login.init_app(app)\n        mongo = PyMongo(app, app.config['MONGO_URI'])\n        app.register_blueprint(views.main)\n        app.register_blueprint(admin.admin)\n\n        return app\n</code></pre>\n<p>Here we initialize our app and the dependencies we'd like to initialize within a single function. Most familiar might be the first two lines of our function: The first creating our app object, and the second loading a config from a class in a config file.</p><p>Another common practice is to keep libraries which need to run <code>init_app</code> in this file as well. This could be something like the <code>LoginManager</code> seen in the example above, or a global database configuration. Lastly, this is also where we would register any <strong>Blueprints</strong> as well.</p><h2 id=\"using-blueprints-in-flask\">Using Blueprints in Flask</h2><p>While the Application Factory is an excellent first step to building cohesive apps, we haven't solved the problem of organizing our app into <em>separation of concerns</em>. <strong>Blueprints</strong> are a way for us to separate our app into parts which share very little with one another. Prime examples would include apps with an <em>admin</em> panel with an accompanying <em>client-facing</em> side, or apps where the \"<em>logged in\" </em>state is vastly different from the app's \"<em>logged out\"</em> state. In these cases, it seems silly to mix both logic and static assets into a single lump, which is where Blueprints come in.</p><p><strong>NOTE:</strong> If you're a Django person and this is all starting to sound familiar, that's because we can equate Flask's <strong>Blueprints</strong> to Django's concept of <strong>apps.</strong> There are differences and added flexibility, but the concept remains the same.</p><p>Registering a part of your app as a Blueprint begins with the following two lines:</p><pre><code class=\"language-python\">from flask import Blueprint\n\nauth = Blueprint('auth', __name__)\n</code></pre>\n<p>When we registered the <code>admin</code> Blueprint previously in <code>__init__.py</code>, the line <code>app.register_blueprint(admin.admin)</code> is essentially saying \"look for a <strong>Blueprint</strong> named <em>admin</em> in a module (either file or folder structure) called <em>admin.\"</em> It's important not to overlook the concept that Blueprints can either be single files or <em>entirely standalone file structures with their own templates and static files.</em> For instance, a Flask app with completely decoupled Blueprints might be structured as follows:</p><pre><code class=\"language-shell\">[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── admin/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/\n│   ├── frontend/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/  \n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   └── views.py\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n        \n</code></pre>\n<p>In the case above, each <strong>Blueprint</strong> stands as though it were its own Python module. Each blueprint contains its own logic, templates, and static files - presumably encapsulated in a way which makes sense.</p><h2 id=\"using-flask-assets-with-blueprints\">Using Flask-Assets with Blueprints</h2><p>We've already forced a lot of information down your throat, but there's one last thing worth mentioning in this overview of working with <strong>Blueprints, </strong>which is working with assets. We've previously looked at the <code>Flask-Static-Compress</code> library for static asset management, but <strong>Blueprints</strong> lend themselves better to <code>Flask-Assets</code> way of thinking.</p><p><code>Flask-Assets</code> is a library which creates a bundle (aka compressed) of assets upfront. Thus, the start of a Blueprint definition might now look something like this:</p><pre><code class=\"language-shell\">from flask import Blueprint\nfrom flask_assets import Environment, Bundle, build\nimport sass\n\nauth = Blueprint('admin', __name__)\n\nassets = Environment(admin)\nscss = Bundle('scss/main.scss', 'scss/forms.scss', filters='libsass', output='build/css/style.css')\nassets.register('scss_all', scss)\nscss.build()\n</code></pre>\n<p><code>Environment</code> states the context of our asset bundle, which is admin, the current Blueprint. </p><p><code>Bundle</code> takes any number of files to compressed together as arguments. Then we must pass the type of \"filter\" the assets are (typically a precompiler) and of course an output destination for the Bundle.</p><p><code>.register()</code> registers the bundle we just created, not unlike the way we registered our Blueprint.</p><p><code>.build()</code> must be called explicitly in order to build the bundle at runtime. Conversely, we could intentionally exclude <code>.build()</code> if we expect our assets are not to change.</p><h2 id=\"and-now-you-know-everything\">And Now You Know Everything</h2><p>...or not, really. The most we should take from this post is:</p><ul><li>There's a better way to structure our apps.</li><li>There are many potential decisions we can make about the structure of our app.</li><li>There's way more stuff we need to Google or look up on StackOverflow.</li></ul><p>Truthfully, there are plenty of resources within <a href=\"http://flask.pocoo.org/docs/1.0/tutorial/views/#\">Flask's documentation</a> or around the internet that covers the topic of Flask app organization and its granular topics more than this single post could ever hope to. Nonetheless, here's to hoping you're feeling a sense of direction in these crazy, adult lives of ours.</p>","url":"https://hackersandslackers.com/structuring-your-flask-app/","uuid":"4345eb76-e1ce-471a-94b9-f06a43c3ad27","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b8b8b05852e5c07171fcab7"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673701","title":"Flask Routing & Sessions: A Subtle Symphony","slug":"the-art-of-building-flask-routes","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","excerpt":"With great flexibility comes great responsibility .","custom_excerpt":"With great flexibility comes great responsibility .","created_at_pretty":"17 September, 2018","published_at_pretty":"19 September, 2018","updated_at_pretty":"17 November, 2018","created_at":"2018-09-17T05:05:03.000-04:00","published_at":"2018-09-19T08:58:00.000-04:00","updated_at":"2018-11-16T20:57:42.000-05:00","meta_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","meta_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","og_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","og_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","og_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","twitter_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","twitter_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","twitter_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"It isn't often you find somebody sad or miserable enough to detail the inner\nworkings of web framework features, such as sessions or routing. This is\nunderstandably so; we use frameworks because presumably hate dealing with these\nthings from scratch. This is especially so when it comes to Flask, which only\nreleased version 1.0 a few months ago, introducing breaking changes rendering\nprevious documentation more-or-less worthless. \n\nGoogling some of Flask's critical features mostly returns one-liners from the\napp's authors (half of which are useless, as they are for older versions of\nFlask). Stack Overflow threads mostly sit in silence, and even Kite\n[https://kite.com/], AKA \"The smart copilot for programmers\" returns blank pages\nof documentation, akin to the blank stare of a clueless Golden Retriever.\n\nIn retrospect, it was probably a poor choice for me to pick up 4 separate\nFlask-based projects during this time.\n\nWe're in a historic place in time where a team of developers put together\nsomething beautiful, yet somehow feels undersold. It seems as though the niche\nmarket of \"those who can't do, teach\" remains untapped for Flask, as the usual\nsuspects have yet to \"do\". This leaves newcomers like myself to hack away for\ntheir own survival in the meantime. I've only just turned that mental corner\nwhere Flask's quirks are as comforting as home-cooked meal, as opposed to\nfrustrating single-word methods containing 6 words of documentation on average.\n\nThe good news is I am still technically alive, after spending weeks building\nFlask applications mostly through trial and error. The bad news is that I've\nbecome Mr. Robot  in the process. That said, if there will ever be an ideal\nmoment in my life to write about Flask, now is the time. As reality slowly slips\naway in 1s and 0s, I may as well pass along  what I've learned.\n\nBroad Strokes\nIt only takes a couple minutes into explaining what Flask is when you realize\nthat Flask, at its core, is overwhelmingly just the “V” in “MVC”. Jinja handles\nthe templates, and something like SQLAlchemy will likely handle your models.\nFlask has an abundance of third-party libraries to handle business logic, but it\nis the core Flask package that we all agreed to gather around. This speaks\nvolumes about the quality of Flask’s simple yet powerful request handling.\n\nI'll  break down as many of Flask's out-of-the-box features, focusing on what\nmatters most (in my opinion). Take a look at some of the Flask libraries we'll\nbe playing around with:\n\n# app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport os\n\nConfiguring Our App\nAs always, we create our app with app = Flask(name). Equally uninteresting is\nour configuration setup, which we'll import via a class in config.py:\n\n# app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport config\nimport os\n\n# Our app\napp = Flask(__name__)\n\n# Load our config variables\napp.config.from_object('config.ProductionConfig')\n\nA number of things in our config are absolutely essential for sessions to work.\nBelow is an example config file:\n\n# config.py\nimport os\n\nclass ProductionConfig():\n    \"\"\"Set app config vars.\"\"\"\n    SECRET_KEY = os.urandom(24)\n    SESSION_TYPE = null\n    SESSION_COOKIE_NAME = 'session name'\n    SESSION_PERMANENT = True\n    PERMANENT_SESSION_LIFETIME = timedelta(days=31) (2678400 seconds)\n\nSECRET_KEY  is critical: this variable needs to exist in out config for sessions\nto function properly. The best way to handle is is by generating a key as seen\nabove.\n\nSESSION_TYPE  allows us to specify where our session data should be stored. This\nis set null by default, but Flask supports a number of options:\n\n * RedisSessionInterface:  Uses the Redis key-value store as a session backend. \n * MemcachedSessionInterface:  Uses the Memcached as a session backend. \n * FileSystemSessionInterface:  werkzeug.contrib.cache.FileSystemCache  as a\n   session backend.\n * MongoDBSessionInterface:  Uses MongoDB as a backend \n   [http://api.mongodb.org/python/current/index.html]via pymongo\n * SqlAlchemySessionInterface:  Uses SQLAlchemy, or rather Flask-SQLAlchemy\n   [https://pythonhosted.org/Flask-SQLAlchemy/]\n\nThere are plenty more variables you can set if you want to take a look here\n[http://flask.pocoo.org/docs/1.0/config/].\n\nSessions and Contexts\nUnlike cookie-based sessions, Flask sessions are handled and stored on the\nserver-side. A session object is simply a dict which is accessible throughout\nthe application a global level, referring to a single 'logged-in user'. As long\nas the session is active, any context of our app will be able to retrieve,\nmodify, or delete the values held in this session object,\n\n# Save a value to the user's session.\nsession['username'] = 'MyUsername' \n\n# IMPORTANT: \"True\" forces our changes to be recognized.\nsession.modified = True: \n\n# Retrieve session values at any time, anywhere \nsession.get('username') = True\n\nSeeing as how sessions are accessible globally, it is also important to note\nthat sessions can last a very long time; pretty much self explanatory given the \nSESSION_PERMANENT = True  configuration option.  It's a good idea to set a\nsession timeout period, or better yet, close them by the user's own request.\nClearing a session is as simple as resetting the session dictionary values back\nto None  by using the pop  method: session.pop('value', None).\n\nThe Application Context\nBesides undying global sessions,  Flask also provides us with a feature with an\nobject more suitable for storing and passing temporary values between app\ncontexts. This object known simply as g. While  technically an abbreviation for\n\"global\",g  is really just a convenient place to store temporarily store values\nwhich you can always depend on to be by your side.\n\n# app.py\nfrom Flask import g\n\nIt's important to note that values assigned to g  only exist within the context\nthey were created by default. For example, if we store information to the object\ndue to some user interaction on the dashboard, these values are lost once the\nuser moves to another part of our app. That said, values assigned to g  can\ntechnically be passed between contexts if we return g.value. This distinction\nbetween always-alive sessions  and every dying g  should be indicative of what\nreach respective object does.  Spoiler alert: sensitive (or contextually\nuseless) data should be stored temporarily with g, where values which will\ncontinuously be useful in determining the functionality of our should should\nreside in session.\n\nInterestingly enough, Flask has a decorator  specifically for terminating values\nsaved to g  in the case we'd want to ensure the swift and total annihilation of\nsuch data. For instance, if we were to assign a database connection to g  using\ng.db = connect_to_database(), we'd want to make sure that connection is closed\nas fast as possible before we forget:\n\n# app.py\ndef db_stuff():\n    g.db = database_connection()\n    g.db.somequeryorwhatever\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db():\n    db = g.pop('db', None)\n\nRoutes & Decorators\nWe're surely familiar with the concepts behind routing users to deserved views\nby now. Before we look at the juicy stuff, consider this boring route for a\nboring product, where the homepage is a dashboard:\n\n# app.py\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef dashboard():\n    \"\"\"Boring route.\"\"\"\n    return render_template('/dashboard.html')\n\nOh snap, our landing page is a /dashboard?  How will we know which user's\ndashboard to display when they visit the dashboard, or any other page for that\nmatter? If only there were a way to intercept every request a user makes to our\napp?\n\nFlask comes with a bunch of insanely useful decorators. Python decorators are\nfunctions which either 'wrap'  other functions in additional logic, or in our\ncase, intercept functions to do with them what we what. Flask has a vast\nplethora of logic decorators, ranging from detecting first-time visitors,\nhandling exceptions, executing logic before/after page loads, etc. Even the\nroute we set above is a decorator!\n\n@flask.before_request\nAdding before_request  to our app allows us to run logic prior to the\naforementioned request. With this power, we can do things like treat users\ndifferently (such as recognized or anonymous users), or just execute some sort\nof unique logic upon page load. \n\nIn this simple case, we check to see if a visitor has an active session every\ntime they hit a route. This way, if a user's session expired between before\nhitting a route in our app, we can prompt them to log in... or whatever. \n\nbefore_request doesn't accept any value parameters - the handler is mostly\nintended to perform tasks such as making a database query necessary for our app\nto run, or make sure users are still logged in.\n\n# app.py\n@app.before_request\ndef before_request():\n    \"\"\"Handle multiple users.\"\"\"\n    if 'username' in session:\n        return render_template('/dashboard.html')\n    else:\n        return render_template('/login.html')\n\n@flask.url_value_preprocessor\nUnlike before_request, url_value_preprocessor  does  accept incoming data. This\nallows us to handle data being posted to any part of our app before we even\nbother serving up views. Not only does this provide a convenient separation of\nconcerns, but also helps us avoid callback hell, which yes, can happen in Python\ntoo.\n\nLet's say we're accepting a POST request, where we create a view for our user's\npersonal details. When the user passes us their email address, we decide to\nretrieve the user's records by hitting an API, and passing the results to the\nview.\n\nWithout modularizing our code, we'd have to handle things like waiting on API\ncalls in the same functions as  our routes. Not only is this shitty repetitive\ncode, but running numerous API calls and rendering a view all at once is going\nto eventually break. Go ahead and ask the NodeJS guys. They'll know.\n\n# app.py\n@app.url_value_preprocessor\ndef url_value_preprocessor(endpoint, values):\n    \"\"\"Handle data sent to any route.\"\"\"\n       if request.args:\n           email = request.args.get('email')\n           r = requests.post(endpoint, headers=headers, data=email)\n           session['usermetadata'] = r\n           session.modified = True\n           return session\n\nYou're Only Getting Started\nWe've only covered small percentage of convenient tools Flask offers us. Go\nahead and see how many decorators [http://flask.pocoo.org/docs/1.0/api/]   you\ncan fuck with. Yeah dude, shit is legit - and we haven't even talked about the\nFlask-Login package yet.\n\nThe beauty of lightweight frameworks is that they focus on the problems that\ndrive us to web frameworks in the first place. Flask is clearly designed to\nhandle serving views, standing up APIs, and handling user management\neffectively. Contrast this with frameworks like Django, which forces rigid app\nsetup in what can commonly be an  hour-long setup or greater. I'll truthfully\nalways have a place in my heart for Django as the fathers of Python MVC: I would\ncan say with confidence that without the creation of Django (as well as the\nofficial $10 dollar intro book from Barnes and Noble) I never would have\ntransitioned from an obnoxious product manager  personality to the kind of guy\nwho owns multiple Python t-shirts. Hmm. Now that I think about it, maybe I\nshould've stayed an office tool as opposed to solving all these complex\nproblems. oh well.\n\nFlask is indicative of a new direction of framework design - or rather lack\nthereof. Programmers who know what they're doing  can express themselves outside\nof traditional boundaries set by other frameworks, surely designed to keep\nidiots from ruining everything. There's nothing wrong with being a worker drone\nrepeating the same worthless projects,  using same libraries, and essentially\ncontributing nothing to humanity. I'd personally prefer to take the freedom and\nspeed of Flask any day.","html":"<p>It isn't often you find somebody sad or miserable enough to detail the inner workings of web framework features, such as sessions or routing. This is understandably so; we use frameworks because presumably hate dealing with these things from scratch. This is especially so when it comes to Flask, which only released version 1.0 a few months ago, introducing breaking changes rendering previous documentation more-or-less worthless. </p><p>Googling some of Flask's critical features mostly returns one-liners from the app's authors (half of which are useless, as they are for older versions of Flask). Stack Overflow threads mostly sit in silence, and even <a href=\"https://kite.com/\">Kite</a>, AKA <em>\"The smart copilot for programmers\" </em>returns blank pages of documentation, akin to the blank stare of a clueless Golden Retriever.</p><p><strong><em>In retrospect, it was probably a poor choice for me to pick up 4 separate Flask-based projects during this time.</em></strong></p><p>We're in a historic place in time where a team of developers put together something beautiful, yet somehow feels undersold. It seems as though the niche market of \"those who can't do, teach\" remains untapped for Flask, as the usual suspects have yet to \"do\". This leaves newcomers like myself to hack away for their own survival in the meantime. I've only just turned that mental corner where Flask's quirks are as comforting as home-cooked meal, as opposed to frustrating single-word methods containing 6 words of documentation on average.</p><p>The good news is I am still technically alive, after spending weeks building Flask applications mostly through trial and error. The bad news is that I've become <em>Mr. Robot</em> in the process. That said, if there will ever be an ideal moment in my life to write about Flask, now is the time. As reality slowly slips away in 1s and 0s, I may as well pass along  what I've learned.</p><h2 id=\"broad-strokes\">Broad Strokes</h2><p>It only takes a couple minutes into explaining what Flask is when you realize that Flask, at its core, is overwhelmingly just the “V” in “MVC”. Jinja handles the templates, and something like SQLAlchemy will likely handle your models. Flask has an abundance of third-party libraries to handle business logic, but it is the core Flask package that we all agreed to gather around. This speaks volumes about the quality of Flask’s simple yet powerful request handling.</p><p>I'll  break down as many of Flask's out-of-the-box features, focusing on what matters most (in my opinion). Take a look at some of the Flask libraries we'll be playing around with:</p><pre><code># app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport os</code></pre><h2 id=\"configuring-our-app\">Configuring Our App</h2><p>As always, we create our app with <code>app = Flask(name)</code><em>. </em>Equally uninteresting is our configuration setup, which we'll import via a class in <code>config.py</code>:</p><pre><code># app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport config\nimport os\n\n# Our app\napp = Flask(__name__)\n\n# Load our config variables\napp.config.from_object('config.ProductionConfig')</code></pre><p>A number of things in our config are absolutely essential for sessions to work. Below is an example config file:</p><pre><code># config.py\nimport os\n\nclass ProductionConfig():\n    \"\"\"Set app config vars.\"\"\"\n    SECRET_KEY = os.urandom(24)\n    SESSION_TYPE = null\n    SESSION_COOKIE_NAME = 'session name'\n    SESSION_PERMANENT = True\n    PERMANENT_SESSION_LIFETIME = timedelta(days=31) (2678400 seconds)</code></pre><p><strong>SECRET_KEY</strong> is critical: this variable needs to exist in out config for sessions to function properly. The best way to handle is is by generating a key as seen above.</p><p><strong>SESSION_TYPE</strong> allows us to specify where our session data should be stored. This is set null by default, but Flask supports a number of options:</p><ul><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.RedisSessionInterface\">RedisSessionInterface</a>:<strong> </strong>Uses the Redis key-value store as a session backend. </li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.MemcachedSessionInterface\">MemcachedSessionInterface</a>:<strong> </strong>Uses the Memcached as a session backend. </li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.FileSystemSessionInterface\">FileSystemSessionInterface</a>:<strong> </strong><code>werkzeug.contrib.cache.FileSystemCache</code> as a session backend.</li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.MongoDBSessionInterface\">MongoDBSessionInterface</a>:<strong> </strong>Uses MongoDB as a backend<a href=\"http://api.mongodb.org/python/current/index.html\"> </a>via <code>pymongo</code></li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.SqlAlchemySessionInterface\">SqlAlchemySessionInterface</a>:<strong> </strong>Uses SQLAlchemy, or rather <a href=\"https://pythonhosted.org/Flask-SQLAlchemy/\">Flask-SQLAlchemy</a></li></ul><p>There are plenty more variables you can set if you want to take a look <a href=\"http://flask.pocoo.org/docs/1.0/config/\">here</a>.</p><h2 id=\"sessions-and-contexts\">Sessions and Contexts</h2><p>Unlike cookie-based sessions, Flask sessions are handled and stored on the server-side. A session object is simply a dict which is accessible throughout the application a global level, referring to a single 'logged-in user'. As long as the session is active, any context of our app will be able to retrieve, modify, or delete the values held in this session object,</p><pre><code># Save a value to the user's session.\nsession['username'] = 'MyUsername' \n\n# IMPORTANT: \"True\" forces our changes to be recognized.\nsession.modified = True: \n\n# Retrieve session values at any time, anywhere \nsession.get('username') = True</code></pre><p>Seeing as how sessions are accessible globally, it is also important to note that sessions can last a very long time; pretty much self explanatory given the <code>SESSION_PERMANENT = True</code> configuration option.  It's a good idea to set a session timeout period, or better yet, close them by the user's own request. Clearing a session is as simple as resetting the session dictionary values back to <em>None</em> by using the <strong>pop</strong> method: <code>session.pop('value', None)</code>.</p><h3 id=\"the-application-context\">The Application Context</h3><p>Besides undying global sessions,  Flask also provides us with a feature with an object more suitable for storing and passing temporary values between app contexts. This object known simply as <code>g</code>. While<strong> </strong>technically an abbreviation for \"global\",  <code>g</code> is really just a convenient place to store temporarily store values which you can always depend on to be by your side.</p><pre><code># app.py\nfrom Flask import g</code></pre><p>It's important to note that values assigned to <code>g</code> <em>only exist within the context they were created </em>by default. For example, if we store information to the object due to some user interaction on the dashboard, these values are lost once the user moves to another part of our app. That said, values assigned to <code>g</code> can technically be passed between contexts if we <code>return g.value</code>. This distinction between always-alive <em>sessions</em> and every dying <em>g</em> should be indicative of what reach respective object does.  Spoiler alert: sensitive (or contextually useless) data should be stored temporarily with <code>g</code>, where values which will continuously be useful in determining the functionality of our should should reside in <code>session</code><em>.</em></p><p>Interestingly enough, Flask has a <em>decorator</em> specifically for terminating values saved to <code>g</code> in the case we'd want to ensure the swift and total annihilation of such data. For instance, if we were to assign a database connection to <code>g</code> using  <code>g.db = connect_to_database()</code>, we'd want to make sure that connection is closed as fast as possible before we forget:</p><pre><code># app.py\ndef db_stuff():\n    g.db = database_connection()\n    g.db.somequeryorwhatever\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db():\n    db = g.pop('db', None)</code></pre><h2 id=\"routes-decorators\">Routes &amp; Decorators</h2><p>We're surely familiar with the concepts behind routing users to deserved views by now. Before we look at the juicy stuff, consider this boring route for a boring product, where the homepage is a dashboard:</p><pre><code># app.py\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef dashboard():\n    \"\"\"Boring route.\"\"\"\n    return render_template('/dashboard.html')</code></pre><p>Oh snap, our landing page is a /<em>dashboard?</em> How will we know which user's dashboard to display when they visit the dashboard, or any other page for that matter? If only there were a way to intercept every request a user makes to our app?</p><p>Flask comes with a bunch of insanely useful <strong><em>decorators</em></strong>. Python decorators are functions which either 'wrap'  other functions in additional logic, or in our case, intercept functions to do with them what we what. Flask has a vast plethora of logic decorators, ranging from detecting first-time visitors, handling exceptions, executing logic before/after page loads, etc. Even the route we set above is a decorator!</p><h3 id=\"-flask-before_request\">@flask.before_request</h3><p>Adding <strong>before_request</strong> to our app allows us to run logic prior to the aforementioned request. With this power, we can do things like treat users differently (such as recognized or anonymous users), or just execute some sort of unique logic upon page load. </p><p>In this simple case, we check to see if a visitor has an active session every time they hit a route. This way, if a user's session expired between before hitting a route in our app, we can prompt them to log in... or whatever. </p><p><strong>before_request </strong>doesn't accept any value parameters - the handler is mostly intended to perform tasks such as making a database query necessary for our app to run, or make sure users are still logged in.</p><pre><code># app.py\n@app.before_request\ndef before_request():\n    \"\"\"Handle multiple users.\"\"\"\n    if 'username' in session:\n        return render_template('/dashboard.html')\n    else:\n        return render_template('/login.html')</code></pre><h3 id=\"-flask-url_value_preprocessor\">@flask.url_value_preprocessor</h3><p>Unlike <em>before_request</em><strong>, url_value_preprocessor</strong> <em>does</em> accept incoming data. This allows us to handle data being posted to any part of our app before we even bother serving up views. Not only does this provide a convenient separation of concerns, but also helps us avoid <em>callback hell, </em>which yes, can happen in Python too.</p><p>Let's say we're accepting a POST request, where we create a view for our user's personal details. When the user passes us their email address, we decide to retrieve the user's records by hitting an API, and passing the results to the view.</p><p>Without modularizing our code, we'd have to handle things like waiting on API calls in the same functions as  our routes. Not only is this shitty repetitive code, but running numerous API calls and rendering a view all at once is going to eventually break. Go ahead and ask the NodeJS guys. They'll know.</p><pre><code># app.py\n@app.url_value_preprocessor\ndef url_value_preprocessor(endpoint, values):\n    \"\"\"Handle data sent to any route.\"\"\"\n       if request.args:\n           email = request.args.get('email')\n           r = requests.post(endpoint, headers=headers, data=email)\n           session['usermetadata'] = r\n           session.modified = True\n           return session</code></pre><h2 id=\"you-re-only-getting-started\">You're Only Getting Started</h2><p>We've only covered small percentage of convenient tools Flask offers us. Go ahead and see <a href=\"http://flask.pocoo.org/docs/1.0/api/\">how many decorators</a>  you can fuck with. Yeah dude, shit is legit - and we haven't even talked about the Flask-Login package yet.</p><p>The beauty of lightweight frameworks is that they focus on the problems that drive us to web frameworks in the first place. Flask is clearly designed to handle serving views, standing up APIs, and handling user management effectively. Contrast this with frameworks like <strong>Django</strong>, which forces rigid app setup in what can commonly be an  hour-long setup or greater. I'll truthfully always have a place in my heart for Django as the fathers of Python MVC: I would can say with confidence that without the creation of Django (as well as the official $10 dollar intro book from Barnes and Noble) I never would have transitioned from an obnoxious product manager  personality to the kind of guy who owns multiple Python t-shirts. Hmm. Now that I think about it, maybe I should've stayed an office tool as opposed to solving all these complex problems. oh well.</p><p>Flask is indicative of a new direction of framework design - or rather lack thereof. Programmers who <em>know what they're doing</em> can express themselves outside of traditional boundaries set by other frameworks, surely designed to keep idiots from ruining everything. There's nothing wrong with being a worker drone repeating the same worthless projects,  using same libraries, and essentially contributing nothing to humanity. I'd personally prefer to take the freedom and speed of Flask any day.</p><p></p>","url":"https://hackersandslackers.com/the-art-of-building-flask-routes/","uuid":"67a6407a-5804-4bd0-812d-219561e2488a","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b9f6e3ff79bcf0717187d8b"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736d2","title":"Recreate JIRA Service Desk in Python & Flask","slug":"building-a-better-jira","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","excerpt":"When SaaS doesn't cut it, beat it down and take everything its got.","custom_excerpt":"When SaaS doesn't cut it, beat it down and take everything its got.","created_at_pretty":"11 August, 2018","published_at_pretty":"31 August, 2018","updated_at_pretty":"02 February, 2019","created_at":"2018-08-11T14:02:52.000-04:00","published_at":"2018-08-31T10:25:00.000-04:00","updated_at":"2019-02-02T05:11:05.000-05:00","meta_title":"When SaaS doesn't cut it, beat it down and take everything its got | Hackers And Slackers","meta_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","og_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","og_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","og_title":"Recreate JIRA Service Desk in Python & Flask","twitter_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","twitter_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","twitter_title":"Recreate JIRA Service Desk in Python & Flask","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"}],"plaintext":"When it comes to SaaS products in the realm of Service desks, JIRA Service Desk\nis at the very least, just as powerful as the next solution (Zendesk comes to\nmind). This naturally begs the question: Why is JIRA Service Desk's pricing\nmodel roughly 1/10th of that of it's competitor?\n\nThe answer lies within ease of use,  but more importantly, presentation. While\nAtlassian's cloud offering is slowly playing catchup, Atlassian as a company has\nnever quite seemed to nail down the importance of a friendly user interface, nor\nthe importance of this when it comes to worldwide adoption. To see what I mean,\nhere's an example that Atlassian themselves tout on their own documentation as a\n\"ready for production\" customer portal:\n\nI'm convinced this is purposefully hideous to force the purchase of plugins.To\nyour average software developer (Atlassian's core demographic for years), one\nmight see nothing wrong with this interface, but as somebody `who has rolled out\nover 30 of these desks for over 6 thousand people, layouts such as these commit\nnumerous UI atrocities which simply are not acceptable for top enterprise\nsoftware.\n\nWhat do we do about this? We build an alternative, of course.\n\nMethod to This Madness\nOur focus is not on JIRA as a product,  but rather an API. Instead of attempting\nto work within JIRA’s boundaries via customization or add-ons, we can take\nmatters into our own hands by owning the application that users use to interact\nwith a JIRA instance. By using the JIRA API, we can not only extend features but\nactually ‘rebuild’ the application to gain full control over the UI or\nadditional logic. JIRA is a hideous yet entirely necessary Java application,\nwhich makes it a perfect candidate for recreation.\n\nWe're going to use Flask for this. Shocking, I know. Here's the obligatory file\nstructure of our project:\n\nmyproject\n├─ app.py\n├─ jira.py\n├─ /static\n│  └─ js\n│  └─ less\n│  └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n\n\nThis tutorial will be working against the JIRA Server  API for Service Desk -\nthat said, Cloud users should still find this applicable.\n\nPulling Your Service Desk Form\nBefore we get nuts building our application, we’ll need to be sure that a\nService Desk already exists in JIRA with our expected intake form. Remember: our\nend goal is to simply consume JIRA as an API, but that entails interacting with\nsomething that exists in the first place.\n\nWith your Service Desk created, there’s one annoyance we need to resolve before\ngetting into code: determining your Service Desk’s ID number. Like most things\nin JIRA, Service Desks are identified by an ID which is simply an arbitrary\ngrouping of integers in some way. What is the official way to find this ID, you\nmight ask? Why, by extracting it from the portal’s URL or by inspecting your XHR\nrequests, of course! Remember: JIRA hates you, that’s why we’re doing this in\nthe first place.\n\nWith your Service Desk ID handy, we can finally break into retrieving our desk\nvia the Service Desk API:\n\nimport requests\nfrom jira_config import jira_username, jira_password\n\nrequest_types_endpoint = \"https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/\"\n\nheaders = {'Content-Type': 'application/json'}\n\ndef fieldsPerRequest(id):\n    \"\"\"Get form fields per request type.\"\"\"\n    r = requests.get(request_types_endpoint + id + '/field', auth=(jira_username, jira_password), headers=headers)\n    form = r.json()\n    return form\n\n\ndef serviceDeskRequestTypes():\n    \"\"\"Get request types.\"\"\"\n    request_array = []\n    r = requests.get(request_types_endpoint, auth=(jira_username, jira_password), headers=headers)\n    for requesttype in r.json()['values']:\n        id = requesttype['id']\n        request_dict = {\n            'name': requesttype['name'],\n            'description': requesttype['description'],\n            'icon': requesttype['icon']['_links']['iconUrls']['32x32'],\n            'fields': fieldsPerRequest(id)\n        }\n        request_array.append(request_dict)\n    return request_array\n\n\nserviceDeskRequestTypes()\nBy using the request_types_endpoint  URL, our function serviceDeskRequestTypes() \n returns the request types  of a given JIRA service desk; or in other words, the\n types of requests users can submit.  This alone only gives us high-level\ninformation about the types of requests we allow but doesn't go into further\ndetail such as the actual resulting form. That's where our next function comes\nin.\n\nfieldsPerRequest()\nThis function gets passed the ID of each request type. With that, we extend our\nendpoint to look like \n'https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/[REQUESTID]/field'\n. Looping through each request type gives up exactly what we need: every request\ntype and every form field per request type.\n\nuserSession()\nThere's another thing left to consider: what if the user isn't currently logged\nin to JIRA? At the very least, we need to check to see if a JIRA session is\nactive:\n\nuser_session_endpoint = 'https://jira.we.co/rest/auth/1/session'\n\ndef getUserSession():\n    \"\"\"Get logged-in user.\"\"\"\n    r = requests.get(user_session_endpoint, headers=headers)\n    if r.status_code == 200:\n        return r.json()\n    else:\n        return False\n\n\nIf the user is logged in to JIRA, we'll receive a 200 code letting us know\neverything is alright. The body of the response will also contain the name of\nthe user plus some extra metadata. What if the user isn't  logged in? Let's get\nto that in a bit.\n\nEasy Routing\nOur view will be nice and simple:\n\nfrom jira import request_forms, user_details\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    if user_details == False:\n        return redirect('https://example.com')\n    else:\n        return render_template('/index.html', requests=request_forms)\n\n\nNotice that all we're doing is making sure the user is signed in to JIRA. But\nwhat's with the example.com, you ask? Well, because I'm leaving this part up to\nyou, dear friend. There's really a number of things we can do, but it depends\nentirely on your situation. For instance:\n\n * You can handle basic auth on your own\n * Register an OAuth application to handle sign-ins (perhaps the most robust\n   solution)\n * If your JIRA instance is behind SSO, you may want to send users to your\n   company's  SAML partner\n * Simply throw an error message\n\nWhatever you decide to do, it's not really my problem. Obligatory smiley face\nemoji :).\n\nThe Template\nRemember: the main reason most of you are probably doing this is to control the\npresentation layer as you see fit. That said, here comes a call of presentation\nlayer text, in the form of a Jinja template:\n\n{% block form %}\n  <div>\n    <h3 class=\"subtitle\">Submit new requests here</h3>\n    <ul class=\"collapsible\">\n      {% for request in requests %}\n      <li class=\"{{request.name}}\">\n        <div class=\"collapsible-header\">\n          <img src=\"{{request.icon}}\">\n          <div class=\"info\">\n            <h5>{{request.name}}</h5>\n            <p>{{request.description}}</p>\n          </div>\n        </div>\n        <div class=\"collapsible-body\">\n          <div class=\"row\">\n            <form method=\"post\">\n              <div>\n                {% for field in request.fields.requestTypeFields %}\n                  {% if field.name in ('Category', 'Product') %}\n                    <div class=\"input-field\">\n                      <select id=\"{{request.name}} {{field.name}}\">\n                        <option value=\"Choose your option\" disabled selected>Choose your option</option>\n                        {% for option in field.validValues %}\n                          <option value=\"{{option.label}}\">{{option.label}}</option>\n                        {% endfor %}\n                      </select>\n                      <label>{{field.name}}</label>\n                    </div>\n                  {% elif field.name == 'Description' %}\n                    <div class=\"input-field\">\n                      <textarea id=\"{{field.name}}\" class=\"materialize-textarea\" placeholder=\"{{field.description}}\"></textarea>\n                      <label for=\"{{request.name}} {{field.name}}\">{{field.name}}</label>\n                    </div>\n                  {% else %}\n                    <div class=\"input-field\">\n                      <input placeholder=\"{{field.description}}\" id=\"{{request.name}} {{field.name}}\" type=\"text\" class=\"validate\">\n                      <label for=\"{{request.name}} {{field.name}}\">{{field.name}}</label>\n                    </div>\n                  {% endif %}\n                {% endfor %}\n                <input type=\"button\" value=\"Submit\" class=\"btn cyan lighten-3 formsubmit\">\n              </div>\n            </form>\n          </div>\n        </div>\n      </li>\n      {% endfor %}\n    </ul>\n  </div>\n{% endblock %}\n\n\nBecause we passed the Service Desk JSON we extracted from the JIRA API to our\nform, we can go crazy setting our labels, placeholder text, or whatever,\nanywhere we please. In my example, I utilize Material Design\n[https://materializecss.com/]'s pretty package of pre-made frontend elements,\nbecause God knows nobody wants to deal with designing that shit. Sorry, I was\njust having a brief flashback to Frontend dev.\n\nThe code above explicitly looks for fields we know are dropdowns, so that we may\nfill the select options accordingly. Same goes for textarea fields. That said,\nthe way I've handled this above is, well, stupid. Instead of hardcoding if\nstatements to look for certain fields, leverage our JSON to determine the type\nof each field as you iterate over them. Do as I say, not as I do.\n\nGoing Further\nThere's so much more we can add here. Take a list of the user's opened tickets,\nfor instance. The great thing about controlling your own portal UI is that you\ncan now control the narrative of your own workload: perhaps the person in\nmarketing who started 2 weeks ago could benefit from seeing the 200 tickets\nbeing addressed before her, thus second-guessing the urge to type URGENT across\na subject line only to be violently shoved down your throat.\n\nIn all seriousness, nobody likes the experience of a vanilla helpdesk because it\ndehumanizes the customer. While our personal beliefs reassure us that we are\nspecial, entering a cold support queue is a stark suggestion that we may not be\nso special after all, which isn't exactly a fact Millennials or Executives like\nto ponder on. If nothing else, take this as a chance to build software friendly\ntowards humans with full transparency, and both parties will surely benefit.\nRemember: happy humans bides times for the inevitable robot revolution on the\nhorizon destined to eradicate mankind. Do your part!","html":"<p>When it comes to SaaS products in the realm of Service desks, JIRA Service Desk is at the very <em>least</em>, just as powerful as the next solution (Zendesk comes to mind). This naturally begs the question: Why is JIRA Service Desk's pricing model roughly 1/10th of that of it's competitor?</p><p>The answer lies within <em>ease of use,</em> but more importantly, <em>presentation</em>. While Atlassian's cloud offering is slowly playing catchup, Atlassian as a company has never quite seemed to nail down the importance of a friendly user interface, nor the importance of this when it comes to worldwide adoption. To see what I mean, here's an example that Atlassian themselves tout on their own documentation as a \"ready for production\" customer portal:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/customer-portal.png\" class=\"kg-image\"><figcaption>I'm convinced this is purposefully hideous to force the purchase of plugins.</figcaption></figure><p>To your average software developer (Atlassian's core demographic for years), one might see nothing wrong with this interface, but as somebody `who has rolled out over 30 of these desks for over 6 thousand people, layouts such as these commit numerous UI atrocities which simply are not acceptable for top enterprise software.</p><p>What do we do about this? We build an alternative, of course.</p><h2 id=\"method-to-this-madness\">Method to This Madness</h2><p>Our focus is not on JIRA as a <em>product,</em> but rather an <em>API. </em>Instead of attempting to work within JIRA’s boundaries via customization or add-ons, we can take matters into our own hands by owning the application that users use to interact with a JIRA instance. By using the JIRA API, we can not only extend features but actually ‘rebuild’ the application to gain full control over the UI or additional logic. JIRA is a hideous yet entirely necessary Java application, which makes it a perfect candidate for recreation.</p><p>We're going to use Flask for this. Shocking, I know. Here's the obligatory file structure of our project:</p><pre><code class=\"language-bash\">myproject\n├─ app.py\n├─ jira.py\n├─ /static\n│  └─ js\n│  └─ less\n│  └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n</code></pre>\n<p>This tutorial will be working against the JIRA <em>Server</em> API for Service Desk - that said, Cloud users should still find this applicable.</p><h2 id=\"pulling-your-service-desk-form\">Pulling Your Service Desk Form</h2><p>Before we get nuts building our application, we’ll need to be sure that a Service Desk already exists in JIRA with our expected intake form. Remember: our end goal is to simply consume JIRA as an API, but that entails interacting with something that exists in the first place.</p><p>With your Service Desk created, there’s one annoyance we need to resolve before getting into code: determining your Service Desk’s ID number. Like most things in JIRA, Service Desks are identified by an ID which is simply an arbitrary grouping of integers in some way. What is the official way to find this ID, you might ask? Why, by extracting it from the portal’s URL or by inspecting your XHR requests, of course! Remember: JIRA hates you, that’s why we’re doing this in the first place.</p><p>With your Service Desk ID handy, we can finally break into retrieving our desk via the Service Desk API:</p><pre><code class=\"language-python\">import requests\nfrom jira_config import jira_username, jira_password\n\nrequest_types_endpoint = &quot;https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/&quot;\n\nheaders = {'Content-Type': 'application/json'}\n\ndef fieldsPerRequest(id):\n    &quot;&quot;&quot;Get form fields per request type.&quot;&quot;&quot;\n    r = requests.get(request_types_endpoint + id + '/field', auth=(jira_username, jira_password), headers=headers)\n    form = r.json()\n    return form\n\n\ndef serviceDeskRequestTypes():\n    &quot;&quot;&quot;Get request types.&quot;&quot;&quot;\n    request_array = []\n    r = requests.get(request_types_endpoint, auth=(jira_username, jira_password), headers=headers)\n    for requesttype in r.json()['values']:\n        id = requesttype['id']\n        request_dict = {\n            'name': requesttype['name'],\n            'description': requesttype['description'],\n            'icon': requesttype['icon']['_links']['iconUrls']['32x32'],\n            'fields': fieldsPerRequest(id)\n        }\n        request_array.append(request_dict)\n    return request_array\n</code></pre>\n<h3 id=\"servicedeskrequesttypes-\">serviceDeskRequestTypes()</h3><p>By using the <em>request_types_endpoint</em> URL, our function <code>serviceDeskRequestTypes()</code> returns the <strong>request types</strong> of a given JIRA service desk; or in other words, the <em>types of requests users can submit.</em> This alone only gives us high-level information about the types of requests we allow but doesn't go into further detail such as the actual resulting form. That's where our next function comes in.</p><h3 id=\"fieldsperrequest-\">fieldsPerRequest()</h3><p>This function gets passed the ID of each request type. With that, we extend our endpoint to look like <code>'https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/[REQUESTID]/field'</code>. Looping through each request type gives up exactly what we need: every request type and every form field per request type.</p><h3 id=\"usersession-\">userSession()</h3><p>There's another thing left to consider: what if the user isn't currently logged in to JIRA? At the very least, we need to check to see if a JIRA session is active:</p><pre><code class=\"language-python\">user_session_endpoint = 'https://jira.we.co/rest/auth/1/session'\n\ndef getUserSession():\n    &quot;&quot;&quot;Get logged-in user.&quot;&quot;&quot;\n    r = requests.get(user_session_endpoint, headers=headers)\n    if r.status_code == 200:\n        return r.json()\n    else:\n        return False\n</code></pre>\n<p>If the user is logged in to JIRA, we'll receive a 200 code letting us know everything is alright. The body of the response will also contain the name of the user plus some extra metadata. What if the user <em>isn't</em> logged in? Let's get to that in a bit.</p><h2 id=\"easy-routing\">Easy Routing</h2><p>Our view will be nice and simple:</p><pre><code class=\"language-python\">from jira import request_forms, user_details\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    if user_details == False:\n        return redirect('https://example.com')\n    else:\n        return render_template('/index.html', requests=request_forms)\n</code></pre>\n<p>Notice that all we're doing is making sure the user is signed in to JIRA. But what's with the <em>example.com</em>, you ask? Well, because I'm leaving this part up to you, dear friend. There's really a number of things we can do, but it depends entirely on your situation. For instance:</p><ul><li>You can handle basic auth on your own</li><li>Register an OAuth application to handle sign-ins (perhaps the most robust solution)</li><li>If your JIRA instance is behind SSO, you may want to send users to your company's  SAML partner</li><li>Simply throw an error message</li></ul><p>Whatever you decide to do, it's not really my problem. Obligatory smiley face emoji :).</p><h2 id=\"the-template\">The Template</h2><p>Remember: the main reason most of you are probably doing this is to control the presentation layer as you see fit. That said, here comes a call of presentation layer text, in the form of a Jinja template:</p><pre><code class=\"language-jinja\">{% block form %}\n  &lt;div&gt;\n    &lt;h3 class=&quot;subtitle&quot;&gt;Submit new requests here&lt;/h3&gt;\n    &lt;ul class=&quot;collapsible&quot;&gt;\n      {% for request in requests %}\n      &lt;li class=&quot;{{request.name}}&quot;&gt;\n        &lt;div class=&quot;collapsible-header&quot;&gt;\n          &lt;img src=&quot;{{request.icon}}&quot;&gt;\n          &lt;div class=&quot;info&quot;&gt;\n            &lt;h5&gt;{{request.name}}&lt;/h5&gt;\n            &lt;p&gt;{{request.description}}&lt;/p&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;collapsible-body&quot;&gt;\n          &lt;div class=&quot;row&quot;&gt;\n            &lt;form method=&quot;post&quot;&gt;\n              &lt;div&gt;\n                {% for field in request.fields.requestTypeFields %}\n                  {% if field.name in ('Category', 'Product') %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;select id=&quot;{{request.name}} {{field.name}}&quot;&gt;\n                        &lt;option value=&quot;Choose your option&quot; disabled selected&gt;Choose your option&lt;/option&gt;\n                        {% for option in field.validValues %}\n                          &lt;option value=&quot;{{option.label}}&quot;&gt;{{option.label}}&lt;/option&gt;\n                        {% endfor %}\n                      &lt;/select&gt;\n                      &lt;label&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% elif field.name == 'Description' %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;textarea id=&quot;{{field.name}}&quot; class=&quot;materialize-textarea&quot; placeholder=&quot;{{field.description}}&quot;&gt;&lt;/textarea&gt;\n                      &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% else %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;input placeholder=&quot;{{field.description}}&quot; id=&quot;{{request.name}} {{field.name}}&quot; type=&quot;text&quot; class=&quot;validate&quot;&gt;\n                      &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% endif %}\n                {% endfor %}\n                &lt;input type=&quot;button&quot; value=&quot;Submit&quot; class=&quot;btn cyan lighten-3 formsubmit&quot;&gt;\n              &lt;/div&gt;\n            &lt;/form&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre>\n<p>Because we passed the Service Desk JSON we extracted from the JIRA API to our form, we can go crazy setting our labels, placeholder text, or whatever, anywhere we please. In my example, I utilize <a href=\"https://materializecss.com/\">Material Design</a>'s pretty package of pre-made frontend elements, because God knows nobody wants to deal with designing that shit. Sorry, I was just having a brief flashback to Frontend dev.</p><p>The code above explicitly looks for fields we know are dropdowns, so that we may fill the select options accordingly. Same goes for textarea fields. That said, the way I've handled this above is, well, stupid. Instead of hardcoding if statements to look for certain fields, leverage our JSON to determine the type of each field as you iterate over them. Do as I say, not as I do.</p><h2 id=\"going-further\">Going Further</h2><p>There's so much more we can add here. Take a list of the user's opened tickets, for instance. The great thing about controlling your own portal UI is that you can now control the narrative of your own workload: perhaps the person in marketing who started 2 weeks ago could benefit from seeing the 200 tickets being addressed before her, thus second-guessing the urge to type <strong>URGENT </strong>across a subject line only to be violently shoved down your throat.</p><p>In all seriousness, nobody likes the experience of a vanilla helpdesk because it dehumanizes the customer. While our personal beliefs reassure us that we are special, entering a cold support queue is a stark suggestion that we may not be so special after all, which isn't exactly a fact Millennials or Executives like to ponder on. If nothing else, take this as a chance to build software friendly towards humans with full transparency, and both parties will surely benefit. Remember: happy humans bides times for the inevitable robot revolution on the horizon destined to eradicate mankind. Do your part!</p>","url":"https://hackersandslackers.com/building-a-better-jira/","uuid":"789d1406-0dbf-432e-aaa0-32d10f7d6337","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b6f24cc0cd9b8583e46ab5b"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736d8","title":"The End-to-End Guide to Handling Forms in Flask","slug":"guide-to-building-forms-in-flask","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/08/forms@2x.jpg","excerpt":"The subtle art of consensually capturing personal data.","custom_excerpt":"The subtle art of consensually capturing personal data.","created_at_pretty":"15 August, 2018","published_at_pretty":"15 August, 2018","updated_at_pretty":"09 April, 2019","created_at":"2018-08-14T22:13:40.000-04:00","published_at":"2018-08-15T06:25:00.000-04:00","updated_at":"2019-04-08T23:17:31.000-04:00","meta_title":"The End-to-End Guide to Handling Forms in Flask | Hackers And Slackers","meta_description":"Learn how to build complex form logic in Flask using the WTForms Python library! Cover the backend logic as well as best practices for form Jinja templates.","og_description":"Learn how to build complex form logic in Flask using the WTForms Python library! Cover the backend logic as well as best practices for form Jinja templates.","og_image":"https://hackersandslackers.com/content/images/2018/08/forms@2x.jpg","og_title":"The End-to-End Guide to Building Forms in Flask","twitter_description":"Learn how to build complex form logic in Flask using the WTForms Python library! Cover the backend logic as well as best practices for form Jinja templates.","twitter_image":"https://hackersandslackers.com/content/images/2018/08/forms@2x.jpg","twitter_title":"The End-to-End Guide to Building Forms in Flask","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"Happy Tuesday everybody! To start this week hot, let's talk about something that\neverybody hates: forms. The only thing more painful than filling out a web form\nis creating one, much less a functional one with feedback. Listen, if you're\ninto creating pleasant form UI experiences, you're probably into some freaky\nshit. Call me.\n\nFlask's youth is an advantage in one regard, in that there are only so many\nlibraries available to handle any given task. In this case, there's only one:\nthe aptly named WTForms.\n\nIf you don't have an immediate pressing need to create a Flask form and feel\nlike ditching this post to check out Instagram, be my guest, but know this:\nhandling form authentication, data submission, and session management is the\npinnacle of app development. This weird data collection traditional we\nexperience every day actually touches on nearly all aspects of app development.\nYou could argue that he who creates forms is a harbinger of a golden age: a hero\nwho brings us to the pinnacle of Western technology. Then again, there's always\nInstagram.\n\nThe Gist of it All\nBefore laying down some code snippets for you to mindlessly copy+paste, it helps\nto understand conceptually what we're about to throw down.\n\nAt a minimum, creating a form has us working routes, form  models, and templates\n. Since you already understand the concept of MVC, that entire last sentence was\nprobably redundant, and I should probably just delete it as opposed to\ncontinuing to write this second sentence contemplating my own redundancy. Oh\nwell.\n\nWe'll keep our routes in app.py  for a compact little app.\n\nmyproject\n├─ app.py\n├─ config.py\n├─ forms.py\n├─ db.py\n├─ /static\n│  ├─ /src\n│  │  ├─ js\n│  │  └─ less\n│  └─ /dist\n│     ├─ js\n│     ├─ css\n│     └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n   └─ form.html\n\n\nHere's the game plan: our form, with all its fields, labels, and potential error\nmessages, will live in forms.py. app.py  will contain the logic of not only\nrouting to the page serving the form, but also validating user input, which\ncovers anything from error checking to session creation. \n\nform.html  will be the presentation layer template which will get loaded into \nindex.html  in this case. Both of those templates are wrapped by layout.html \nwhich is basically just metadata and shit you already know — we’ve been through\nthis. Let’s start off by creating our forms.py.\n\nWhat The Form\nWTForms  has a nice little monopoly over the Python form handling industry\ndating back to Django, so at least we aren't burdened with choices here. Set up\nyour environment and let's install everything we need:\n\npipenv shell\npip3 install Flask WTForms Flask-Login\n\n\nThat'll hold us over for now. In forms.py,  we're going to do two main imports:\n\nfrom wtforms import Form, StringField, PasswordField, validators, SubmitField, SelectField\n\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length\n\n\nForms really boil down into these two things: types of input, and validation of\nsaid input. There are plenty more fields and validators available, but this is\nwhat we'd need for a user signup form. Guess what we're making. \n\nClassy as Form\nForms in your app will always be defined 1-to-1 with a Python class declaration.\nIt's kind of like working with models, except they're forms. Just wait until\nyour forms work with models.\n\nfrom wtforms import Form, StringField, PasswordField, validators, SubmitField, SelectField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length\n\n\nclass SignupForm(Form):\n    \"\"\"User Signup Form.\"\"\"\n\n    name = StringField('Name', [\n        validators.DataRequired(message=('Don\\'t be shy!'))\n    ])\n    email = StringField('Email', [\n        Length(min=6, message=(u'Little short for an email address?')),\n        Email(message=('That\\'s not a valid email address.')),\n        DataRequired(message=('That\\'s not a valid email address.'))\n    ])\n    password = PasswordField('Password', validators=[\n        DataRequired(message=\"Please enter a password.\"),\n    ])\n    confirm = PasswordField('Repeat Password', validators=[\n            EqualTo(password, message='Passwords must match.')\n            ])\n    website = StringField('Website')\n    submit = SubmitField('Register')\n\n    def validate_email(self, email):\n        \"\"\"Email validation.\"\"\"\n        user = User.query.filter_by(email=email.data).first()\n        if user is not None:\n            raise ValidationError('Please use a different email address.')\n\n\nAs expected, every variable child of our class is a field. Field types are\ndeclared immediately (such as StringField()) and accept a label (name of the\nfield) as well as validators, which are conditions which must be met for the\nfield to be considered valid. A single field can accept an infinite number of\nvalidators, which would come in handy if you're a stickler for password\nsecurity. As well as setting the validators, we also set the error message to\npass to the user for that particular field if they are to submit invalid\ninformation. Fields accept other parameters as well, such as placeholder text,\nif you're interested in that side of things\n[https://wtforms.readthedocs.io/en/stable/fields.html#the-field-base-class].\n\nSome validators are more sophisticated enough to handle heavy-lifting: note how \nEmail()  is a validator in itself which handles the nonsense of looking for an\n'@' symbol (or whatever it is PHP guys did in the 90's). There’s even a regex\nvalidator available if you want to go full pro-mode.\n\nHardcore Validation XXX\nYou'll notice the example provided contains a validate_email()  function to\ncheck the database for a user record match. We can basically write any custom\nlogic we want to validate forms this way, in case the event that the standard\nvalidators just don't cut it.\n\nForming the Actual Form\nAlright, it's that time. Jinja's form handling isn't as daunting as this next\nwall of text might seem, once you get in the groove of things:\n\n{% block content %}\n<div class=\"formwrapper\">\n  <form method=post>\n    <div class=\"name\">\n      {{ form.name(placeholder='Joe Blah') }} {{ form.name.label }}\n      {% if form.name.errors %}\n        <ul class=\"errors\">{% for error in form.name.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n      {% endif %}\n    </div>\n    <div class=\"email\">\n      {{ form.email }} {{ form.email.label }}\n      {% if form.email.errors %}\n        <ul class=\"errors\">{% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n      {% endif %}\n    </div>\n    <div class=\"password\">\n      {{ form.password }} {{ form.password.label }}\n      {% if form.password.errors %}\n        <ul class=\"errors\">{% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n      {% endif %}\n    </div>\n    <div class=\"confirm\">\n      {{ form.confirm }} {{ form.confirm.label }}\n      {% if form.confirm.errors %}\n        <ul class=\"errors\">{% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n      {% endif %}\n    </div>\n    <div class=\"website\">\n      {{ form.website(placeholder='http://example.com') }} {{ form.website.label }}\n    </div>\n    <div class=\"submitbutton\">\n      <input id=\"submit\" type=\"submit\" value=\"Submit\">\n    </div>\n  </form>\n</div>\n\n{% for message in get_flashed_messages() %}\n<div class=\"alert alert-warning\">\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n    {{ message }}\n</div>\n{% endfor %}\n\n\nNotice that our form contains a method, but neither a destination nor an action.\nMore on that late.\n\nEach form field is pulling in three dynamic assets: the form itself, the display\nname, and a space reserved for error handling. This general layout is robust\nenough to handle returning multiple errors per field, which we obviously would\nprefer to keep in-line with the offending fields for UI purposes.\n\nAnother way of handling errors is by utilizing Flask's flash  module. A 'flash'\nis a temporary modal telling the user what they did wrong, which can be closed\nor simply expire after a number of seconds. We're using both forms of error\nhandling here for educational purposes, but you probably won't need to most of\nthe time.\n\nDrop Some Logic on These Fools\napp.py  contains the route to the form, which allows for both GET and POST \nmethods. Submitting a form in Flask cleverly routes the user to the page they're\nalready on. Depending on what the logic decides, the user will experience\neither: \n\n * Instant in-line errors, with no visible change of page.\n * A successful redirect to wherever they hoped the form would take them.\n\nfrom flask import Flask, url_for, render_template, Markup, redirect, request, flash\nfrom flask import session as login_session\nfrom forms import SignupForm\nimport config\nfrom models import User, users, login_manager\nfrom db import users_col\nimport logging\nimport sys\nimport json\n\n\napp = Flask(__name__, static_url_path='', static_folder=\"static\", template_folder=\"templates\")\ncompress = FlaskStaticCompress(app)\napp.config.from_object('config.Config')\n\n\n@app.route('/signup', methods=['GET', 'POST'])\ndef signup():\n    \"\"\"Signup Form.\"\"\"\n    signup_form = SignupForm()\n    if request.method == 'POST':\n        if signup_form.validate():\n            flash('Logged in successfully.')\n            return render_template('/dashboard.html', template=\"dashbord-template\")\n    return render_template('/signup.html', form=signup_form, template=\"form-page\")\n\n\nYou'll recognize SignupForm() as our good old buddy from forms.py  which has\nbeen imported here. Because the user submitted their form, they will experience\nthe page with everything that lives within if request.method == 'POST':  this\ntime around. Determining validation is as simple as the next line: if\nsignup_form.validate():. This one-liner will validate each field individually,\nand deliver the proper errors to the offending fields. This level of black magic\nsaves us a huge headache and actually means that creating additional forms in\nthe future won't be all that different from simply adjusting the class and\ntemplate we already made. All that negative form talk I dropped earlier was a\ntest. You passed.\n\nWhat happens next?\nAs you might infer from the conditional statements, the user will either\nsuccessfully complete the form and move on to the next page, or they might find\nthemselves in a Ancient Greek version of hell where they find themselves\nincorrectly filling out the same form forever. Sucks to suck.\n\nIf this were a real signup form, we'd handle user creation and database\ninteraction here as well. As great as that sounds, I'll save your time as I know\nyou still have an Instagram to check. Hats off to anybody who has made it\nthrough this rambling nonsense  - you deserve it.","html":"<p>Happy Tuesday everybody! To start this week hot, let's talk about something that everybody hates: forms. The only thing more painful than filling out a web form is creating one, much less a functional one with feedback. Listen, if you're into creating pleasant form UI experiences, you're probably into some freaky shit. Call me.</p><p>Flask's youth is an advantage in one regard, in that there are only so many libraries available to handle any given task. In this case, there's only one: the aptly named WTForms.</p><p>If you don't have an immediate pressing need to create a Flask form and feel like ditching this post to check out Instagram, be my guest, but know this: handling form authentication, data submission, and session management is the pinnacle of app development. This weird data collection traditional we experience every day actually touches on nearly all aspects of app development. You could argue that he who creates forms is a harbinger of a golden age: a hero who brings us to the pinnacle of Western technology. Then again, there's always Instagram.</p><h2 id=\"the-gist-of-it-all\">The Gist of it All</h2><p>Before laying down some code snippets for you to mindlessly copy+paste, it helps to understand conceptually what we're about to throw down.</p><p>At a minimum, creating a form has us working <strong>routes</strong>, form<strong> models</strong>, and <strong>templates</strong>. Since you already understand the concept of MVC, that entire last sentence was probably redundant, and I should probably just delete it as opposed to continuing to write this second sentence contemplating my own redundancy. Oh well.</p><p>We'll keep our routes in <code>app.py</code> for a compact little app.</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">myproject\n├─ app.py\n├─ config.py\n├─ forms.py\n├─ db.py\n├─ /static\n│  ├─ /src\n│  │  ├─ js\n│  │  └─ less\n│  └─ /dist\n│     ├─ js\n│     ├─ css\n│     └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n   └─ form.html\n</code></pre>\n<!--kg-card-end: markdown--><p>Here's the game plan: our form, with all its fields, labels, and potential error messages, will live in <code>forms.py</code>. <code>app.py</code><strong> </strong>will contain the logic of not only routing to the page serving the form, but also validating user input, which covers anything from error checking to session creation. </p><p><code>form.html</code> will be the presentation layer template which will get loaded into <code>index.html</code> in this case. Both of those templates are wrapped by <code>layout.html</code> which is basically just metadata and shit you already know — we’ve been through this. Let’s start off by creating our <code>forms.py</code><strong>.</strong></p><h2 id=\"what-the-form\">What The Form</h2><p><code>WTForms</code> has a nice little monopoly over the Python form handling industry dating back to Django, so at least we aren't burdened with choices here. Set up your environment and let's install everything we need:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">pipenv shell\npip3 install Flask WTForms Flask-Login\n</code></pre>\n<!--kg-card-end: markdown--><p>That'll hold us over for now. In <code>forms.py</code><strong>,</strong> we're going to do two main imports:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from wtforms import Form, StringField, PasswordField, validators, SubmitField, SelectField\n\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length\n</code></pre>\n<!--kg-card-end: markdown--><p>Forms really boil down into these two things: types of input, and validation of said input. There are plenty more fields and validators available, but this is what we'd need for a user signup form. Guess what we're making. </p><h3 id=\"classy-as-form\">Classy as Form</h3><p>Forms in your app will always be defined 1-to-1 with a Python class declaration. It's kind of like working with models, except they're forms. Just wait until your forms work with models.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from wtforms import Form, StringField, PasswordField, validators, SubmitField, SelectField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo, Length\n\n\nclass SignupForm(Form):\n    &quot;&quot;&quot;User Signup Form.&quot;&quot;&quot;\n\n    name = StringField('Name', [\n        validators.DataRequired(message=('Don\\'t be shy!'))\n    ])\n    email = StringField('Email', [\n        Length(min=6, message=(u'Little short for an email address?')),\n        Email(message=('That\\'s not a valid email address.')),\n        DataRequired(message=('That\\'s not a valid email address.'))\n    ])\n    password = PasswordField('Password', validators=[\n        DataRequired(message=&quot;Please enter a password.&quot;),\n    ])\n    confirm = PasswordField('Repeat Password', validators=[\n            EqualTo(password, message='Passwords must match.')\n            ])\n    website = StringField('Website')\n    submit = SubmitField('Register')\n\n    def validate_email(self, email):\n        &quot;&quot;&quot;Email validation.&quot;&quot;&quot;\n        user = User.query.filter_by(email=email.data).first()\n        if user is not None:\n            raise ValidationError('Please use a different email address.')\n</code></pre>\n<!--kg-card-end: markdown--><p>As expected, every variable child of our class is a field. Field types are declared immediately (such as StringField()) and accept a <em>label </em>(name of the field) as well as <em>validators</em>, which are conditions which must be met for the field to be considered valid. A single field can accept an infinite number of validators, which would come in handy if you're a stickler for password security. As well as setting the validators, we also set the error message to pass to the user for that particular field if they are to submit invalid information. Fields accept other parameters as well, such as placeholder text, if you're interested in <a href=\"https://wtforms.readthedocs.io/en/stable/fields.html#the-field-base-class\">that side of things</a>.</p><p>Some validators are more sophisticated enough to handle heavy-lifting: note how <em>Email()</em> is a validator in itself which handles the nonsense of looking for an '@' symbol (or whatever it is PHP guys did in the 90's). There’s even a regex validator available if you want to go full pro-mode.</p><h3 id=\"hardcore-validation-xxx\">Hardcore Validation XXX</h3><p>You'll notice the example provided contains a <strong>validate_email()</strong> function to check the database for a user record match. We can basically write any custom logic we want to validate forms this way, in case the event that the standard validators just don't cut it.</p><h2 id=\"forming-the-actual-form\">Forming the Actual Form</h2><p>Alright, it's that time. Jinja's form handling isn't as daunting as this next wall of text might seem, once you get in the groove of things:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% block content %}\n&lt;div class=&quot;formwrapper&quot;&gt;\n  &lt;form method=post&gt;\n    &lt;div class=&quot;name&quot;&gt;\n      {{ form.name(placeholder='Joe Blah') }} {{ form.name.label }}\n      {% if form.name.errors %}\n        &lt;ul class=&quot;errors&quot;&gt;{% for error in form.name.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;\n      {% endif %}\n    &lt;/div&gt;\n    &lt;div class=&quot;email&quot;&gt;\n      {{ form.email }} {{ form.email.label }}\n      {% if form.email.errors %}\n        &lt;ul class=&quot;errors&quot;&gt;{% for error in form.email.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;\n      {% endif %}\n    &lt;/div&gt;\n    &lt;div class=&quot;password&quot;&gt;\n      {{ form.password }} {{ form.password.label }}\n      {% if form.password.errors %}\n        &lt;ul class=&quot;errors&quot;&gt;{% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;\n      {% endif %}\n    &lt;/div&gt;\n    &lt;div class=&quot;confirm&quot;&gt;\n      {{ form.confirm }} {{ form.confirm.label }}\n      {% if form.confirm.errors %}\n        &lt;ul class=&quot;errors&quot;&gt;{% for error in form.password.errors %}&lt;li&gt;{{ error }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;\n      {% endif %}\n    &lt;/div&gt;\n    &lt;div class=&quot;website&quot;&gt;\n      {{ form.website(placeholder='http://example.com') }} {{ form.website.label }}\n    &lt;/div&gt;\n    &lt;div class=&quot;submitbutton&quot;&gt;\n      &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/div&gt;\n\n{% for message in get_flashed_messages() %}\n&lt;div class=&quot;alert alert-warning&quot;&gt;\n    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;\n    {{ message }}\n&lt;/div&gt;\n{% endfor %}\n</code></pre>\n<!--kg-card-end: markdown--><p>Notice that our form contains a method, but neither a destination nor an action. More on that late.</p><p>Each form field is pulling in three dynamic assets: the form itself, the display name, and a space reserved for error handling. This general layout is robust enough to handle returning multiple errors per field, which we obviously would prefer to keep in-line with the offending fields for UI purposes.</p><p>Another way of handling errors is by utilizing Flask's <em>flash</em> module. A 'flash' is a temporary modal telling the user what they did wrong, which can be closed or simply expire after a number of seconds. We're using both forms of error handling here for educational purposes, but you probably won't need to most of the time.</p><h2 id=\"drop-some-logic-on-these-fools\">Drop Some Logic on These Fools</h2><p><code>app.py</code> contains the route to the form, which allows for both <strong>GET </strong>and <strong>POST</strong> methods. Submitting a form in Flask cleverly routes the user to the <em>page they're already on. </em>Depending on what the logic decides, the user will experience either: </p><ul><li>Instant in-line errors, with no visible change of page.</li><li>A successful redirect to wherever they hoped the form would take them.</li></ul><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, url_for, render_template, Markup, redirect, request, flash\nfrom flask import session as login_session\nfrom forms import SignupForm\nimport config\nfrom models import User, users, login_manager\nfrom db import users_col\nimport logging\nimport sys\nimport json\n\n\napp = Flask(__name__, static_url_path='', static_folder=&quot;static&quot;, template_folder=&quot;templates&quot;)\ncompress = FlaskStaticCompress(app)\napp.config.from_object('config.Config')\n\n\n@app.route('/signup', methods=['GET', 'POST'])\ndef signup():\n    &quot;&quot;&quot;Signup Form.&quot;&quot;&quot;\n    signup_form = SignupForm()\n    if request.method == 'POST':\n        if signup_form.validate():\n            flash('Logged in successfully.')\n            return render_template('/dashboard.html', template=&quot;dashbord-template&quot;)\n    return render_template('/signup.html', form=signup_form, template=&quot;form-page&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>You'll recognize SignupForm() as our good old buddy from <code>forms.py</code> which has been imported here. Because the user submitted their form, they will experience the page with everything that lives within <code>if request.method == 'POST':</code> this time around. Determining validation is as simple as the next line: <code>if signup_form.validate():</code>. This one-liner will validate each field individually, and deliver the proper errors to the offending fields. This level of black magic saves us a huge headache and actually means that creating additional forms in the future won't be all that different from simply adjusting the class and template we already made. All that negative form talk I dropped earlier was a test. You passed.</p><h3 id=\"what-happens-next\">What happens next?</h3><p>As you might infer from the conditional statements, the user will either successfully complete the form and move on to the next page, or they might find themselves in a Ancient Greek version of hell where they find themselves incorrectly filling out the same form forever. Sucks to suck.</p><p>If this were a real signup form, we'd handle user creation and database interaction here as well. As great as that sounds, I'll save your time as I know you still have an Instagram to check. Hats off to anybody who has made it through this rambling nonsense  - you deserve it.</p>","url":"https://hackersandslackers.com/guide-to-building-forms-in-flask/","uuid":"7cb4b740-9bda-4d96-a28d-83487d6581ce","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b738c54c43a944face384b1"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736c6","title":"Using MongoDB Atlas as your Flask Database","slug":"using-mongodb-atlas-as-your-flask-database","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","excerpt":"Since you prefer using Python and Flask, I’ll assume we both prefer enjoyable dev.","custom_excerpt":"Since you prefer using Python and Flask, I’ll assume we both prefer enjoyable dev.","created_at_pretty":"28 July, 2018","published_at_pretty":"31 July, 2018","updated_at_pretty":"07 March, 2019","created_at":"2018-07-28T13:42:54.000-04:00","published_at":"2018-07-31T16:59:00.000-04:00","updated_at":"2019-03-07T01:02:11.000-05:00","meta_title":"Using MongoDB Atlas as your Flask Database | Hackers And Slackers","meta_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","og_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","og_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","og_title":"Using MongoDB Atlas as your Flask Database","twitter_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","twitter_title":"Using MongoDB Atlas as your Flask Database","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"It's been roughly a year since MongoDB launched their Stitch: a \"back-end as a\nservice\" cloud offering. I've been tinkering with Mongo on the cloud ever\nsince... Alright fine, \"tinkering with\"  may better be described as\"accidentally\nbecame dependent on it after developing new features in production\nenvironments,\" but I can't really complain thus-far. If you're not familiar, \nMongoDB Atlas  is MongoDB's cloud-hosted database offering; that is to say, the\nsame as any other MongoDB database, except very expensive.\n\nThe jury is still out on how MongoDB Atlas  and its counterpart Stitch  will fit\ninto the picture of next generation cloud services. That said, I can vouch that\nMongo products are simply fun to use  for developers, especially when compared\nto  traditional rigid alternatives. Since I would also group Python  and Flask \nin the 'fun to use' category, selecting MongoDB as the database for your Flask\napp makes a lot of sense.\n\nFor this tutorial we're going to set up a simple app where users can submit\ninformation via a form to MongoDB. After writing to our database, we'll query\nthe db to see the results. The result will be a Flask app with the following\nfile structure:\n\nmy-flask-project\n├── templates/\n├── static/\n├── app.py\n├── config.py\n├── currenttime.py\n└── form.py\n\n\nConnect to your Database with PyMongo\nPyMongo  is Python's go-to library for interacting with MongoDB. \n\nWe'll keep all database connection logic within db.py. After importing PyMongo,\nmost of the configuration we need to handle happens in a single line containing\nour MongoDB URI: the massive string which contains our DB location, creds, and\nauthorization DB. The string is broken down like this:\n\nmongodb+srv://[username]:[password]@[projectname]-gktww.gcp.mongodb.net/[authDB]\n\n\nAuthenticate with a [username]  and [password] you’ve set up in whichever\ndatabase handles authentication for your MongoDB instance (this is also what \n[authDB]  is referring to). \n\n[projectname]  is the unique name of your cloud instance. The rest of the URI\ncontains some nonsense, including the host of your particular instance (I’m\nusing Google Cloud, hence the .gcp in the URI). Most of this information can be\nfound just by jumping on mongodb.com [https://www.mongodb.com/]  and\ninvestigating your URI via the \"connect\" popup:\n\nThat should make things a bit easier.Now we can set up our connection:\n\nimport pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@hackerdata-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\n\nNote that we intentionally set the connection to False. Otherwise, we're going\nto find ourselves in a hell of managing open connections every time we interact\nwith the DB.\n\nSpeaking of the DB, we need to specify which database and collection we want to\ninteract with. This brings our config file to something as follows:\n\nimport pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\n\nLastly, if you'd like to access, say, all the objects inside of a collection (or\nsimilar query), we'll just need to add a few lines line to ensure we're reading\nthe collection's data:\n\nimport pymongo\nfrom bson.json_util import dumps\nimport json\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\ncol_results = json.loads(dumps(col.find().limit(5).sort(\"time\", -1)))\n\n\nRemember that Mongo returns BSON objects as opposed to JSON objects, which isn't\nvery useful for our purposes. To alleviate this we'll do a messy little dance to\nconvert Mongo's BSON into a string, and convert this to JSON using json.dumps().\n\nNote: the need to do this may have been something changed in recent versions of\nMongo, as I have older application functioning where this wasn't the case.\n¯\\_(ツ)_/¯.\n\nCreating a Form\nHeading over to form.py, we just need to set up a simple single-field form for\nusers to submit their URLs. For the sake of Python, let's say we're only\naccepting URLs for Jupyter noteboooks:\n\nfrom wtforms import Form, StringField, validators\nfrom wtforms.validators import DataRequired, Regexp\n\nclass myForm(Form):\n    \"\"\"Homepage form.\"\"\"\n    PlotlyURL = StringField('Provide a raw .ipynb URL from Github',\n    validators=[\n            DataRequired(),\n            Regexp(\".*\\.ipynb$\",\n            message=\"Please provide a URL ending in ipynb\"),\n          ])\n\n\nWe could have an entire tutorial just about Flask's WTForms\n[http://flask.pocoo.org/docs/1.0/patterns/wtforms/], but let's stay on topic\n and move on to currenttime.py.\n\nAdding Time Metadata\nIn a lot of cases where we store information to a database, we at least want to\nadd certain metadata such as the time something was added. This allows us to\narrange results by most recently updated, which we'll be doing in this example.\n\nfrom datetime import datetime, timezone\n\ndef getTime():\n    \"\"\"Get user's current time\"\"\"\n    rightnow = datetime.today()\n    return rightnow\n\ndef getPrettyTime():\n    \"\"\"Get user's pretty current time\"\"\"\n    rightnow = datetime.today()\n    prettytime = rightnow.ctime()\n    return prettytime\n\nyourtime = getTime()\nprettytime = getPrettyTime()\n\n\nThe variable yourtime  will be a datetime string representing the local time of\nthe user creating a new record. We will use this value to sort the queried\nresults by time. On the contrary,prettytime  will be the same time, only\nformatted in a way that is readable to humans.\n\nPutting the Pieces Together\nFinally we get to move on app.py and get this thing moving. We'll initiate our\napp by importing the necessary libraries, as well as the scripts we just\ncreated:\n\nfrom flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n\nNote that we need to import from the DB config we set earlier is the \"col\"\nvariable; we'll only be interacting directly with the collection we want to\nmodify, and the rest is assumed within the config file itself. Now let's build a\nroute for our homepage that does two things:\n\n * Allows users to submit a URL via the simple form we created\n * Displays all previous searches by all users.\n\nfrom flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    recent_searches = list(col_results)\n    return render_template('/index.html', form=myForm(), recents=recent_searches, template=\"home-template\")\n\n\nThere's only two significant lines here, but let's break them down piece by\npiece.\n\nrecent_searches\nFirst we set a recent_searches  variable which is essentially a query against\nour collection to retrieve a list of previous searches. We ask that these be\nreturned as a list()  upfront. Typically the find() method would contain the\nconstraints of our query, but we're simply asking to return all  results in the\ncollection, with a limit()  up to 5. Finally, we sort()  the results by the\nfield we refer to as 'time' is descending order, as noted by the -1 argument.\n\nThis is all probably very difficult to visualize without a graphic. Here's a\nsnapshot of the collection we're defining with dummy data added:\n\nSee why we need to differentiate \"time\" and \"prettytime\"?render_template\nWe already know [https://hackersandslackers.com/serving-static-assets-in-flask/] \n the basics of serving templates and assets in Flask, so it shouldn't be too\ndifficult to break down the last line in our route:\n\n * '/index.html'  specifies the base template we'll be serving up.\n * form=myForm()  passes the form class we created earlier to the form partial\n   we're including as part of the index page.\n * recents=recent_searches  passes the query of previous searches to the\n   template, with which we can build a widget.\n * template=\"home-template\" is a simple variable passed which we'll utilize as a\n   class on the page we're loading.\n\nThe Result\nFrom everything we've completed, you should be expecting to see a somewhat\nworthless page where users can submit links via a form, simply to see results\nposted by previous posters. If we expand on this idea just a bit, we can see how\nsomething so simple can actually be extended to a full product: \n\n> Planet Jupyter [https://planetjupyter.com]\nStyle your Jupyter Notebooks.\n\n\nPlanet Jupyter is demo product we built at H&S to style Jupyter notebooks.\nPerhaps 60% of the logic behind Planet Jupyter is the simple DB interactions we\njust covered, with the rest being added flair.\n\nThis is not a shameless plug for the barely functioning toys we've built, mind\nyou, but rather an example of simple DB interactions using Flask can be easily\nextensible into relevant, useful, products.\n\nWe hope you’ve found this tutorial to be useful!","html":"<p>It's been roughly a year since MongoDB launched their <strong>Stitch: </strong>a \"back-end as a service\" cloud offering. I've been tinkering with Mongo on the cloud ever since... Alright fine, <em>\"tinkering with\"</em> may better be described as  <em>\"accidentally became dependent on it after developing new features in production environments,\" </em>but I can't really complain thus-far. If you're not familiar, <strong>MongoDB Atlas</strong> is MongoDB's cloud-hosted database offering; that is to say, the same as any other MongoDB database, except very expensive.</p><p>The jury is still out on how MongoDB <strong>Atlas</strong> and its counterpart <strong>Stitch</strong> will fit into the picture of next generation cloud services. That said, I can vouch that Mongo products are simply <em>fun to use</em> for developers, especially when compared to  traditional rigid alternatives. Since I would also group <em>Python</em> and <em>Flask</em> in the 'fun to use' category, selecting MongoDB as the database for your Flask app makes a lot of sense.</p><p>For this tutorial we're going to set up a simple app where users can submit information via a form to MongoDB. After writing to our database, we'll query the db to see the results. The result will be a Flask app with the following file structure:</p><pre><code class=\"language-shell\">my-flask-project\n├── templates/\n├── static/\n├── app.py\n├── config.py\n├── currenttime.py\n└── form.py\n</code></pre>\n<h2 id=\"connect-to-your-database-with-pymongo\">Connect to your Database with PyMongo</h2><p><strong>PyMongo</strong> is Python's go-to library for interacting with MongoDB. </p><p>We'll keep all database connection logic within <strong>db.py</strong>. After importing PyMongo, most of the configuration we need to handle happens in a single line containing our MongoDB URI: the massive string which contains our DB location, creds, and authorization DB. The string is broken down like this:</p><pre><code class=\"language-shell\">mongodb+srv://[username]:[password]@[projectname]-gktww.gcp.mongodb.net/[authDB]\n</code></pre>\n<p>Authenticate with a <strong>[username]</strong> and <strong>[password] </strong>you’ve set up in whichever database handles authentication for your MongoDB instance (this is also what<strong> [authDB]</strong> is referring to). </p><p><strong>[projectname]</strong> is the unique name of your cloud instance. The rest of the URI contains some nonsense, including the host of your particular instance (I’m using Google Cloud, hence the .gcp in the URI). Most of this information can be found just by jumping on <a href=\"https://www.mongodb.com/\">mongodb.com</a> and investigating your URI via the \"connect\" popup:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2018-07-30-at-9.46.42-PM.png\" class=\"kg-image\"><figcaption>That should make things a bit easier.</figcaption></figure><p>Now we can set up our connection:</p><pre><code class=\"language-python\">import pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@hackerdata-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n</code></pre>\n<p>Note that we intentionally set the connection to <strong>False. </strong>Otherwise, we're going to find ourselves in a hell of managing open connections every time we interact with the DB.</p><p>Speaking of the DB, we need to specify which database and collection we want to interact with. This brings our config file to something as follows:</p><pre><code class=\"language-python\">import pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n</code></pre>\n<p>Lastly, if you'd like to access, say, all the objects inside of a collection (or similar query), we'll just need to add a few lines line to ensure we're reading the collection's data:</p><pre><code class=\"language-python\">import pymongo\nfrom bson.json_util import dumps\nimport json\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\ncol_results = json.loads(dumps(col.find().limit(5).sort(&quot;time&quot;, -1)))\n</code></pre>\n<p>Remember that Mongo returns BSON objects as opposed to JSON objects, which isn't very useful for our purposes. To alleviate this we'll do a messy little dance to convert Mongo's BSON into a string, and convert this to JSON using <strong>json.dumps()</strong>.</p><p><strong>Note: </strong>the need to do this may have been something changed in recent versions of Mongo, as I have older application functioning where this wasn't the case. ¯\\_(ツ)_/¯.</p><h2 id=\"creating-a-form\">Creating a Form</h2><p>Heading over to <strong>form.py, </strong>we just need to set up a simple single-field form for users to submit their URLs. For the sake of Python, let's say we're only accepting URLs for Jupyter noteboooks:</p><pre><code class=\"language-python\">from wtforms import Form, StringField, validators\nfrom wtforms.validators import DataRequired, Regexp\n\nclass myForm(Form):\n    &quot;&quot;&quot;Homepage form.&quot;&quot;&quot;\n    PlotlyURL = StringField('Provide a raw .ipynb URL from Github',\n    validators=[\n            DataRequired(),\n            Regexp(&quot;.*\\.ipynb$&quot;,\n            message=&quot;Please provide a URL ending in ipynb&quot;),\n          ])\n</code></pre>\n<p>We could have an entire tutorial just about Flask's WTF<a href=\"http://flask.pocoo.org/docs/1.0/patterns/wtforms/\">orms</a>, but let's stay on topic  and move on to <strong>currenttime.py.</strong></p><h2 id=\"adding-time-metadata\">Adding Time Metadata</h2><p>In a lot of cases where we store information to a database, we at least want to add certain metadata such as the time something was added. This allows us to arrange results by most recently updated, which we'll be doing in this example.</p><pre><code class=\"language-python\">from datetime import datetime, timezone\n\ndef getTime():\n    &quot;&quot;&quot;Get user's current time&quot;&quot;&quot;\n    rightnow = datetime.today()\n    return rightnow\n\ndef getPrettyTime():\n    &quot;&quot;&quot;Get user's pretty current time&quot;&quot;&quot;\n    rightnow = datetime.today()\n    prettytime = rightnow.ctime()\n    return prettytime\n\nyourtime = getTime()\nprettytime = getPrettyTime()\n</code></pre>\n<p>The variable <strong>yourtime</strong> will be a datetime string representing the local time of the user creating a new record. We will use this value to sort the queried results by time. On the contrary,  <strong>prettytime</strong> will be the same time, only formatted in a way that is readable to humans.</p><h2 id=\"putting-the-pieces-together\">Putting the Pieces Together</h2><p>Finally we get to move on <strong>app.py </strong>and get this thing moving. We'll initiate our app by importing the necessary libraries, as well as the scripts we just created:</p><pre><code class=\"language-python\">from flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n</code></pre>\n<p>Note that we need to import from the DB config we set earlier is the \"col\" variable; we'll only be interacting directly with the collection we want to modify, and the rest is assumed within the config file itself. Now let's build a route for our homepage that does two things:</p><ul><li>Allows users to submit a URL via the simple form we created</li><li>Displays all previous searches by all users.</li></ul><pre><code class=\"language-python\">from flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    recent_searches = list(col_results)\n    return render_template('/index.html', form=myForm(), recents=recent_searches, template=&quot;home-template&quot;)\n</code></pre>\n<p>There's only two significant lines here, but let's break them down piece by piece.</p><h3 id=\"recent_searches\">recent_searches</h3><p>First we set a <strong>recent_searches</strong> variable which is essentially a query against our collection to retrieve a list of previous searches. We ask that these be returned as a <strong>list()</strong> upfront. Typically the <strong>find() </strong>method would contain the constraints of our query, but we're simply asking to return <em>all</em> results in the collection, with a <strong>limit()</strong> up to 5. Finally, we <strong>sort()</strong> the results by the field we refer to as 'time' is descending order, as noted by the -1 argument.</p><p>This is all probably very difficult to visualize without a graphic. Here's a snapshot of the collection we're defining with dummy data added:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2018-07-31-at-11.08.44-AM.png\" class=\"kg-image\"><figcaption>See why we need to differentiate \"time\" and \"prettytime\"?</figcaption></figure><h3 id=\"render_template\">render_template</h3><p>We <a href=\"https://hackersandslackers.com/serving-static-assets-in-flask/\">already know</a> the basics of serving templates and assets in Flask, so it shouldn't be too difficult to break down the last line in our route:</p><ul><li><strong>'/index.html'</strong> specifies the base template we'll be serving up.</li><li><strong>form=myForm()</strong> passes the form class we created earlier to the form partial we're including as part of the index page.</li><li><strong>recents=recent_searches</strong> passes the query of previous searches to the template, with which we can build a widget.</li><li><strong>template=\"home-template\" </strong>is a simple variable passed which we'll utilize as a class on the page we're loading.</li></ul><h2 id=\"the-result\">The Result</h2><p>From everything we've completed, you should be expecting to see a somewhat worthless page where users can submit links via a form, simply to see results posted by previous posters. If we expand on this idea just a bit, we can see how something so simple can actually be extended to a full product: </p><blockquote class=\"embedly-card\" data-card-controls=\"0\"><h4><a href=\"https://planetjupyter.com\">Planet Jupyter</a></h4><p>Style your Jupyter Notebooks.</p></blockquote>\n<script async src=\"//cdn.embedly.com/widgets/platform.js\" charset=\"UTF-8\"></script><p>Planet Jupyter is demo product we built at H&amp;S to style Jupyter notebooks. Perhaps 60% of the logic behind Planet Jupyter is the simple DB interactions we just covered, with the rest being added flair.</p><p>This is not a shameless plug for the barely functioning toys we've built, mind you, but rather an example of simple DB interactions using Flask can be easily extensible into relevant, useful, products.</p><p>We hope you’ve found this tutorial to be useful!</p>","url":"https://hackersandslackers.com/using-mongodb-atlas-as-your-flask-database/","uuid":"e8c92cbd-6845-45b5-acfc-a744810eafcd","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b5cab1e2189c353565a2adf"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736c2","title":"Serving Frontend Assets in Flask","slug":"serving-static-assets-in-flask","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/flaskstatic.jpg","excerpt":"When Python developers manage presentation layers.","custom_excerpt":"When Python developers manage presentation layers.","created_at_pretty":"23 July, 2018","published_at_pretty":"23 July, 2018","updated_at_pretty":"05 April, 2019","created_at":"2018-07-22T23:56:52.000-04:00","published_at":"2018-07-23T06:22:21.000-04:00","updated_at":"2019-04-04T22:10:24.000-04:00","meta_title":"Serving Frontend Assets in Flask | Hackers And Slackers","meta_description":"flask_static_compress is a library for compressing flask assets. It can be considered to be a Python equivalent to Gulp in the context of asset compression.","og_description":"flask_static_compress is a library for compressing flask assets. It can be considered to be a Python equivalent to Gulp in the context of asset compression.","og_image":"https://hackersandslackers.com/content/images/2019/03/flaskstatic.jpg","og_title":"Serving Frontend Assets in Flask","twitter_description":"flask_static_compress is a library for compressing flask assets. It can be considered to be a Python equivalent to Gulp in the context of asset compression.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/flaskstatic.jpg","twitter_title":"Serving Frontend Assets in Flask","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Frontend","slug":"frontend","description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","feature_image":null,"meta_description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","meta_title":"Frontend Development | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"If you're familiar with Django (or Python to any extent), you've probably\naccepted the concept of what Python guys refer to as \"static assets.\" Let's take\na moment to consider this: at some point in Django's conception a design\ndecision was made: all JavaScript, CSS, or  any assets pertaining to the\npresentation layer  belong tucked away into an isolated corner of the framework.\nAlas, it was decreed: henceforward, only two types of code exist in the\nuniverse: Python, and not-Python. Anything that isn't Python is simply a\n\"static\" asset to be dealt with either locally or via a CDN somewhere. \n\nThe implied mindset is both somewhat absurd yet also unsurprising. It's easy to\nimagine a couple of backend nerds nonchalantly writing off frontend development\nas a concept  to be stuck in a single folder. You know, all those things which\nmake an app an app? Like, anything visible to a user? These are simply\nthings-to-be-dealt-with when the frontend guys are ready with their \"make it\npretty\" nonsense. Screw it, throw it all in the /static  folder. We accept this\ndistinction to this day with little thought. Flask has carried over the same\nterminology and concept of a \"static\" folder, so this amusing cultural relic is\nhere to stay.\n\nAnyhow, we're here today to help you serve those beautiful assets of yours, as\nstatic as they may be. We'll do so by exploring the top-two libraries available\nto us: Flask-Static-Compress, and Flask-Assets.\n\nApplication Structure For Flask Apps with Frontend\nBest practices aside, we'll start with the most straightforward project\nstructure for a Flask web app. Let's work with this structure:\n\nmyproject\n├─ /static\n│  └─ /js\n│  └─ /less\n│  └─ /img\n│  └─ /build\n├─ /templates\n└─ app.py\n\n\nAll the Python we need is going to sit in a plump little app.py  file. \n\nTemplates  hold the same concept as they do to equivalent frameworks such as\nExpress: this is where we contain pages, partials, and layouts.  Flask's default\n Jinja2  templating engine has personally served me well enough to never\ninvestigate an alternative.\n\n/Static is where we'll store the raw  source  files for things like preprocessed\nstylesheets and JavaScript. At runtime, these sources files will be compressed\nand stored elsewhere in a production setting, such as that nifty /build  folder\nwe created (or feel free to call it /dist, whatever, it's your party man). \n\nIt's best practice to serve these from a CDN at runtime, but whatever.\n\nIn contrast to NodeJS apps, things like images and fonts are stored in the\n/static folder as well. This distinguishes Python's concept of /static  from,\nsay, another framework's concept of /src: instead of being a folder of only\nsource code, we pretty much have a folder of all that shit which isn't Python. \nAnd we've come full circle.\n\nCreating The Flask App Object\nfrom flask import Flask, url_for, render_template, request, Response\n\napp = Flask(__name__, static_folder=\"static\", template_folder=\"templates\")\n\n\nWe initiate our app on line 4 with app = Flask().  We create our app with three\nparameters/attributes:\n\n * __name__: Now that I think about it, I've never actually considered what this\n   first parameter is doing. Just know that you need it,\n * static_folder: Specifies the name of the folder where static assets will be\n   served. This is based on where your app believes the root folder lives.\n   Because our app is a single directory, it knows that /static  is in the\n   current directory.\n * template_folder: Same as above, but contains Jinja2 templates, AKA the files\n   which become HTML.\n\nIt's important to reiterate that these folders default to being relative to the\ncurrent location of app.py.  If we want to change this behavior, we can pass \ninstance_path=/path/to/desired/dir/  to override this behavior.\n\nMethod 1: Flask-Static-Compress\nThere's more than one way to skin a cat, and there's certainly more than one\nlibrary or philosophy for serving pages and styles in Flask. \nflask_static_compress is one such library, which we'll include in app.py:  \n\nfrom flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n\n\nflask_static_compress [https://github.com/alanhamlett/flask-static-compress]  is\na cool library for compressing and joining assets together. If you've ever used\nGulp, it achieves some of the common tasks Gulp might, but with a MUCH different\nphilosophy. Some key differences are:\n\n * The ability to served compressed assets individually, as opposed to one giant\n   site bundle.\n * Never needing to explicitly fun a build command to create files served at\n   runtime.\n\nBefore serving any assets, we'll need a landing page for our app. While still in\n app.py,  we need to set a route for anybody who visits our site:\n\nfrom flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n\napp = Flask(__name__, static_folder=\"static\", template_folder=\"templates\")\n\n@app.route('/', methods=['GET'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    return render_template('/index.html', title=\"Lame Site\")\n\n\nOur route listens for traffic hitting \"/\" (our root directory) and kindly serves\nthem the page index.html  as you might expect. Because we set the value of \ntemplates_folder  just now, Flask knows to serve a file living in /\ntemplates/index.html. \n\nIf you need some pointers on creating basic templates in Flask in which to load\nyour frontend assets, I'd suggest taking a look back at the previous post.\n\nFrontend YOLO Swag\nBack to your project, make .less  file and a .js  file in the appropriate\nplaces:\n\nmyproject\n├─ /build\n├─ /static\n│  └─ js\n│  │  └─ main.js\n│  └─ less\n│  │  └─ style.js\n│  └─ img\n├─ /templates\n│  └─ layout.html\n│  └─ index.html\n└─ app.py\n\n\nUse these files to brand your site accordingly. Add some images, memes,\npropaganda, viruses, etc. Whatever your heart desires.\n\nBack in app.py  we need to finish configuring our library:\n\nfrom flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n\napp = Flask(__name__)\napp.config['COMPRESSOR_DEBUG'] = app.config.get('DEBUG')\napp.config['COMPRESSOR_STATIC_PREFIX'] = 'static'\napp.config['COMPRESSOR_OUTPUT_DIR'] = 'build'\napp.static_folder = 'static'\ncompress = FlaskStaticCompress(app)\n\n\n@app.route('/', methods=['GET'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    return render_template('/index.html', title=\"Lame Site\")\n\n\nCongrats! the main part of your application is pretty much done, just note a few\nthings:\n\n * Notice this time we set our folder paths via app.config[]  as opposed to\n   inline, in the earlier example. This is simply a matter of preference.\n * compress = FlaskStaticCompress(app) initializes our library, so definitely do\n   that.\n * Fun tidbit: app.static_folder = 'static' is a snippet which can live within\n   any route to override  the default app settings for where your folders are\n   located. \n\nCompressed 2 deff\nLet's wrap this bad boy up. Back in layout.html, let's add those static files we\ncreated.\n\n<!doctype html>\n<html>\n<head>\n  <title>{% block title %}{% endblock %} - My Lame Site</title>\n  <!-- Meta Data -->\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\">\n    \n  <!-- CSS -->\n  {% compress 'css' %}\n     <link href=\"{{ url_for('static', filename='less/home.less') }}\" type=\"text/less\">\n  {% endcompress %}\n    \n  <!-- JS -->\n    {% compress 'js' %}\n      <script src=\"{{ url_for('static', filename='js/previews.js') }}\"></script>\n\t{% endcompress %}\n</head>\n<body>\n  {% block content %}{% endblock %}\n</body>\n</html>\n\n\nLet's analyze this real quick:\n\n{% compress 'css' %}\n   <link href=\"{{ url_for('static', filename='less/home.less') }}\" type=\"text/less\">\n{% endcompress %}\n\n\nAll files within the {% compress 'css' %}  block will be minified and joined\ninto a single file, and then moved to the build folder we specified earlier.\nIt's that easy- no jobs to run beforehand, etc.\n\nWhat might also catch your eye is how we define the path:\n\n{{ url_for('static', filename='less/home.less') }}\n\n\nThis is a Jinja path dynamically locating our source file from our specified\nstatic doc. Well, I'll be darned.\n\nMethod 2: Flask-Assets\nFlaskStaticCompress  is great, but Flask_assets\n[http://flask-assets.readthedocs.io/en/latest/]  might even be better. If you're\nfamiliar with Webpack, consider the philosophy behind bundling.  Creating \nbundles  of frontend assets makes sense when we can draw clear distinctions of\nalike-screens in our app: this way, users don't download the entirety of our\nassets for screens they might not visit upfront, while pre-loading assets for\npages they'll probably  visit.\n\nThe Flask-Assets  library goes hand-in-hand with the concept of Flask Blueprints\n. If you aren't familiar with Blueprints just yet, I encourage you to become\nfamiliar here [https://hackersandslackers.com/structuring-your-flask-app/].\n\nTo get started, we'll install the necessary libraries:\n\n$ pip3 install flask-assets lesscpy cssmin jsmin\n\n\nThis is working under the assumption that we're be writing styles in LESS. If\nyou prefer sass, libsass  can take the place of lesscpy.\n\nThe other two libraries, cssmin  and jsmin, are for minifying CSS and JS assets\nrespectively.\n\nLet's see how we pull this off:\n\n...\nfrom flask_assets import Environment, Bundle\n\n\n# Flask-Assets Configuration\nless_bundle = Bundle('src/less/*.less',\n                     filters='less,cssmin',\n                     output='dist/css/account.css',\n                     extra={'rel': 'stylesheet/less'})\njs_bundle = Bundle('src/js/*.js',\n                   filters='jsmin',\n                   output='dist/js/main.min.js')\nassets.register('less_all', less_bundle)\nassets.register('js_all', js_bundle)\nless_bundle.build()\njs_bundle.build()\n``\n\nNotice how we only import flask_assets of all the libraries we installed- this\nis intentional. The other libraries do not need to be imported anywhere.\n\nless_bundle  and js_bundle  represent groupings of LESS and JS files to be\nstitched into one single file. Any positional arguments to be passed in to \nBundle()  will be taken as paths of sources files to bundle: we can bundle as\nmany or as few files as we want (or in our case , just import *).\n\nThe filters  argument is where we tell our Bundle()  how to treat the files\nwe've passed. In the case of less_bundle, passing less,cssmin  indicates that\nthe incoming files will be LESS files, to be compiled into CSS files, and then\noutputted as minified CSS files. the output destination, of course, is handled\nby the argument output.\n\nFinal Thoughts\nThe great thing about Flask (and Python in general) is that you're provided the\nluxury to write code in a manner which you find enjoyable. Considering Flask is\na relatively young framework, we're in a bit of a golden age where there are\njust enough libraries to suit your tastes, but not enough to get lost in an NPM\nlevel hell.\n\nIn my completely biased and untrustworthy opinion, it's hard to imagine getting\ninvolved with a Framework in a sweeter spot than where Flask is right now.","html":"<p>If you're familiar with Django (or Python to any extent), you've probably accepted the concept of what Python guys refer to as \"static assets.\" Let's take a moment to consider this: at some point in Django's conception a design decision was made: all <em>JavaScript</em>, <em>CSS</em>, or<em> any assets pertaining to the presentation layer</em> belong tucked away into an isolated corner of the framework. Alas, it was decreed: henceforward, only two types of code exist in the universe: Python, and not-Python. Anything that isn't Python is simply a \"static\" asset to be dealt with either locally or via a CDN somewhere. </p><p>The implied mindset is both somewhat absurd yet also unsurprising. It's easy to imagine a couple of backend nerds nonchalantly writing off <em>frontend development as a concept</em> to be stuck in a single folder. You know, all those things which make an app an app? Like, anything visible to a user? These are simply things-to-be-dealt-with when the frontend guys are ready with their \"make it pretty\" nonsense. Screw it, throw it all in the <strong>/static</strong> folder. We accept this distinction to this day with little thought. Flask has carried over the same terminology and concept of a \"static\" folder, so this amusing cultural relic is here to stay.</p><p>Anyhow, we're here today to help you serve those beautiful assets of yours, as static as they may be. We'll do so by exploring the top-two libraries available to us: <strong>Flask-Static-Compress</strong>, and <strong>Flask-Assets</strong>.</p><h2 id=\"application-structure-for-flask-apps-with-frontend\">Application Structure For Flask Apps with Frontend</h2><p>Best practices aside, we'll start with the most straightforward project structure for a Flask web app. Let's work with this structure:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">myproject\n├─ /static\n│  └─ /js\n│  └─ /less\n│  └─ /img\n│  └─ /build\n├─ /templates\n└─ app.py\n</code></pre>\n<!--kg-card-end: markdown--><p>All the Python we need is going to sit in a plump little <strong>app.py</strong><em> </em>file. </p><p><strong>Templates</strong> hold the same concept as they do to equivalent frameworks such as Express: this is where we contain <em>pages</em>, <em>partials</em>, and <em>layouts.</em> Flask's default <strong>Jinja2</strong> templating engine has personally served me well enough to never investigate an alternative.</p><p><strong>/Static </strong>is where we'll store the <em>raw</em> <em>source</em> files for things like preprocessed stylesheets and JavaScript. At runtime, these sources files will be compressed and stored elsewhere in a production setting, such as that nifty <strong>/build</strong> folder we created (or feel free to call it <em>/dist</em>, whatever, it's your party man). </p><p>It's best practice to serve these from a CDN at runtime, but whatever.</p><p>In contrast to NodeJS apps, things like images and fonts are stored in the /static folder as well. This distinguishes Python's concept of /<em>static</em> from, say, another framework's concept of /<em>src: </em>instead of being a folder of only source code, we pretty much have a folder of <em>all that shit which isn't Python. </em>And we've come full circle.</p><h2 id=\"creating-the-flask-app-object\">Creating The Flask App Object</h2><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, url_for, render_template, request, Response\n\napp = Flask(__name__, static_folder=&quot;static&quot;, template_folder=&quot;templates&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>We initiate our app on line 4 with <code>app = Flask()</code>.  We create our app with three parameters/attributes:</p><ul><li><code>__name__</code>: Now that I think about it, I've never actually considered what this first parameter is doing. Just know that you need it,</li><li><code>static_folder</code>: Specifies the name of the folder where static assets will be served. This is based on where your app believes the root folder lives. Because our app is a single directory, it knows that /<em>static</em> is in the current directory.</li><li><code>template_folder</code>: Same as above, but contains Jinja2 templates, AKA the files which become HTML.</li></ul><p>It's important to reiterate that these folders default to being <em>relative to the current location of </em><strong>app.py</strong><em>.</em> If we want to change this behavior, we can pass <code>instance_path=/path/to/desired/dir/</code> to override this behavior.</p><h2 id=\"method-1-flask-static-compress\">Method 1: Flask-Static-Compress</h2><p>There's more than one way to skin a cat, and there's certainly more than one library or philosophy for serving pages and styles in Flask. <strong>flask_static_compress </strong>is one such library, which we'll include in <strong>app.py</strong><em>:</em> </p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n</code></pre>\n<!--kg-card-end: markdown--><p><strong><a href=\"https://github.com/alanhamlett/flask-static-compress\">flask_static_compress</a></strong> is a cool library for compressing and joining assets together. If you've ever used Gulp, it achieves some of the common tasks Gulp might, but with a MUCH different philosophy. Some key differences are:</p><ul><li>The ability to served compressed assets individually, as opposed to one giant site bundle.</li><li>Never needing to explicitly fun a build command to create files served at runtime.</li></ul><p>Before serving any assets, we'll need a landing page for our app. While still in <strong>app.py,</strong> we need to set a route for anybody who visits our site:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n\napp = Flask(__name__, static_folder=&quot;static&quot;, template_folder=&quot;templates&quot;)\n\n@app.route('/', methods=['GET'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    return render_template('/index.html', title=&quot;Lame Site&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Our route listens for traffic hitting \"/\" (our root directory) and kindly serves them the page <strong>index.html</strong> as you might expect. Because we set the value of <code>templates_folder</code> just now, Flask knows to serve a file living in /<strong>templates/index.html</strong>. </p><p>If you need some pointers on creating basic templates in Flask in which to load your frontend assets, I'd suggest taking a look back at the previous post.</p><h3 id=\"frontend-yolo-swag\">Frontend YOLO Swag</h3><p>Back to your project, make <strong>.less</strong> file and a <strong>.js</strong> file in the appropriate places:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">myproject\n├─ /build\n├─ /static\n│  └─ js\n│  │  └─ main.js\n│  └─ less\n│  │  └─ style.js\n│  └─ img\n├─ /templates\n│  └─ layout.html\n│  └─ index.html\n└─ app.py\n</code></pre>\n<!--kg-card-end: markdown--><p>Use these files to brand your site accordingly. Add some images, memes, propaganda, viruses, etc. Whatever your heart desires.</p><p>Back in <strong>app.py</strong><em> </em>we need to finish configuring our library:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, url_for, render_template, request, Response\nfrom flask_static_compress import FlaskStaticCompress\n\napp = Flask(__name__)\napp.config['COMPRESSOR_DEBUG'] = app.config.get('DEBUG')\napp.config['COMPRESSOR_STATIC_PREFIX'] = 'static'\napp.config['COMPRESSOR_OUTPUT_DIR'] = 'build'\napp.static_folder = 'static'\ncompress = FlaskStaticCompress(app)\n\n\n@app.route('/', methods=['GET'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    return render_template('/index.html', title=&quot;Lame Site&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Congrats! the main part of your application is pretty much done, just note a few things:</p><ul><li>Notice this time we set our folder paths via <em><strong>app.config[]</strong></em> as opposed to inline, in the earlier example. This is simply a matter of preference.</li><li><strong>compress = FlaskStaticCompress(app) </strong>initializes our library, so definitely do that.</li><li>Fun tidbit: <strong>app.static_folder = 'static' </strong>is a snippet which can live within any route to <em>override</em> the default app settings for where your folders are located. </li></ul><h2 id=\"compressed-2-deff\">Compressed 2 deff</h2><p>Let's wrap this bad boy up. Back in layout.html, let's add those static files we created.</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;{% block title %}{% endblock %} - My Lame Site&lt;/title&gt;\n  &lt;!-- Meta Data --&gt;\n  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;\n    \n  &lt;!-- CSS --&gt;\n  {% compress 'css' %}\n     &lt;link href=&quot;{{ url_for('static', filename='less/home.less') }}&quot; type=&quot;text/less&quot;&gt;\n  {% endcompress %}\n    \n  &lt;!-- JS --&gt;\n    {% compress 'js' %}\n      &lt;script src=&quot;{{ url_for('static', filename='js/previews.js') }}&quot;&gt;&lt;/script&gt;\n\t{% endcompress %}\n&lt;/head&gt;\n&lt;body&gt;\n  {% block content %}{% endblock %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Let's analyze this real quick:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% compress 'css' %}\n   &lt;link href=&quot;{{ url_for('static', filename='less/home.less') }}&quot; type=&quot;text/less&quot;&gt;\n{% endcompress %}\n</code></pre>\n<!--kg-card-end: markdown--><p>All files within the <code>{% compress 'css' %}</code> block will be minified and joined into a single file, and then moved to the build folder we specified earlier. It's that easy- no jobs to run beforehand, etc.</p><p>What might also catch your eye is how we define the path:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{{ url_for('static', filename='less/home.less') }}\n</code></pre>\n<!--kg-card-end: markdown--><p>This is a Jinja path dynamically locating our source file from our specified static doc. Well, I'll be darned.</p><h2 id=\"method-2-flask-assets\">Method 2: Flask-Assets</h2><p><strong>FlaskStaticCompress</strong> is great, but <strong><a href=\"http://flask-assets.readthedocs.io/en/latest/\">Flask_assets</a> </strong>might even be better. If you're familiar with Webpack, consider the philosophy behind <em>bundling.</em> Creating <em>bundles</em> of frontend assets makes sense when we can draw clear distinctions of alike-screens in our app: this way, users don't download the entirety of our assets for screens they might not visit upfront, while pre-loading assets for pages they'll <em>probably</em> visit.</p><p>The <strong>Flask-Assets</strong> library goes hand-in-hand with the concept of Flask <strong>Blueprints</strong>. If you aren't familiar with Blueprints just yet, I encourage you to become familiar <a href=\"https://hackersandslackers.com/structuring-your-flask-app/\">here</a>.</p><p>To get started, we'll install the necessary libraries:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ pip3 install flask-assets lesscpy cssmin jsmin\n</code></pre>\n<!--kg-card-end: markdown--><p>This is working under the assumption that we're be writing styles in LESS. If you prefer sass, <strong>libsass</strong> can take the place of <strong>lesscpy</strong>.</p><p>The other two libraries, <strong>cssmin</strong> and <strong>jsmin</strong>, are for minifying CSS and JS assets respectively.</p><p>Let's see how we pull this off:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">...\nfrom flask_assets import Environment, Bundle\n\n\n# Flask-Assets Configuration\nless_bundle = Bundle('src/less/*.less',\n                     filters='less,cssmin',\n                     output='dist/css/account.css',\n                     extra={'rel': 'stylesheet/less'})\njs_bundle = Bundle('src/js/*.js',\n                   filters='jsmin',\n                   output='dist/js/main.min.js')\nassets.register('less_all', less_bundle)\nassets.register('js_all', js_bundle)\nless_bundle.build()\njs_bundle.build()\n``</code></pre>\n<!--kg-card-end: markdown--><p>Notice how we only import flask_assets of all the libraries we installed- this is intentional. The other libraries do not need to be imported anywhere.</p><p><strong>less_bundle</strong> and <strong>js_bundle</strong> represent groupings of LESS and JS files to be stitched into one single file. Any positional arguments to be passed in to <code>Bundle()</code> will be taken as paths of sources files to bundle: we can bundle as many or as few files as we want (or in our case , just import *).</p><p>The <strong>filters</strong> argument is where we tell our <code>Bundle()</code> how to treat the files we've passed. In the case of <strong>less_bundle, </strong>passing <code>less,cssmin</code> indicates that the incoming files will be LESS files, to be compiled into CSS files, and then outputted as minified CSS files. the output destination, of course, is handled by the argument <code>output</code>.</p><h2 id=\"final-thoughts\">Final Thoughts</h2><p>The great thing about Flask (and Python in general) is that you're provided the luxury to write code in a manner which you find enjoyable. Considering Flask is a relatively young framework, we're in a bit of a golden age where there are just enough libraries to suit your tastes, but not enough to get lost in an NPM level hell.</p><p>In my completely biased and untrustworthy opinion, it's hard to imagine getting involved with a Framework in a sweeter spot than where Flask is right now. </p>","url":"https://hackersandslackers.com/serving-static-assets-in-flask/","uuid":"d1c8d104-6392-411b-86d4-75326e8e0960","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b5552047c9c156d9440c0ae"}}]}},"pageContext":{"slug":"flask","limit":12,"skip":0,"numberOfPages":2,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":2,"previousPagePath":null,"nextPagePath":"/tag/flask/page/2/"}}