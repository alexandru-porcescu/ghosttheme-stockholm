{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736ee","title":"Structuring Your Flask Application","slug":"structuring-your-flask-app","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","excerpt":"Leverage Blueprints, Flask-Assets, and the Application Factory.","custom_excerpt":"Leverage Blueprints, Flask-Assets, and the Application Factory.","created_at_pretty":"02 September, 2018","published_at_pretty":"15 October, 2018","updated_at_pretty":"23 February, 2019","created_at":"2018-09-02T03:02:29.000-04:00","published_at":"2018-10-15T08:00:00.000-04:00","updated_at":"2019-02-23T11:21:49.000-05:00","meta_title":"Structuring your Flask Application | Hackers and Slackers","meta_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","og_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","og_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","og_title":"Structuring your Flask App Like an Adult | Hackers and Slackers","twitter_description":"Follow best practices when building your Flask apps. Leverage Blueprints, Flask-Assets, and the Application Factory.","twitter_image":"https://hackersandslackers.com/content/images/2018/09/flaskblueprints2@2x.jpg","twitter_title":"Structuring your Flask App Like an Adult | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"When we first started developing in Flask, most of us took the 5 lines of code\nin the quick-start guide and ran with it. Compared to every other web framework,\ngetting a \"Hello world\" to flash on screen without being hassled with database\nconfigurations, template preferences, or reverse proxy setups felt a lot like\nrobbing a bank.\n\nAt some point or another, we inevitably pause the party and take a look around.\nAll of our views are smashed into a single file named something meaningless like\n app.py. All logic lives in the root directory. We're in our 30s and the app\nwe've just created looks as terrible as our bathrooms. It's time to get our shit\ntogether.\n\nThe Flask Application Factory\nThe overwhelming preference to start a Flask application is to use a structure\ndubbed the Application Factory\n[http://flask.pocoo.org/docs/1.0/patterns/appfactories/]. The gist is to keep\nthe initialization preferences of our application in a single __init__.py  file,\nsometimes borrowing help from peer files such as db.py  or models.py. Either\nway, the gist is to keep global logic separated from the other parts.\n\nA simple app using the application factory method might look something like\nthis:\n\n[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── views.py\n│   ├── static/\n│   └── templates/\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n\n\nThe main takeaway here being the presence of the myapp  directory which now\nhouses our app logic, and the presence of our good friend __init__.py.\n\nAn example of what might live in __init.py__  could be something like this:\n\nimport os\nimport sys\nfrom flask import Flask, g\nfrom config import BaseConfig\nfrom flask_login import LoginManager\nfrom flask_pymongo import PyMongo\n\n\ndef create_app():\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_object('config.BaseConfig')\n    login = LoginManager()\n\n    with app.app_context():\n        from . import views\n        from . import auth\n        login.init_app(app)\n        mongo = PyMongo(app, app.config['MONGO_URI'])\n        app.register_blueprint(views.main)\n        app.register_blueprint(admin.admin)\n\n        return app\n\n\nHere we initialize our app and the dependencies we'd like to initialize within a\nsingle function. Most familiar might be the first two lines of our function: The\nfirst creating our app object, and the second loading a config from a class in a\nconfig file.\n\nAnother common practice is to keep libraries which need to run init_app  in this\nfile as well. This could be something like the LoginManager  seen in the example\nabove, or a global database configuration. Lastly, this is also where we would\nregister any Blueprints  as well.\n\nUsing Blueprints in Flask\nWhile the Application Factory is an excellent first step to building cohesive\napps, we haven't solved the problem of organizing our app into separation of\nconcerns. Blueprints  are a way for us to separate our app into parts which\nshare very little with one another. Prime examples would include apps with an \nadmin  panel with an accompanying client-facing  side, or apps where the \"logged\nin\" state is vastly different from the app's \"logged out\"  state. In these\ncases, it seems silly to mix both logic and static assets into a single lump,\nwhich is where Blueprints come in.\n\nNOTE:  If you're a Django person and this is all starting to sound familiar,\nthat's because we can equate Flask's Blueprints  to Django's concept of apps. \nThere are differences and added flexibility, but the concept remains the same.\n\nRegistering a part of your app as a Blueprint begins with the following two\nlines:\n\nfrom flask import Blueprint\n\nauth = Blueprint('auth', __name__)\n\n\nWhen we registered the admin  Blueprint previously in __init__.py, the line \napp.register_blueprint(admin.admin)  is essentially saying \"look for a Blueprint \n named admin  in a module (either file or folder structure) called admin.\"  It's\nimportant not to overlook the concept that Blueprints can either be single files\nor entirely standalone file structures with their own templates and static\nfiles.  For instance, a Flask app with completely decoupled Blueprints might be\nstructured as follows:\n\n[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── admin/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/\n│   ├── frontend/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/  \n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   └── views.py\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n        \n\n\nIn the case above, each Blueprint  stands as though it were its own Python\nmodule. Each blueprint contains its own logic, templates, and static files -\npresumably encapsulated in a way which makes sense.\n\nUsing Flask-Assets with Blueprints\nWe've already forced a lot of information down your throat, but there's one last\nthing worth mentioning in this overview of working with Blueprints, which is\nworking with assets. We've previously looked at the Flask-Static-Compress \nlibrary for static asset management, but Blueprints  lend themselves better to \nFlask-Assets  way of thinking.\n\nFlask-Assets  is a library which creates a bundle (aka compressed) of assets\nupfront. Thus, the start of a Blueprint definition might now look something like\nthis:\n\nfrom flask import Blueprint\nfrom flask_assets import Environment, Bundle, build\nimport sass\n\nauth = Blueprint('admin', __name__)\n\nassets = Environment(admin)\nscss = Bundle('scss/main.scss', 'scss/forms.scss', filters='libsass', output='build/css/style.css')\nassets.register('scss_all', scss)\nscss.build()\n\n\nEnvironment  states the context of our asset bundle, which is admin, the current\nBlueprint. \n\nBundle  takes any number of files to compressed together as arguments. Then we\nmust pass the type of \"filter\" the assets are (typically a precompiler) and of\ncourse an output destination for the Bundle.\n\n.register()  registers the bundle we just created, not unlike the way we\nregistered our Blueprint.\n\n.build()  must be called explicitly in order to build the bundle at runtime.\nConversely, we could intentionally exclude .build()  if we expect our assets are\nnot to change.\n\nAnd Now You Know Everything\n...or not, really. The most we should take from this post is:\n\n * There's a better way to structure our apps.\n * There are many potential decisions we can make about the structure of our\n   app.\n * There's way more stuff we need to Google or look up on StackOverflow.\n\nTruthfully, there are plenty of resources within Flask's documentation\n[http://flask.pocoo.org/docs/1.0/tutorial/views/#]  or around the internet that\ncovers the topic of Flask app organization and its granular topics more than\nthis single post could ever hope to. Nonetheless, here's to hoping you're\nfeeling a sense of direction in these crazy, adult lives of ours.","html":"<p>When we first started developing in Flask, most of us took the 5 lines of code in the quick-start guide and ran with it. Compared to every other web framework, getting a \"Hello world\" to flash on screen without being hassled with database configurations, template preferences, or reverse proxy setups felt a lot like robbing a bank.</p><p>At some point or another, we inevitably pause the party and take a look around. All of our views are smashed into a single file named something meaningless like <code>app.py</code>. All logic lives in the root directory. We're in our 30s and the app we've just created looks as terrible as our bathrooms. It's time to get our shit together.</p><h2 id=\"the-flask-application-factory\">The Flask Application Factory</h2><p>The overwhelming preference to start a Flask application is to use a structure dubbed the <a href=\"http://flask.pocoo.org/docs/1.0/patterns/appfactories/\">Application Factory</a>. The gist is to keep the initialization preferences of our application in a single <code>__init__.py</code> file, sometimes borrowing help from peer files such as <code>db.py</code> or <code>models.py</code>. Either way, the gist is to keep global logic separated from the other parts.</p><p>A simple app using the application factory method might look something like this:</p><pre><code class=\"language-shell\">[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   ├── views.py\n│   ├── static/\n│   └── templates/\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n</code></pre>\n<p>The main takeaway here being the presence of the <strong>myapp</strong> directory which now houses our app logic, and the presence of our good friend <code>__init__.py</code>.</p><p>An example of what might live in <code>__init.py__</code> could be something like this:</p><pre><code class=\"language-python\">import os\nimport sys\nfrom flask import Flask, g\nfrom config import BaseConfig\nfrom flask_login import LoginManager\nfrom flask_pymongo import PyMongo\n\n\ndef create_app():\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_object('config.BaseConfig')\n    login = LoginManager()\n\n    with app.app_context():\n        from . import views\n        from . import auth\n        login.init_app(app)\n        mongo = PyMongo(app, app.config['MONGO_URI'])\n        app.register_blueprint(views.main)\n        app.register_blueprint(admin.admin)\n\n        return app\n</code></pre>\n<p>Here we initialize our app and the dependencies we'd like to initialize within a single function. Most familiar might be the first two lines of our function: The first creating our app object, and the second loading a config from a class in a config file.</p><p>Another common practice is to keep libraries which need to run <code>init_app</code> in this file as well. This could be something like the <code>LoginManager</code> seen in the example above, or a global database configuration. Lastly, this is also where we would register any <strong>Blueprints</strong> as well.</p><h2 id=\"using-blueprints-in-flask\">Using Blueprints in Flask</h2><p>While the Application Factory is an excellent first step to building cohesive apps, we haven't solved the problem of organizing our app into <em>separation of concerns</em>. <strong>Blueprints</strong> are a way for us to separate our app into parts which share very little with one another. Prime examples would include apps with an <em>admin</em> panel with an accompanying <em>client-facing</em> side, or apps where the \"<em>logged in\" </em>state is vastly different from the app's \"<em>logged out\"</em> state. In these cases, it seems silly to mix both logic and static assets into a single lump, which is where Blueprints come in.</p><p><strong>NOTE:</strong> If you're a Django person and this is all starting to sound familiar, that's because we can equate Flask's <strong>Blueprints</strong> to Django's concept of <strong>apps.</strong> There are differences and added flexibility, but the concept remains the same.</p><p>Registering a part of your app as a Blueprint begins with the following two lines:</p><pre><code class=\"language-python\">from flask import Blueprint\n\nauth = Blueprint('auth', __name__)\n</code></pre>\n<p>When we registered the <code>admin</code> Blueprint previously in <code>__init__.py</code>, the line <code>app.register_blueprint(admin.admin)</code> is essentially saying \"look for a <strong>Blueprint</strong> named <em>admin</em> in a module (either file or folder structure) called <em>admin.\"</em> It's important not to overlook the concept that Blueprints can either be single files or <em>entirely standalone file structures with their own templates and static files.</em> For instance, a Flask app with completely decoupled Blueprints might be structured as follows:</p><pre><code class=\"language-shell\">[app]\n├── myapp/\n│   ├── __init__.py\n│   ├── admin/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/\n│   ├── frontend/\n│   │    ├── __init__.py\n│   │    ├── views.py\n│   │    ├── forms.py\n│   │    ├── static/\n│   │\t └── templates/  \n│   ├── db.py\n│   ├── forms.py\n│   ├── models.py\n│   └── views.py\n├── config.py\n├── requirements.txt\n├── setup.py\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── app.json\n└── wsgi.py\n        \n</code></pre>\n<p>In the case above, each <strong>Blueprint</strong> stands as though it were its own Python module. Each blueprint contains its own logic, templates, and static files - presumably encapsulated in a way which makes sense.</p><h2 id=\"using-flask-assets-with-blueprints\">Using Flask-Assets with Blueprints</h2><p>We've already forced a lot of information down your throat, but there's one last thing worth mentioning in this overview of working with <strong>Blueprints, </strong>which is working with assets. We've previously looked at the <code>Flask-Static-Compress</code> library for static asset management, but <strong>Blueprints</strong> lend themselves better to <code>Flask-Assets</code> way of thinking.</p><p><code>Flask-Assets</code> is a library which creates a bundle (aka compressed) of assets upfront. Thus, the start of a Blueprint definition might now look something like this:</p><pre><code class=\"language-shell\">from flask import Blueprint\nfrom flask_assets import Environment, Bundle, build\nimport sass\n\nauth = Blueprint('admin', __name__)\n\nassets = Environment(admin)\nscss = Bundle('scss/main.scss', 'scss/forms.scss', filters='libsass', output='build/css/style.css')\nassets.register('scss_all', scss)\nscss.build()\n</code></pre>\n<p><code>Environment</code> states the context of our asset bundle, which is admin, the current Blueprint. </p><p><code>Bundle</code> takes any number of files to compressed together as arguments. Then we must pass the type of \"filter\" the assets are (typically a precompiler) and of course an output destination for the Bundle.</p><p><code>.register()</code> registers the bundle we just created, not unlike the way we registered our Blueprint.</p><p><code>.build()</code> must be called explicitly in order to build the bundle at runtime. Conversely, we could intentionally exclude <code>.build()</code> if we expect our assets are not to change.</p><h2 id=\"and-now-you-know-everything\">And Now You Know Everything</h2><p>...or not, really. The most we should take from this post is:</p><ul><li>There's a better way to structure our apps.</li><li>There are many potential decisions we can make about the structure of our app.</li><li>There's way more stuff we need to Google or look up on StackOverflow.</li></ul><p>Truthfully, there are plenty of resources within <a href=\"http://flask.pocoo.org/docs/1.0/tutorial/views/#\">Flask's documentation</a> or around the internet that covers the topic of Flask app organization and its granular topics more than this single post could ever hope to. Nonetheless, here's to hoping you're feeling a sense of direction in these crazy, adult lives of ours.</p>","url":"https://hackersandslackers.com/structuring-your-flask-app/","uuid":"4345eb76-e1ce-471a-94b9-f06a43c3ad27","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b8b8b05852e5c07171fcab7"}},"pageContext":{"slug":"structuring-your-flask-app"}}