{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673665","title":"Stitch's “Query Anywhere”: Executing Business Logic via Frontend","slug":"mongodb-stitch-query-anywhere","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/06/stitch5@2x.jpg","excerpt":"MongoDB Stitch vs the impossible: secure database queries via frontend JS.","custom_excerpt":"MongoDB Stitch vs the impossible: secure database queries via frontend JS.","created_at_pretty":"02 June, 2018","published_at_pretty":"23 November, 2018","updated_at_pretty":"05 January, 2019","created_at":"2018-06-02T12:07:57.000-04:00","published_at":"2018-11-23T07:00:00.000-05:00","updated_at":"2019-01-04T21:09:07.000-05:00","meta_title":"MongoDB Stitch \"Query Anywhere\" | Hackers and Slackers","meta_description":"Use MongoDB Stitch to query databases via Frontend code.","og_description":"Use MongoDB Stitch to query databases via Frontend code.","og_image":"https://hackersandslackers.com/content/images/2018/06/stitch5@2x.jpg","og_title":"MongoDB Stitch \"Query Anywhere\"","twitter_description":"Use MongoDB Stitch to query databases via Frontend code.","twitter_image":"https://hackersandslackers.com/content/images/2018/06/stitch5@2x.jpg","twitter_title":"MongoDB Stitch \"Query Anywhere\"","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},{"name":"Frontend","slug":"frontend","description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","feature_image":null,"meta_description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","meta_title":"Frontend Development | Hackers and Slackers","visibility":"public"},{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},{"name":"#MongoDB Cloud","slug":"mongodb-cloud","description":"All you need to know about MongoDB’s official cloud offering. Dive into MongoDB Atlas, or the architecture & microservices provided by MongoDB Stitch.","feature_image":"https://hackersandslackers.com/content/images/2019/03/mongodbcloudseries.jpg","meta_description":"All you need to know about MongoDB’s official cloud offering. Dive into MongoDB Atlas, or the architecture & microservices provided by MongoDB Stitch.","meta_title":"MongoDB Cloud","visibility":"internal"}],"plaintext":"Some tools are simply the right tool for the job. I imagine this must have been\nthe thinking behind the wave of JSON-like NoSQL databases at their peak, and\neven so today. If we figure we’ll be passing information as JSON to an endpoint,\nto then have it structured into a schema, only to be promptly broken down again\nfor our request seconds later, if you will, it’s fair to question the\ncost-benefit of schemas in some cases. A lot of those cases cover the apps we\nbuild for ourselves: ones that let us do stupid things like spamming selfies or\nfilling the internet with vast mindless thoughts.\n\nMongoDB Atlas  is a hell of product in its own right, being a cloud NoSQL\ndatabase with the ability to execute queries similar to SQL JOINs, countless\naggregations, and more possibilities to work into a pipeline than I’ve even had\ntime to explore (we’ll get there). If you’ve ever been tasked to build endpoints\nfor yourself, chances are you already appreciate side-stepping the manual\none-to-one key association that comes with passing JSON to Lambda Functions or\nwhat-have-you.\n\nTake our situation at Hackers And Slackers, for instance. We’re running a Ghost\nblog, which is a young piece of software built by a non-profit organization:\nthis software is constantly being updated and improved, which means if we want\nto modify the logic of our Node app at all, our choices are:\n\n 1. Modify the Ghost source and refuse future updates\n 2. Merge our custom backend with Ghost changes in the event of an update\n 3. Build a third-party API using a platform such as AWS\n\nMongoDB Stitch  gives us a new fourth option: extend our app without all the\nrepetitive boilerplate.  I say extend  because it empowers us to build on top of\nthings which were previously black-boxed to us, such developing a theme atop a\nblogging system.\n\nCarrying on the Legacy\nMongoDB Stitch extends the philosophy of avoiding repetition. In a similar way\nto how NoSQL removed a pain point for many developers, Stitch wants you to keep\ndoing what you do best, which is probably writing NodeJS apps. Forever.\n\nIf I worked for Mongo, I’d sell the product like this:\n\nMongoDB Stitch empowers you to build powerful features without ever switching\ngears to the menial aspects of development.What I’m really saying is that MongoDB Stitch  is Google Firebase. Both products\ntarget the frontend  and mobile  developer markets, and both are very young and\nearly in fully achieving this goal. I’m watching the MongoDB product video for\nthe first time, and it feels like what I’ve assumed from using the product\naligns with their sell (good job on their part, I suppose):\n\nAs warm and uppity as that video is, Mongo has been rather bashful about their\nCloud. I'm guessing that has something to do with an IPO.\n\nOn the other hand, Google Firebase  has been tooting its own horn loudly for a\nyoung product, with a level of growth which feels almost reckless at times (I\nwon't get into it):\n\nAnyway, we're not here to compare. We're here to judge.\n\nGetting Started with a New Database\nFeel free to follow along by setting up a free tier cluster\n[https://docs.mongodb.com/manual/tutorial/atlas-free-tier-setup/]. \n\nProper Mongo accounts are managed at https://cloud.mongodb.com  once created.\nThis landing dash has plenty of useful info and stats regarding the cluster\nitself. We'll also need to be sure that a database exists before we crate any\napps, otherwise we'll just be interacting with nothing.\n\nI highly  suggest using the MongoDB Compass  desktop app to connect to your your\ncluster. It's easy to download, and even saves you the time of entering\ncredentials by connecting with a copy+pasted URI:\n\nConnect with your database; emotionally.Within Compass, simply create a database\nand collection:\n\nIn MongoWorld, \"collections\" are the equivalent of \"tables\".Let's Get Stitched\nWith all that out of the way, head back to your account on the Mongo Cloud. Now\nour interest is entirely in the Stitch Apps  link on the left side nav:\n\nThere’s so much to explore!Create and name a new Stitch application, and we'll\nland on the \"getting started\" page. \n\nEnable anonymous auth & point to your collectionOnce we create our app, Stitch\nimmediately throws us in to a quick 101 of how to interact with our database.\nWe're going to use the exact example that Stitch gives us; it's important to\nhave the \"A-ha\" moment where everything comes together. \n\nBefore getting to any code, the only two things we need to do are:\n\n 1. Enable Anonymous Authentication: This is fancy language for creating a user\n    type where anybody who accesses our app can make queries\n 2. Pointing to our Mongo Collection: We need somewhere to store the data we'll\n    be messing with.\n\nConnecting Your App\nWe're going to copy and paste this code on to a page of our app. Once this is\nlive, visit the page and keep an eye on the console:\n\n<script src=\"https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js\"></script>\n\n<script>\n  const clientPromise = stitch.StitchClientFactory.create('hackerjira-bzmfe');\n  clientPromise.then(client => {\n    const db = client.service('mongodb', 'mongodb-atlas').db('HackersBlog');\n    client.login().then(() =>\n      db.collection('jira').updateOne({owner_id: client.authedId()}, {$set:{number:42}}, {upsert:true})\n    ).then(()=>\n      db.collection('jira').find({owner_id: client.authedId()}).limit(100).execute()\n    ).then(docs => {\n      console.log(\"Found docs\", docs)\n      console.log(\"[MongoDB Stitch] Connected to Stitch\")\n    }).catch(err => {\n      console.error(err)\n    });\n  });\n</script>\n\n\nChecking this on the live sites looks like this:\n\nNote the \"docs\" found in the console on the right.It worked, but what exactly?\nThe first thing the snippet tells the database to do is to upsert a row where\n\"number\" is equal to 42:\n\ndb.collection('jira').updateOne({owner_id: client.authedId()}, {$set:{number:42}}, {upsert:true})\n\n\nFor sanity, let's check the database to see what's up:\n\nIs that… a new record?!?!Sure enough, a new entry has been added to our database\nin the collection we specified. That's fun and all, but what about our actual\ndata? Isn't that what we came here for? Consider the next line:\n\ndb.collection('jira').find({owner_id: client.authedId()}).limit(100).execute()\n\n\nAhhh, we’re querying based on entries only  created from the current user!\nBecause the sample code we pasted creates a record, we can then query the\ndatabase for records created by that user. Let’s not ignore how cool that is\nhaving not actually done any work: we already have logic in place to allow\nanonymous users to create records and recognize them based on their session.\n\n.find()  is our bread and butter for retrieving records, much like SQL SELECT.\nSo in theory, to show all issues from this collection we'd just need to run the\nfollowing, right?\n\ndb.collection('jira').find({}).execute()\n\n\nSlow down there, buddy- but yes, pretty much. We just need to make read\npermissions public on the MongoDB Stitch side first. Back in the Stitch UI,\nselect \"Rules\" from the sidebar. Here, we can modify the rules for who can\nread/write which records from which DB:\n\nIt's less complicated than it looks.We can create rules as advanced as we'd\nlike, but the rules we need right now are simple enough to handle purely via the\nUI.\n\nGet All The Records\nGo ahead and add a bunch of records to your database collection. Experiment with\nimporting data via JSON or CSV, or just add some records one-by-one.\n\nWhen that's done, go back to your app and see what .find({})  comes back with:\n\nNow that's a collection.There they are: every record from a database collection,\ngrabbed with a single line of code on our frontend. Feel free to take a moment\nto reflect on this: we didn’t need to create an API, write logic, or log in to\nany shitty IAM policy management UIs. We didn’t even need to write a query; the\n‘query’ in this case is just a JSON object.\n\nStitching it All Together\nWhen I first reached this point, I experienced a rush of emotions: can creating\nnew features truly be this simple? If so, what have we been doing with our lives\nuntil this moment- repeating the same boilerplate and relearning the same\nconcepts as millions before us? Is this knowledge all worthless now? Does the\nexistence of Stitch reduce our lives’ greatest accomplishments to something that\ncan now be reproduced in minutes?\n\nWhile there are a great number of things that come easily with Stitch, there are\na fair share of headaches that come along with them. Many intricacies of complex\nflows and user management lack documentation or examples altogether. Creating a\ncloud based on ease-of-use even more frustrating: there’s not much that sucks\nmore than knowing something should be simple, but lacking the few lines of code\nto do it.\n\nThat’s where we’ll be filling in the blanks. Next time, we’ll take a look into\nStitch’s Serverless functions.","html":"<p>Some tools are simply the right tool for the job. I imagine this must have been the thinking behind the wave of JSON-like NoSQL databases at their peak, and even so today. If we figure we’ll be passing information as JSON to an endpoint, to then have it structured into a schema, only to be promptly broken down again for our request seconds later, if you will, it’s fair to question the cost-benefit of schemas in some cases. A lot of those cases cover the apps we build for ourselves: ones that let us do stupid things like spamming selfies or filling the internet with vast mindless thoughts.</p><p><strong><strong>MongoDB Atlas</strong></strong> is a hell of product in its own right, being a cloud NoSQL database with the ability to execute queries similar to SQL JOINs, countless aggregations, and more possibilities to work into a pipeline than I’ve even had time to explore (we’ll get there). If you’ve ever been tasked to build endpoints for yourself, chances are you already appreciate side-stepping the manual one-to-one key association that comes with passing JSON to Lambda Functions or what-have-you.</p><p>Take our situation at Hackers And Slackers, for instance. We’re running a Ghost blog, which is a young piece of software built by a non-profit organization: this software is constantly being updated and improved, which means if we want to modify the logic of our Node app at all, our choices are:</p><ol><li>Modify the Ghost source and refuse future updates</li><li>Merge our custom backend with Ghost changes in the event of an update</li><li>Build a third-party API using a platform such as AWS</li></ol><p><strong><strong>MongoDB Stitch</strong></strong> gives us a new fourth option: <em>extend our app without all the repetitive boilerplate.</em> I say <em>extend</em> because it empowers us to build on top of things which were previously black-boxed to us, such developing a theme atop a blogging system.</p><h2 id=\"carrying-on-the-legacy\">Carrying on the Legacy</h2><p><strong><strong>MongoDB Stitch </strong></strong>extends the philosophy of avoiding repetition. In a similar way to how NoSQL removed a pain point for many developers, Stitch wants you to keep doing what you do best, which is probably writing NodeJS apps. Forever.</p><p>If I worked for Mongo, I’d sell the product like this:</p><blockquote><em><em>MongoDB Stitch empowers you to build powerful features without ever switching gears to the menial aspects of development.</em></em></blockquote><p>What I’m really saying is that <strong><strong>MongoDB Stitch</strong></strong> is <strong><strong>Google Firebase</strong></strong>. Both products target the <em>frontend</em> and <em>mobile</em> developer markets, and both are very young and early in fully achieving this goal. I’m watching the MongoDB product video for the first time, and it feels like what I’ve assumed from using the product aligns with their sell (good job on their part, I suppose):</p><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/H3P0lW94L2Q?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>As warm and uppity as that video is, Mongo has been rather bashful about their Cloud. I'm guessing that has something to do with an IPO.</p><p>On the other hand, <strong>Google Firebase</strong> has been tooting its own horn loudly for a young product, with a level of growth which feels almost reckless at times (I won't get into it):</p><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/iosNuIdQoy8?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>Anyway, we're not here to compare. We're here to judge.</p><h2 id=\"getting-started-with-a-new-database\">Getting Started with a New Database</h2><p>Feel free to follow along by <a href=\"https://docs.mongodb.com/manual/tutorial/atlas-free-tier-setup/\">setting up a free tier cluster</a>. </p><p>Proper Mongo accounts are managed at <a href=\"https://cloud.mongodb.com\">https://cloud.mongodb.com</a> once created. This landing dash has plenty of useful info and stats regarding the cluster itself. We'll also need to be sure that a database exists before we crate any apps, otherwise we'll just be interacting with nothing.</p><p>I <em>highly</em> suggest using the <strong>MongoDB Compass</strong> desktop app to connect to your your cluster. It's easy to download, and even saves you the time of entering credentials by connecting with a copy+pasted URI:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/connectcompass.gif\" class=\"kg-image\"><figcaption>Connect with your database; emotionally.</figcaption></figure><p>Within Compass, simply create a database and collection:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/createdatabase_o.jpg\" class=\"kg-image\"><figcaption>In MongoWorld, \"collections\" are the equivalent of \"tables\".</figcaption></figure><h2 id=\"let-s-get-stitched\">Let's Get Stitched</h2><p>With all that out of the way, head back to your account on the Mongo Cloud. Now our interest is entirely in the <strong>Stitch Apps</strong> link on the left side nav:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/selectstitch.png\" class=\"kg-image\"><figcaption>There’s so much to explore!</figcaption></figure><p>Create and name a new Stitch application, and we'll land on the \"getting started\" page. </p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/cf61a09bd893c453854634988b71d500.gif\" class=\"kg-image\"><figcaption><em>Enable anonymous auth &amp; point to your collection</em></figcaption></figure><p>Once we create our app, Stitch immediately throws us in to a quick 101 of how to interact with our database. We're going to use the exact example that Stitch gives us; it's important to have the \"A-ha\" moment where everything comes together. </p><p>Before getting to any code, the only two things we need to do are:</p><ol><li><strong>Enable Anonymous Authentication</strong>: This is fancy language for creating a user type where anybody who accesses our app can make queries</li><li><strong>Pointing to our Mongo Collection</strong>: We need somewhere to store the data we'll be messing with.</li></ol><h3 id=\"connecting-your-app\">Connecting Your App</h3><p>We're going to copy and paste this code on to a page of our app. Once this is live, visit the page and keep an eye on the console:</p><pre><code class=\"language-javascript\">&lt;script src=&quot;https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js&quot;&gt;&lt;/script&gt;\n\n&lt;script&gt;\n  const clientPromise = stitch.StitchClientFactory.create('hackerjira-bzmfe');\n  clientPromise.then(client =&gt; {\n    const db = client.service('mongodb', 'mongodb-atlas').db('HackersBlog');\n    client.login().then(() =&gt;\n      db.collection('jira').updateOne({owner_id: client.authedId()}, {$set:{number:42}}, {upsert:true})\n    ).then(()=&gt;\n      db.collection('jira').find({owner_id: client.authedId()}).limit(100).execute()\n    ).then(docs =&gt; {\n      console.log(&quot;Found docs&quot;, docs)\n      console.log(&quot;[MongoDB Stitch] Connected to Stitch&quot;)\n    }).catch(err =&gt; {\n      console.error(err)\n    });\n  });\n&lt;/script&gt;\n</code></pre>\n<p>Checking this on the live sites looks like this:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screenshot-2018-06-02-16.40.43.png\" class=\"kg-image\"><figcaption>Note the \"docs\" found in the console on the right.</figcaption></figure><p>It worked, but what exactly? The first thing the snippet tells the database to do is to upsert a row where \"number\" is equal to 42:</p><pre><code class=\"language-javascript\">db.collection('jira').updateOne({owner_id: client.authedId()}, {$set:{number:42}}, {upsert:true})\n</code></pre>\n<p>For sanity, let's check the database to see what's up:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/createdatabase_o.jpg\" class=\"kg-image\"><figcaption>Is that… a new record?!?!</figcaption></figure><p>Sure enough, a new entry has been added to our database in the collection we specified. That's fun and all, but what about our actual data? Isn't that what we came here for? Consider the next line:</p><pre><code class=\"language-javascript\">db.collection('jira').find({owner_id: client.authedId()}).limit(100).execute()\n</code></pre>\n<p>Ahhh, we’re querying based on entries <em>only</em> created from the current user! Because the sample code we pasted creates a record, we can then query the database for records created by that user. Let’s not ignore how cool that is having not actually done any work: we already have logic in place to allow anonymous users to create records and recognize them based on their session.</p><p><code>.find()</code> is our bread and butter for retrieving records, much like SQL <code>SELECT</code>. So in theory, to show all issues from this collection we'd just need to run the following, right?</p><pre><code class=\"language-javascript\">db.collection('jira').find({}).execute()\n</code></pre>\n<p>Slow down there, buddy- but yes, pretty much. We just need to make read permissions public on the MongoDB Stitch side first. Back in the Stitch UI, select \"Rules\" from the sidebar. Here, we can modify the rules for who can read/write which records from which DB:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screenshot-2018-06-02-16.43.31.png\" class=\"kg-image\"><figcaption>It's less complicated than it looks.</figcaption></figure><p>We can create rules as advanced as we'd like, but the rules we need right now are simple enough to handle purely via the UI.</p><h2 id=\"get-all-the-records\">Get All The Records</h2><p>Go ahead and add a bunch of records to your database collection. Experiment with importing data via JSON or CSV, or just add some records one-by-one.</p><p>When that's done, go back to your app and see what <code>.find({})</code> comes back with:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screen-Shot-2018-11-24-at-4.45.50-PM_o.png\" class=\"kg-image\"><figcaption>Now that's a collection.</figcaption></figure><p>There they are: every record from a database collection, grabbed with a single line of code on our frontend. Feel free to take a moment to reflect on this: we didn’t need to create an API, write logic, or log in to any shitty IAM policy management UIs. We didn’t even need to write a query; the ‘query’ in this case is just a JSON object.</p><h3 id=\"stitching-it-all-together\">Stitching it All Together</h3><p>When I first reached this point, I experienced a rush of emotions: can creating new features truly be this simple? If so, what have we been doing with our lives until this moment- repeating the same boilerplate and relearning the same concepts as millions before us? Is this knowledge all worthless now? Does the existence of Stitch reduce our lives’ greatest accomplishments to something that can now be reproduced in minutes?</p><p>While there are a great number of things that come easily with Stitch, there are a fair share of headaches that come along with them. Many intricacies of complex flows and user management lack documentation or examples altogether. Creating a cloud based on ease-of-use even more frustrating: there’s not much that sucks more than knowing something should be simple, but lacking the few lines of code to do it.</p><p>That’s where we’ll be filling in the blanks. Next time, we’ll take a look into Stitch’s Serverless functions.</p>","url":"https://hackersandslackers.com/mongodb-stitch-query-anywhere/","uuid":"76a0bed5-d98a-47a1-a00a-64cff37d16a8","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b12c0ddb5ac11477416d88d"}},"pageContext":{"slug":"mongodb-stitch-query-anywhere"}}