{"data":{"ghostPost":{"id":"Ghost__Post__5c82cfe75af763016e85082e","title":"Working With GraphQL Fragments and Mutations","slug":"creating-updating-and-deleting-data-via-graphql-mutations","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","custom_excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","created_at_pretty":"08 March, 2019","published_at_pretty":"19 March, 2019","updated_at_pretty":"20 March, 2019","created_at":"2019-03-08T15:26:15.000-05:00","published_at":"2019-03-19T16:34:38.000-04:00","updated_at":"2019-03-20T18:39:27.000-04:00","meta_title":"Working With GraphQL Fragments and Mutations | Hackers and Slackers","meta_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","og_title":"Working With GraphQL Fragments and Mutations","twitter_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-2.jpg","twitter_title":"Working With GraphQL Fragments and Mutations","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"Last week we encountered a genuine scenario when working with GraphQL clients.\nWhen building real applications consuming data via GraphQL, we usually don't\nknow precisely the query we're going to want to run at runtime. Imagine a user\ncruising through your application, setting preferences, and arriving at core\npieces of functionality under a content which is specific only to them. Say\nwe're building a GrubHub knockoff (we hate profits and love entering\nimpenetrable parts of the market, it's not that uncommon really.) At its core,\nthe information we're serving will always be restaurants; we'll always want to\nreturn things like the restaurant address, name, rating, etc. Because we want\nour app to be intelligent, this means that circumstances in which User 1  makes\na query are vastly different than User 2. Aside from the obvious facts (residing\nin different locales), perhaps there's more metadata we can leverage from User 1\n's longterm app usage, versus User 2  who is a total noob to our knockoff app.\n\nYet, the information we're serving will always be restaurants. There's a core\nquery being reused at the heart of our requests: we need to be dynamic enough to\naccount for the fact that User 1  has checked off 13 different cuisines and\nstrict delivery time windows, whereas User 2  doesn't give a shit. User 2  just\nwants pizza.\n\nThis is where GraphQL Fragments  come in to play. We've already seen how we can\npass variables through our queries to receive contextual data: the next step is\ncreating blocks of reusable code which may never change, which become the\nfoundational building blocks of all future queries.\n\nWhen to Use Fragments\nBack to our JIRA example, I demonstrated precisely the sort of thing one should\nnever do: making more than one GraphQL request to serve a single purpose.\n\nTo recap, we're pulling in JIRA issues to a Kanban board. Our board has 4\ncolumns: one per \"status.\" Here's a god-awful way of hardcoding a query like\nthat:\n\nquery JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }\n\nSeems like a lot of repetition, yeah? What if we could define chunks of queries\nto be reused to simplify things?\n\n# Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}\n\nProgress! Instead of reiterating the fields we want to query for each time, we\nset these once.  We do this by creating a fragment  named JiraFields  (naming\nconventions for fragments are totally up to you- these don't relate to\nanything). To make this easier to visualize, let's just look at the parts:\n\nfragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}\n\nTake note of [nameOfDatamodelToQuery(SINGULAR)]. Our fragment will refer to data\nmodel in the singular syntax  - this is important.\n\nOur New Query Using a Fragment\nAgain, let's simply what we're looking at:\n\nquery [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}\n\n * [subsetName]  is the name of the embedded JSON object to be returned in the\n   response. The naming is up to us.\n * [DatamodelToQuery(PLURAL)]  contrasts the singular data model we specified in\n   our fragment.\n * Finally, ...[GivenNameToYourFragment]  is the syntax for dumping a fragment\n   into a query. Yes, the ...  is intentional.\n\nHere's how we managed to get on:\n\nNow we're talkin'.Implementing On The Client Side\nWith the big picture in hand, this is still all theoretical until we have some\nreal code making real dynamic queries. So which GraphQL client tools should we\nuse?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.\n\nAs we all know, Apollo [https://github.com/apollographql/apollo-client]  is\ncrushing the game with their seemingly endless libraries doing... a lot of\nsimilar stuff? Then there's Prisma\n[https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/]\n, the new hotshot looking to make a buck. But what about this repo\n[https://github.com/smooth-code/fraql]? It seems totally fine, but why won't it\nfreakin work?! And what about this Lokka [https://github.com/kadirahq/lokka] \nthing? Also, apparently you can just use node-fetch\n[https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher] \n anyway?\n\nFor somebody looking for simplicity, this gets very frustrating. Most clients\nare immediately concerned with integrating with React as fast as possible\n(totally understandable), but a small-town country boy like me just wants to\nstart with simple. I'm just trying to write a god damn tutorial!\n\nAnyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything\nrelated to JavaScript could be cohesive or straightforward. Instead of wrestling\nwith that reality, now's as good a time as ever to move on to the part of\nGraphQL we've failed to speak of: modifying data.\n\nGraphQL Mutation Cheatsheet\nAny form of creating, changing, or deleting data in GraphQL falls under the\numbrella of mutations. The structure is similar to queries, except that we take\ndata in (presumably through variables) and spit out whichever fields you'd like\nto see as a result of that.\n\nCreating Records\nA functioning \"create\" mutation with the resulting response:\n\nSimple enough.And the mutation itself, just in case anybody is copy/pasting out\nthere:\n\nmutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}\n\nUpdating Records\nWe can update records (aka nodes) by specifying the target node using where: {},\nand the data to be updated within data: {}\n\nSyntax is just like creating nodes, but with an added where:{} statement.mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}\n\nDeleting Records\nYou can even specify which fields you want returned from the node you're in the\nact of ruthlessly murdering! \n\nAnd with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue\nwith GraphQL\" to please its master once last time.mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}\n\nEnough For Now\nHopefully, I'm not the only one to have bee deceived by the simplicity of\nGraphQL's syntax at first glance. The minimalism of GraphQL queries and\nmutations would lead one to believe that they're simple to understand right off\nthe bat. The problem with that logic is the syntax is so  simplistic, that\nthere's hardly any way of telling what nearly identical queries or mutations\nmight do from one character to the next. Even in JSON, the combination of \nexplicit quotations, key:value relationships, and  comma-separation  affords us\na lot of inferred knowledge we take for granted.\n\nI'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much\nas it can easily be frustrating to newcomers (and rightfully so). As long as\npeople keep reading, I'll keep posting, so let's chip away at this thing week by\nweek.","html":"<p>Last week we encountered a genuine scenario when working with GraphQL clients. When building real applications consuming data via GraphQL, we usually don't know precisely the query we're going to want to run at runtime. Imagine a user cruising through your application, setting preferences, and arriving at core pieces of functionality under a content which is specific only to them. Say we're building a GrubHub knockoff (we hate profits and love entering impenetrable parts of the market, it's not that uncommon really.) At its core, the information we're serving will always be restaurants; we'll always want to return things like the restaurant address, name, rating, etc. Because we want our app to be intelligent, this means that circumstances in which <strong>User 1</strong> makes a query are vastly different than <strong>User 2</strong>. Aside from the obvious facts (residing in different locales), perhaps there's more metadata we can leverage from <strong>User 1</strong>'s longterm app usage, versus <strong>User 2</strong> who is a total noob to our knockoff app.</p><p>Yet, <em>the information we're serving will always be restaurants</em>. There's a core query being reused at the heart of our requests: we need to be dynamic enough to account for the fact that <strong>User 1</strong> has checked off 13 different cuisines and strict delivery time windows, whereas <strong>User 2</strong> doesn't give a shit. <strong>User 2</strong> just wants pizza.</p><p>This is where GraphQL <em><strong>Fragments</strong></em> come in to play. We've already seen how we can pass variables through our queries to receive contextual data: the next step is creating blocks of reusable code which may never change, which become the foundational building blocks of all future queries.</p><h2 id=\"when-to-use-fragments\">When to Use Fragments</h2><p>Back to our JIRA example, I demonstrated precisely the sort of thing one should never do: making more than one GraphQL request to serve a single purpose.</p><p>To recap, we're pulling in JIRA issues to a Kanban board. Our board has 4 columns: one per \"status.\" Here's a god-awful way of hardcoding a query like that:</p><!--kg-card-begin: code--><pre><code>query JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }</code></pre><!--kg-card-end: code--><p>Seems like a lot of repetition, yeah? What if we could define chunks of queries to be reused to simplify things?</p><!--kg-card-begin: code--><pre><code># Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}</code></pre><!--kg-card-end: code--><p>Progress! Instead of reiterating the fields we want to query for each time, we set these <em>once.</em> We do this by creating a <code>fragment</code> named <strong>JiraFields</strong> (naming conventions for fragments are totally up to you- these don't relate to anything). To make this easier to visualize, let's just look at the parts:</p><!--kg-card-begin: code--><pre><code>fragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}</code></pre><!--kg-card-end: code--><p>Take note of <code>[nameOfDatamodelToQuery(SINGULAR)]</code>. Our fragment will refer to data model in the singular syntax  - this is important.</p><h3 id=\"our-new-query-using-a-fragment\">Our New Query Using a Fragment</h3><p>Again, let's simply what we're looking at:</p><!--kg-card-begin: code--><pre><code>query [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}</code></pre><!--kg-card-end: code--><ul><li><code>[subsetName]</code> is the name of the embedded JSON object to be returned in the response. The naming is up to us.</li><li><code>[DatamodelToQuery(PLURAL)]</code> contrasts the singular data model we specified in our fragment.</li><li>Finally, <code>...[GivenNameToYourFragment]</code> is the syntax for dumping a fragment into a query. Yes, the <code>...</code> is intentional.</li></ul><p>Here's how we managed to get on:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-18-at-8.15.19-AM.png\" class=\"kg-image\"><figcaption>Now we're talkin'.</figcaption></figure><!--kg-card-end: image--><h2 id=\"implementing-on-the-client-side\">Implementing On The Client Side</h2><p>With the big picture in hand, this is still all theoretical until we have some real code making real dynamic queries. So which GraphQL client tools should we use?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.</p><p>As we all know, <a href=\"https://github.com/apollographql/apollo-client\"><strong>Apollo</strong></a> is crushing the game with their seemingly endless libraries doing... a lot of similar stuff? Then there's <strong><a href=\"https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/\">Prisma</a></strong>, the new hotshot looking to make a buck. But what about <a href=\"https://github.com/smooth-code/fraql\"><strong>this repo</strong></a>? It seems totally fine, but why won't it freakin work?! And what about this <strong><a href=\"https://github.com/kadirahq/lokka\">Lokka</a></strong> thing? Also, <a href=\"https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher\">apparently you can just use <strong>node-fetch</strong></a> anyway?</p><p>For somebody looking for simplicity, this gets very frustrating. Most clients are immediately concerned with integrating with React as fast as possible (totally understandable), but a small-town country boy like me just wants to start with simple. I'm just trying to write a god damn tutorial!</p><p>Anyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything related to JavaScript could be cohesive or straightforward. Instead of wrestling with that reality, now's as good a time as ever to move on to the part of GraphQL we've failed to speak of: modifying data.</p><h2 id=\"graphql-mutation-cheatsheet\">GraphQL Mutation Cheatsheet</h2><p>Any form of creating, changing, or deleting data in GraphQL falls under the umbrella of mutations. The structure is similar to queries, except that we take data in (presumably through variables) and spit out whichever fields you'd like to see as a result of that.</p><h3 id=\"creating-records\">Creating Records</h3><p>A functioning \"create\" mutation with the resulting response:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.41-PM.png\" class=\"kg-image\"><figcaption>Simple enough.</figcaption></figure><!--kg-card-end: image--><p>And the mutation itself, just in case anybody is copy/pasting out there:</p><!--kg-card-begin: code--><pre><code>mutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"updating-records\">Updating Records</h3><p>We can update records (aka nodes) by specifying the target node using <code>where: {}</code>, and the data to be updated within <code>data: {}</code></p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-19-at-1.23.28-PM.png\" class=\"kg-image\"><figcaption>Syntax is just like creating nodes, but with an added where:{} statement.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"deleting-records\">Deleting Records</h3><p>You can even specify which fields you want returned from the node you're in the act of ruthlessly murdering! </p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.20-PM.png\" class=\"kg-image\"><figcaption>And with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue with GraphQL\" to please its master once last time.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"enough-for-now\">Enough For Now</h3><p>Hopefully, I'm not the only one to have bee deceived by the simplicity of GraphQL's syntax at first glance. The minimalism of GraphQL queries and mutations would lead one to believe that they're simple to understand right off the bat. The problem with that logic is the syntax is <em>so</em> simplistic, that there's hardly any way of telling what nearly identical queries or mutations might do from one character to the next. Even in JSON, the combination of <strong>explicit quotations</strong>, <strong>key:value relationships</strong>, and<strong> comma-separation</strong> affords us a lot of inferred knowledge we take for granted.</p><p>I'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much as it can easily be frustrating to newcomers (and rightfully so). As long as people keep reading, I'll keep posting, so let's chip away at this thing week by week.</p><p></p>","url":"https://hackersandslackers.com/creating-updating-and-deleting-data-via-graphql-mutations/","uuid":"a042692b-1812-49a1-a2fb-c0bd97973edf","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c82cfe75af763016e85082e"}},"pageContext":{"slug":"creating-updating-and-deleting-data-via-graphql-mutations"}}