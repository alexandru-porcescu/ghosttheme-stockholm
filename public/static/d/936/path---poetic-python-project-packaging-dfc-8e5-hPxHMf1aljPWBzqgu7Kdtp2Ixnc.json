{"data":{"ghostPost":{"id":"Ghost__Post__5c34086694d3e847951adf3e","title":"Poetically Packaging Your Python Project","slug":"poetic-python-project-packaging","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/01/poetry4@2x.jpg","excerpt":"Manage your projects with Poetry to handle dependencies, envs, packaging, etc.","custom_excerpt":"Manage your projects with Poetry to handle dependencies, envs, packaging, etc.","created_at_pretty":"08 January, 2019","published_at_pretty":"08 January, 2019","updated_at_pretty":"09 April, 2019","created_at":"2019-01-07T21:18:14.000-05:00","published_at":"2019-01-08T10:16:00.000-05:00","updated_at":"2019-04-09T17:59:40.000-04:00","meta_title":"Poetically Packaging Your Python Project | Hackers and Slackers","meta_description":"Manage your projects with Poetry: a dependency manager and project packager all in one. Handle your environment and project data in a single file.","og_description":"Manage your projects with Poetry to handle dependencies, envs, packaging, etc.","og_image":"https://hackersandslackers.com/content/images/2019/01/poetry4@2x.jpg","og_title":"Poetically Packaging Your Python Project","twitter_description":"Manage your projects with Poetry to handle dependencies, envs, packaging, etc.","twitter_image":"https://hackersandslackers.com/content/images/2019/01/poetry4@2x.jpg","twitter_title":"Poetically Packaging Your Python Project","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"It wasn't long ago that we Hackers were singing the praises of Pipenv\n[https://hackersandslackers.com/pipenv-etc-tracking-your-projects-dependancies/]\n: Python's seemingly superior dependency manager at the time. While we hold much\nlove in hearts, sometimes there is love to go around. We just so happen to be\nfair weather fans, which reminds me: what has Pipenv done for me lately?\n\nAs you've probably guessed (considering its a piece of software), nothing much.\nWell, there was that time when pip upgraded from v.18  to v.18.1, which broke\nPipenv entirely with almost minimal acknowledgment (for all I know this might\nstill be broken). As our lives seemed to fade, a miracle emerged from the ashes:\na young, smart, attractive alternative to Pipenv that's been whispering in my\near, and promising the world. Her name is Poetry [https://poetry.eustace.io/].\n\nWhat Light Through Yonder GitHub Breaks?\nPoetry stems from the genuine frustration that comes with not only managing\nenvironments and dependencies in Python, but the fact that even solving this\nproblem (albeit poorly) still doesn't solve the related tasks needing\nfulfillment when creating respectable Python projects. Consider Node's \npackage.json: a single file which contains a project's metadata, prod\ndependencies, dev dependencies, contact information, etc. Instead, Python\nprojects usually come with the following:\n\nSetup.py\nIf you've never bothered to publish a package to PyPI before, there's a decent\nchance you may not be very familiar with some of the nuances that come with \nsetup.py  or why you'd bother creating one. This is a losing mentality: we\nshould assume that most (or some) of the things we build might become useful\nenough to distribute some day.\n\nThus, we get this monstrosity:\n\nfrom setuptools import setup, find_packages, tests_require, packages, name\n\nwith open(\"README\", 'r') as f:\n    long_description = f.read()\n\nsetup = (\n    name='Fake Project',\n    version='1.0',\n    description='A fake project used for example purposes.',\n    long_description=long_description,\n    author='Todd Birchard',\n    author_email='todd@hackersandslackers.com',\n    maintainer='Some Loser',\n    maintainer_email='some.loser@example.com,\n    url=\"https://github.com/toddbirchard/fake-project\",\n    license='MIT',\n    include_package_data=True,\n    package_dir={'application'}\n    packages=['distutils', 'modules'],\n    tests_require=[\"pytest\"],\n    cmdclass={\"pytest\": PyTest},\n    classifiers=[\n          'Development Status :: 2 - Beta',\n          'Environment :: Console',\n          'Environment :: Web Environment',\n          'Intended Audience :: End Users/Desktop',\n          'Intended Audience :: Developers',\n          'Intended Audience :: System Administrators',\n          'License :: OSI Approved :: Python Software Foundation License',\n          'Operating System :: MacOS :: MacOS X',\n          'Operating System :: Microsoft :: Windows',\n          'Operating System :: POSIX',\n          'Programming Language :: Python',\n          'Topic :: Communications :: Email',\n          'Topic :: Office/Business',\n          'Topic :: Software Development :: Bug Tracking',\n          ],\n)\n\n\nMany of the metadata fields are rather self-explanatory. But what about the\nfields related to package dependencies, such as package_dir or packages? Wasn't\nthis already handled in our Pipfile? On top of that, we need to specify then the\ntest suite we're using via tests_require  and cmdclass? Short answer: pretty\nmuch.\n\nSetup.cfg\nThe real joke with setup.py  is that it needs its own configuration file: yes, a\nconfiguration file for your configuration file. setup.cfg, as the name\nsuggestions, sets even more granular configurations for the things mentioned in \nsetup.py, such as how pytest  should be handled, etc. Let's not get into it, but\nhere's an example:\n\n[coverage:run]\nomit = */test/*\n\n[flake8]\nexclude = *.egg*,.env,.git,.tox,_*,build*,dist*,venv*,python2/,python3/\nignore = E261,W503\nmax-line-length = 121\n\n[tool:pytest]\nminversion = 3.2\naddopts =\n  # --fulltrace\n  # -n auto\n  --cov-config=setup.cfg\n  --cov=httplib2\n  --noconftest\n  --showlocals\n  --strict\n  --tb=short\n  --timeout=17\n  --verbose\n  -ra\n\n\nPipfile and Pipfile.lock\nIf you have been using Pipenv, you'll recognize these files as being responsible\nfor setting your Python version and dependencies. But wait- didn't we also need\nto specify dependencies in setup.py?  Yes, we did. There is no God, but if there\nwere, he'd probably hate you. Here's all the work you'd need to do creating an\nacceptable Pipfile:\n\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\nFlask-SQLAlchemy = \"*\"\npsycopg2 = \"*\"\npsycopg2-binary = \"*\"\nrequests = \"*\"\nconfigparser=\"*\"\nmapbox=\"*\"\nflask=\"*\"\npandas=\"*\"\nFlask-Assets=\"*\"\nlibsass=\"*\"\njsmin=\"*\"\ndash_core_components=\"*\"\ndash-table=\"*\"\ndash_html_components=\"*\"\ndash=\"*\"\nflask-session=\"*\"\nflask-redis=\"*\"\ngunicorn=\"*\"\npytest-flask=\"*\"\n\n\n[dev-packages]\n\n[requires]\npython_version = \"3.7.1\"\n\n\n\nBut wait, there's more!\n\nRequirements.txt\nBecause the Pipfile format has not been adopted as a standard for dependency\nmanagement, we still  need to create a requirements.txt file if we want to\ndeploy our application to respectable hosts such as Google App Engine  or\nwhat-have-you. So now we have this ugly son of a bitch from the stone age to\ndeal with as well:\n\natomicwrites==1.2.1\nattrs==18.2.0\nboto3==1.9.75\nbotocore==1.12.75\nCacheControl==0.12.5\ncertifi==2018.11.29\nchardet==3.0.4\nClick==7.0\nconfigparser==3.5.0\ndash==0.35.1\ndash-core-components==0.42.0\ndash-html-components==0.13.4\ndash-renderer==0.16.1\ndash-table==3.1.11\ndecorator==4.3.0\ndocutils==0.14\nFlask==1.0.2\nFlask-Assets==0.12\nFlask-Compress==1.4.0\nFlask-Redis==0.3.0\nFlask-Session==0.3.1\nFlask-SQLAlchemy==2.3.2\ngunicorn==19.9.0\nidna==2.8\nipython-genutils==0.2.0\niso3166==0.9\nitsdangerous==1.1.0\nJinja2==2.10\njmespath==0.9.3\njsmin==2.2.2\njsonschema==2.6.0\njupyter-core==4.4.0\nlibsass==0.17.0\nmapbox==0.17.2\nMarkupSafe==1.1.0\nmore-itertools==5.0.0\nmsgpack==0.6.0\nnbformat==4.4.0\nnumpy==1.15.4\npandas==0.23.4\nplotly==3.5.0\npluggy==0.8.0\npolyline==1.3.2\npsycopg2==2.7.6.1\npsycopg2-binary==2.7.6.1\npy==1.7.0\npytest==4.1.0\npytest-flask==0.14.0\npython-dateutil==2.7.5\npytz==2018.9\nredis==3.0.1\nrequests==2.21.0\nretrying==1.3.3\ns3transfer==0.1.13\nsix==1.12.0\nSQLAlchemy==1.2.15\ntraitlets==4.3.2\nuritemplate==3.0.0\nurllib3==1.24.1\nwebassets==0.12.1\nWerkzeug==0.14.1\n\n\nMANIFEST.in\nYES, THERE'S MORE. If you're not bothered by now, please leave this blog\nimmediately. The job market is ripe for neckbeards who take pleasure in\nunnecessary complexity. Until the robots take over, this blog is for humans.\n\nAnyway, there's an entire file dedicated to including files in your project\nwhich aren't code. We're entering comically ridiculous territory:\n\ninclude README.rst\ninclude docs/*.txt\ninclude funniest/data.json\n\n\nIt's a Bird! It's a Plane! Its... A Single, Sophisticated Config File?\nI hope you're thoroughly pissed off after looking back at all the things we've\nlet slide by year after year, telling ourselves that this patchwork of standards\nis just fine. Cue our hero: the creator of Poetry:\n\n> Packaging systems and dependency management in Python are rather convoluted and\nhard to understand for newcomers. Even for seasoned developers it might be\ncumbersome at times to create all files needed in a Python project: setup.py,\nrequirements.txt, setup.cfg, MANIFEST.in  and the newly added Pipfile. So I\nwanted a tool that would limit everything to a single configuration file to do:\ndependency management, packaging and publishing.\nOh God yes, but HOW?!?!\n\nIntroducing pyproject.toml\nPoetry is built around a single configuration dubbed pyproject.toml  which has\nbecome an accepted standard in the Python community\n[https://www.python.org/dev/peps/pep-0518/]  by way of PEP 518.  With the weight\nof the Python development community itself, it's safe to say this isn't another\nfad and is worth using.\n\nHere's an example .toml file from the Poetry Github repository\n[https://github.com/sdispater/poetry]:\n\n[tool.poetry]\nname = \"my-package\"\nversion = \"0.1.0\"\ndescription = \"The description of the package\"\n\nlicense = \"MIT\"\n\nauthors = [\n    \"Sébastien Eustace <sebastien@eustace.io>\"\n]\n\nreadme = 'README.md'  # Markdown files are supported\n\nrepository = \"https://github.com/sdispater/poetry\"\nhomepage = \"https://github.com/sdispater/poetry\"\n\nkeywords = ['packaging', 'poetry']\n\n[tool.poetry.dependencies]\npython = \"~2.7 || ^3.2\"  # Compatible python versions must be declared here\ntoml = \"^0.9\"\n# Dependencies with extras\nrequests = { version = \"^2.13\", extras = [ \"security\" ] }\n# Python specific dependencies with prereleases allowed\npathlib2 = { version = \"^2.2\", python = \"~2.7\", allows-prereleases = true }\n# Git dependencies\ncleo = { git = \"https://github.com/sdispater/cleo.git\", branch = \"master\" }\n\n# Optional dependencies (extras)\npendulum = { version = \"^1.4\", optional = true }\n\n[tool.poetry.dev-dependencies]\npytest = \"^3.0\"\npytest-cov = \"^2.4\"\n\n[tool.poetry.scripts]\nmy-script = 'my_package:main'\n\n\nIn addition to covering the scope of all previously mentioned files, using \npyproject.toml  with Poetry also covers:\n\n * Auto-populating the exclude  section from values found in .gitignore\n * The addition of a keywords  section to be included with the resulting PyPi\n   package\n * Support for version numbers using any syntax, such as wildcard (*)  or carrot\n   (^1.0.0)  syntax\n * Auto-detection for virtual environments, thus a global install that can be\n   used within envs\n\nCreating Poetic Art\nAre we all fired up yet? Right: let's change our workflow forever.\n\nInstallation\n  To install Poetry on OSX, use the following:\n\n$ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python\n\n\nThis will create an addition to your ~/.bash_profile. Restart your terminal and\nverify the installation:\n\n$ poetry --version\nPoetry 0.12.10\n\n\nCreating a New Python Project\nNavigate to whichever file path you'd like your new project to call home. To get\nstarted, all we need next is the following command:\n\npoetry new my-package\n\n\nReady for a breath of fresh air? This command generates a basic project\nstructure for you- something that's been missing from Python for a long time\nwhen compared to similar generators for Node or otherwise. The resulting project\nstructure looks as such:\n\nmy-package\n├── pyproject.toml\n├── README.rst\n├── my_package\n│   └── __init__.py\n└── tests\n    ├── __init__.py\n    └── test_my_package\n\n\nOf the beautiful things happening here, the only one we haven't touched on yet\nis Poetry's built-in integration with pytest. Oh, happy day!\n\nAlternative Interactive Installation Method\nIf you'd prefer a bit more handholding, feel free to use poetry init  in an\nempty directory (or a directory without the existing .toml  file) to be walked\nthrough the creation process:\n\n$ poetry init\n\nThis command will guide you through creating your pyproject.toml config.\n\nPackage name [my-package]: Great Package\nVersion [0.1.0]:\nDescription []: Great package for great people.\nAuthor [Todd Birchard <todd@hackersandslackers.com>, n to skip]:\nLicense []: MIT\nCompatible Python versions [^2.7]: ^3.7\n\nWould you like to define your dependencies (require) interactively? (yes/no) [yes] no\n\n\n\nWould you like to define your dev dependencies (require-dev) interactively (yes/no) [yes] no\n\nGenerated file\n\n[tool.poetry]\nname = \"Great Package\"\nversion = \"0.1.0\"\ndescription = \"Great package for great people.\"\nauthors = [\"Todd Birchard <todd@hackersandslackers.com>\"]\nlicense = \"MIT\"\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n[tool.poetry.dev-dependencies]\n\n[build-system]\nrequires = [\"poetry>=0.12\"]\nbuild-backend = \"poetry.masonry.api\"\n\n\nDo you confirm generation? (yes/no) [yes] yes\n\n\nManaging Dependencies in pyproject.toml\nIf you're familiar with Pipfiles, pyproject.toml handles dependencies the same\nway. Just remember that poetry install  installs your listed dependencies, and \npoetry update  will update dependencies in poetry.lock to their latest versions.\n\nCarry on my Wayward Son\nI could spend all day copy-pasting general usage from the Poetry Github page,\nbut I think my work here is done. Do yourself a favor and  take a look at the\nGithub repo [https://github.com/sdispater/poetry]  to make your life easier\nforever. Or at least until the next replacement solution comes along.","html":"<p>It wasn't long ago that we Hackers were <a href=\"https://hackersandslackers.com/pipenv-etc-tracking-your-projects-dependancies/\">singing the praises of Pipenv</a>: Python's seemingly superior dependency manager at the time. While we hold much love in hearts, sometimes there is love to go around. We just so happen to be fair weather fans, which reminds me: what has Pipenv done for me <em>lately</em>?</p><p>As you've probably guessed (considering its a piece of software), nothing much. Well, there was that time when pip upgraded from <code>v.18</code> to <code>v.18.1</code>, which broke Pipenv entirely with almost minimal acknowledgment (for all I know this might still be broken). As our lives seemed to fade, a miracle emerged from the ashes: a young, smart, attractive alternative to Pipenv that's been whispering in my ear, and promising the world. Her name is <a href=\"https://poetry.eustace.io/\"><strong>Poetry</strong></a>.</p><h2 id=\"what-light-through-yonder-github-breaks\">What Light Through Yonder GitHub Breaks?</h2><p>Poetry stems from the genuine frustration that comes with not only managing environments and dependencies in Python, but the fact that even solving this problem (albeit poorly) still doesn't solve the related tasks needing fulfillment when creating respectable Python projects. Consider Node's <code>package.json</code>: a single file which contains a project's metadata, prod dependencies, dev dependencies, contact information, etc. Instead, Python projects usually come with the following:</p><h3 id=\"setup-py\">Setup.py</h3><p>If you've never bothered to publish a package to PyPI before, there's a decent chance you may not be very familiar with some of the nuances that come with <code>setup.py</code> or why you'd bother creating one. This is a losing mentality: we should assume that most (or some) of the things we build might become useful enough to distribute some day.</p><p>Thus, we get this monstrosity:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from setuptools import setup, find_packages, tests_require, packages, name\n\nwith open(&quot;README&quot;, 'r') as f:\n    long_description = f.read()\n\nsetup = (\n    name='Fake Project',\n    version='1.0',\n    description='A fake project used for example purposes.',\n    long_description=long_description,\n    author='Todd Birchard',\n    author_email='todd@hackersandslackers.com',\n    maintainer='Some Loser',\n    maintainer_email='some.loser@example.com,\n    url=&quot;https://github.com/toddbirchard/fake-project&quot;,\n    license='MIT',\n    include_package_data=True,\n    package_dir={'application'}\n    packages=['distutils', 'modules'],\n    tests_require=[&quot;pytest&quot;],\n    cmdclass={&quot;pytest&quot;: PyTest},\n    classifiers=[\n          'Development Status :: 2 - Beta',\n          'Environment :: Console',\n          'Environment :: Web Environment',\n          'Intended Audience :: End Users/Desktop',\n          'Intended Audience :: Developers',\n          'Intended Audience :: System Administrators',\n          'License :: OSI Approved :: Python Software Foundation License',\n          'Operating System :: MacOS :: MacOS X',\n          'Operating System :: Microsoft :: Windows',\n          'Operating System :: POSIX',\n          'Programming Language :: Python',\n          'Topic :: Communications :: Email',\n          'Topic :: Office/Business',\n          'Topic :: Software Development :: Bug Tracking',\n          ],\n)\n</code></pre>\n<!--kg-card-end: markdown--><p>Many of the metadata fields are rather self-explanatory. But what about the fields related to package dependencies, such as package_dir or packages? Wasn't this already handled in our Pipfile? On top of that, we need to specify then the test suite we're using via <strong>tests_require</strong> and <strong>cmdclass</strong>? Short answer: pretty much.</p><h3 id=\"setup-cfg\">Setup.cfg</h3><p>The real joke with <code>setup.py</code> is that it needs its own configuration file: yes, a configuration file for your configuration file. <code>setup.cfg</code>, as the name suggestions, sets even more granular configurations for the things mentioned in <code>setup.py</code>, such as how <strong>pytest</strong> should be handled, etc. Let's not get into it, but here's an example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">[coverage:run]\nomit = */test/*\n\n[flake8]\nexclude = *.egg*,.env,.git,.tox,_*,build*,dist*,venv*,python2/,python3/\nignore = E261,W503\nmax-line-length = 121\n\n[tool:pytest]\nminversion = 3.2\naddopts =\n  # --fulltrace\n  # -n auto\n  --cov-config=setup.cfg\n  --cov=httplib2\n  --noconftest\n  --showlocals\n  --strict\n  --tb=short\n  --timeout=17\n  --verbose\n  -ra\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"pipfile-and-pipfile-lock\">Pipfile and Pipfile.lock</h3><p>If you have been using Pipenv, you'll recognize these files as being responsible for setting your Python version and dependencies. <em>But wait- didn't we also need to specify dependencies in setup.py?</em> Yes, we did. There is no God, but if there were, he'd probably hate you. Here's all the work you'd need to do creating an acceptable Pipfile:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">[[source]]\nurl = &quot;https://pypi.org/simple&quot;\nverify_ssl = true\nname = &quot;pypi&quot;\n\n[packages]\nFlask-SQLAlchemy = &quot;*&quot;\npsycopg2 = &quot;*&quot;\npsycopg2-binary = &quot;*&quot;\nrequests = &quot;*&quot;\nconfigparser=&quot;*&quot;\nmapbox=&quot;*&quot;\nflask=&quot;*&quot;\npandas=&quot;*&quot;\nFlask-Assets=&quot;*&quot;\nlibsass=&quot;*&quot;\njsmin=&quot;*&quot;\ndash_core_components=&quot;*&quot;\ndash-table=&quot;*&quot;\ndash_html_components=&quot;*&quot;\ndash=&quot;*&quot;\nflask-session=&quot;*&quot;\nflask-redis=&quot;*&quot;\ngunicorn=&quot;*&quot;\npytest-flask=&quot;*&quot;\n\n\n[dev-packages]\n\n[requires]\npython_version = &quot;3.7.1&quot;\n\n</code></pre>\n<!--kg-card-end: markdown--><p>But wait, there's more!</p><h3 id=\"requirements-txt\">Requirements.txt</h3><p>Because the Pipfile format has not been adopted as a standard for dependency management, we <em>still</em> need to create a requirements.txt file if we want to deploy our application to respectable hosts such as <strong>Google App Engine</strong> or what-have-you. So now we have this ugly son of a bitch from the stone age to deal with as well:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">atomicwrites==1.2.1\nattrs==18.2.0\nboto3==1.9.75\nbotocore==1.12.75\nCacheControl==0.12.5\ncertifi==2018.11.29\nchardet==3.0.4\nClick==7.0\nconfigparser==3.5.0\ndash==0.35.1\ndash-core-components==0.42.0\ndash-html-components==0.13.4\ndash-renderer==0.16.1\ndash-table==3.1.11\ndecorator==4.3.0\ndocutils==0.14\nFlask==1.0.2\nFlask-Assets==0.12\nFlask-Compress==1.4.0\nFlask-Redis==0.3.0\nFlask-Session==0.3.1\nFlask-SQLAlchemy==2.3.2\ngunicorn==19.9.0\nidna==2.8\nipython-genutils==0.2.0\niso3166==0.9\nitsdangerous==1.1.0\nJinja2==2.10\njmespath==0.9.3\njsmin==2.2.2\njsonschema==2.6.0\njupyter-core==4.4.0\nlibsass==0.17.0\nmapbox==0.17.2\nMarkupSafe==1.1.0\nmore-itertools==5.0.0\nmsgpack==0.6.0\nnbformat==4.4.0\nnumpy==1.15.4\npandas==0.23.4\nplotly==3.5.0\npluggy==0.8.0\npolyline==1.3.2\npsycopg2==2.7.6.1\npsycopg2-binary==2.7.6.1\npy==1.7.0\npytest==4.1.0\npytest-flask==0.14.0\npython-dateutil==2.7.5\npytz==2018.9\nredis==3.0.1\nrequests==2.21.0\nretrying==1.3.3\ns3transfer==0.1.13\nsix==1.12.0\nSQLAlchemy==1.2.15\ntraitlets==4.3.2\nuritemplate==3.0.0\nurllib3==1.24.1\nwebassets==0.12.1\nWerkzeug==0.14.1\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"manifest-in\">MANIFEST.in</h3><p>YES, THERE'S MORE. If you're not bothered by now, please leave this blog immediately. The job market is ripe for neckbeards who take pleasure in unnecessary complexity. Until the robots take over, this blog is for humans.</p><p>Anyway, there's an entire file dedicated to including files in your project which aren't code. We're entering comically ridiculous territory:</p><!--kg-card-begin: markdown--><pre><code class=\"language-ini\">include README.rst\ninclude docs/*.txt\ninclude funniest/data.json\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"it-s-a-bird-it-s-a-plane-its-a-single-sophisticated-config-file\">It's a Bird! It's a Plane! Its... A Single, Sophisticated Config File?</h2><p>I hope you're thoroughly pissed off after looking back at all the things we've let slide by year after year, telling ourselves that this patchwork of standards is just fine. Cue our hero: the creator of Poetry:</p><blockquote>Packaging systems and dependency management in Python are rather convoluted and hard to understand for newcomers. Even for seasoned developers it might be cumbersome at times to create all files needed in a Python project: <code>setup.py</code>,<code>requirements.txt</code>, <code>setup.cfg</code>, <code>MANIFEST.in</code> and the newly added <code>Pipfile</code>. So I wanted a tool that would limit everything to a single configuration file to do: dependency management, packaging and publishing.</blockquote><p>Oh God yes, but HOW?!?!</p><h3 id=\"introducing-pyproject-toml\">Introducing pyproject.toml</h3><p>Poetry is built around a single configuration dubbed <code>pyproject.toml</code> which has become an <a href=\"https://www.python.org/dev/peps/pep-0518/\">accepted standard in the Python community</a> by way of <strong>PEP 518.</strong> With the weight of the Python development community itself, it's safe to say this isn't another fad and is worth using.</p><p>Here's an example <strong>.toml </strong>file from the <a href=\"https://github.com/sdispater/poetry\">Poetry Github repository</a>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-toml\">[tool.poetry]\nname = &quot;my-package&quot;\nversion = &quot;0.1.0&quot;\ndescription = &quot;The description of the package&quot;\n\nlicense = &quot;MIT&quot;\n\nauthors = [\n    &quot;Sébastien Eustace &lt;sebastien@eustace.io&gt;&quot;\n]\n\nreadme = 'README.md'  # Markdown files are supported\n\nrepository = &quot;https://github.com/sdispater/poetry&quot;\nhomepage = &quot;https://github.com/sdispater/poetry&quot;\n\nkeywords = ['packaging', 'poetry']\n\n[tool.poetry.dependencies]\npython = &quot;~2.7 || ^3.2&quot;  # Compatible python versions must be declared here\ntoml = &quot;^0.9&quot;\n# Dependencies with extras\nrequests = { version = &quot;^2.13&quot;, extras = [ &quot;security&quot; ] }\n# Python specific dependencies with prereleases allowed\npathlib2 = { version = &quot;^2.2&quot;, python = &quot;~2.7&quot;, allows-prereleases = true }\n# Git dependencies\ncleo = { git = &quot;https://github.com/sdispater/cleo.git&quot;, branch = &quot;master&quot; }\n\n# Optional dependencies (extras)\npendulum = { version = &quot;^1.4&quot;, optional = true }\n\n[tool.poetry.dev-dependencies]\npytest = &quot;^3.0&quot;\npytest-cov = &quot;^2.4&quot;\n\n[tool.poetry.scripts]\nmy-script = 'my_package:main'\n</code></pre>\n<!--kg-card-end: markdown--><p>In addition to covering the scope of all previously mentioned files, using <strong>pyproject.toml</strong> with Poetry also covers:</p><ul><li>Auto-populating the <strong>exclude</strong> section from values found in <code>.gitignore</code></li><li>The addition of a <strong>keywords</strong> section to be included with the resulting PyPi package</li><li>Support for version numbers using any syntax, such as <strong>wildcard (*)</strong> or <strong>carrot (^1.0.0)</strong> syntax</li><li>Auto-detection for virtual environments, thus a global install that can be used within envs</li></ul><h2 id=\"creating-poetic-art\">Creating Poetic Art</h2><p>Are we all fired up yet? Right: let's change our workflow forever.</p><h3 id=\"installation\">Installation</h3><p> To install Poetry on OSX, use the following:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python\n</code></pre>\n<!--kg-card-end: markdown--><p>This will create an addition to your <code>~/.bash_profile</code>. Restart your terminal and verify the installation:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ poetry --version\nPoetry 0.12.10\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"creating-a-new-python-project\">Creating a New Python Project</h3><p>Navigate to whichever file path you'd like your new project to call home. To get started, all we need next is the following command:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">poetry new my-package\n</code></pre>\n<!--kg-card-end: markdown--><p>Ready for a breath of fresh air? This command generates a basic project structure for you- something that's been missing from Python for a long time when compared to similar generators for Node or otherwise. The resulting project structure looks as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">my-package\n├── pyproject.toml\n├── README.rst\n├── my_package\n│   └── __init__.py\n└── tests\n    ├── __init__.py\n    └── test_my_package\n</code></pre>\n<!--kg-card-end: markdown--><p>Of the beautiful things happening here, the only one we haven't touched on yet is Poetry's built-in integration with <strong>pytest</strong>. Oh, happy day!</p><h4 id=\"alternative-interactive-installation-method\">Alternative Interactive Installation Method</h4><p>If you'd prefer a bit more handholding, feel free to use <code>poetry init</code> in an empty directory (or a directory without the existing <strong>.toml</strong> file) to be walked through the creation process:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ poetry init\n\nThis command will guide you through creating your pyproject.toml config.\n\nPackage name [my-package]: Great Package\nVersion [0.1.0]:\nDescription []: Great package for great people.\nAuthor [Todd Birchard &lt;todd@hackersandslackers.com&gt;, n to skip]:\nLicense []: MIT\nCompatible Python versions [^2.7]: ^3.7\n\nWould you like to define your dependencies (require) interactively? (yes/no) [yes] no\n\n\n\nWould you like to define your dev dependencies (require-dev) interactively (yes/no) [yes] no\n\nGenerated file\n\n[tool.poetry]\nname = &quot;Great Package&quot;\nversion = &quot;0.1.0&quot;\ndescription = &quot;Great package for great people.&quot;\nauthors = [&quot;Todd Birchard &lt;todd@hackersandslackers.com&gt;&quot;]\nlicense = &quot;MIT&quot;\n\n[tool.poetry.dependencies]\npython = &quot;^3.7&quot;\n\n[tool.poetry.dev-dependencies]\n\n[build-system]\nrequires = [&quot;poetry&gt;=0.12&quot;]\nbuild-backend = &quot;poetry.masonry.api&quot;\n\n\nDo you confirm generation? (yes/no) [yes] yes\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"managing-dependencies-in-pyproject-toml\">Managing Dependencies in pyproject.toml</h2><p>If you're familiar with Pipfiles, pyproject.toml handles dependencies the same way. Just remember that <code>poetry install</code> installs your listed dependencies, and <code>poetry update</code> will update dependencies in <em>poetry.lock </em>to their latest versions.</p><h3 id=\"carry-on-my-wayward-son\">Carry on my Wayward Son</h3><p>I could spend all day copy-pasting general usage from the Poetry Github page, but I think my work here is done. Do yourself a favor and<a href=\"https://github.com/sdispater/poetry\"> take a look at the Github repo</a> to make your life easier forever. Or at least until the next replacement solution comes along.</p>","url":"https://hackersandslackers.com/poetic-python-project-packaging/","uuid":"10ddf06a-b12f-40b4-9849-2b057d3fe2f4","page":false,"codeinjection_foot":null,"codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@glorious/demo/dist/gdemo.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/@glorious/demo/dist/gdemo.min.js\"></script>\n","comment_id":"5c34086694d3e847951adf3e"}},"pageContext":{"slug":"poetic-python-project-packaging"}}