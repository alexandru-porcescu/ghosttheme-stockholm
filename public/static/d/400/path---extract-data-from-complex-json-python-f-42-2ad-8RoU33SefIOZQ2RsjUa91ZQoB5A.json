{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb867371b","title":"Extract Nested Data From Complex JSON","slug":"extract-data-from-complex-json-python","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/10/107@2x.jpg","excerpt":"Never manually walk through complex JSON objects again by using this function.","custom_excerpt":"Never manually walk through complex JSON objects again by using this function.","created_at_pretty":"10 October, 2018","published_at_pretty":"10 October, 2018","updated_at_pretty":"22 January, 2019","created_at":"2018-10-10T00:15:29.000-04:00","published_at":"2018-10-10T08:00:00.000-04:00","updated_at":"2019-01-22T15:20:23.000-05:00","meta_title":"Extract Nested Data From Complex JSON Trees | Hackers and Slackers","meta_description":"Never manually walk through complex JSON objects again by using this function","og_description":"Never manually walk through complex JSON objects again by using this function","og_image":"https://hackersandslackers.com/content/images/2018/10/107@2x.jpg","og_title":"Extract Nested Data From Complex JSON Trees | Hackers and Slackers","twitter_description":"Never manually walk through complex JSON objects again by using this function","twitter_image":"https://hackersandslackers.com/content/images/2018/10/107@2x.jpg","twitter_title":"Extract Nested Data From Complex JSON Trees | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"We're all data people here, so you already know the scenario: it happens perhaps\nonce a day, perhaps 5, or even more. There's an API you're working with, and\nit's great. It contains all the information you're looking for, but there's just\none problem: the complexity of nested JSON objects is endless, and suddenly the\njob you love needs to be put on hold to painstakingly retrieve the data you\nactually want, and it's 5 levels deep in a nested JSON hell. Nobody feels like\nmuch of a \"scientist\" or an \"engineer\" when half their day becomes dealing with\nkey value errors.\n\nLuckily, we code in Python!  (okay fine, language doesn't make much of a\ndifference here. It felt like a rallying call at the time).\n\nUsing Google Maps API as an Example\nTo visualize the problem, let's take an example somebody might actually want to\nuse. Â I think the  Google Maps API is a good candidate to fit the bill here.\n\nWhile Google Maps is actually a collection of APIs, the Google Maps Distance\nMatrix [https://developers.google.com/maps/documentation/distance-matrix/start].\nThe idea is that with a single API call, a user can calculate the distance and\ntime traveled between an origin and an infinite number of destinations. It's a\ngreat full-featured API, but as you might imagine the resulting JSON for\ncalculating commute time between where you stand and every location in the\nconceivable universe  makes an awfully complex JSON structure.\n\nGetting a Taste of JSON Hell\nReal quick, here's an example of the types of parameters this request accepts:\n\nimport requests\nimport API_KEY\n\ndef google_api_matrix():\n    \"\"\"Example Google Distance Matrix function.\"\"\"\n    endpoint = \"https://maps.googleapis.com/maps/api/distancematrix/json\"\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': 'New York City, NY',\n       'destinations': 'Philadelphia,PA',\n       'transit_mode': 'car'\n    }\n    r = requests.get(endpoint, params=params)\n    return r.json\n\n\nOne origin, one destination. The JSON response for a request this\nstraightforward is quite simple:\n\n{\n    \"destination_addresses\": [\n        \"Philadelphia, PA, USA\"\n    ],\n    \"origin_addresses\": [\n        \"New York, NY, USA\"\n    ],\n    \"rows\": [\n        {\n            \"elements\": [\n                {\n                    \"distance\": {\n                        \"text\": \"94.6 mi\",\n                        \"value\": 152193\n                    },\n                    \"duration\": {\n                        \"text\": \"1 hour 44 mins\",\n                        \"value\": 6227\n                    },\n                    \"status\": \"OK\"\n                }\n            ]\n        }\n    ],\n    \"status\": \"OK\"\n}\n\n\nFor each destination, we're getting two data points: the commute distance, and \nestimated duration. If we hypothetically wanted to extract those values, typing \nresponse['rows'][0]['elements']['distance']['test']  isn't too  crazy. I mean,\nit's somewhat awful and brings on casual thoughts of suicide, but nothing out of\nthe ordinary\n\nNow let's make things interesting by adding a few more stops on our trip:\n\nimport requests \nimport API_KEY\n\ndef google_api_matrix():\n    \"\"\"Example Google Distance Matrix function.\"\"\"\n    endpoint = \"https://maps.googleapis.com/maps/api/distancematrix/json\"\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': 'New York City, NY',\n       'destinations': 'Washington,DC|Philadelphia,PA|Santa Barbara,CA|Miami,FL|Austin,TX|Napa County,CA',\n       'transit_mode': 'car'\n    }\n    r = requests.get(endpoint, params=params)\n    return r.json\n\n\nOh fuuucckkkk:\n\n{\n  \"destination_addresses\": [\n    \"Washington, DC, USA\",\n    \"Philadelphia, PA, USA\",\n    \"Santa Barbara, CA, USA\",\n    \"Miami, FL, USA\",\n    \"Austin, TX, USA\",\n    \"Napa County, CA, USA\"\n  ],\n  \"origin_addresses\": [\n    \"New York, NY, USA\"\n  ],\n  \"rows\": [\n    {\n      \"elements\": [\n        {\n          \"distance\": {\n            \"text\": \"227 mi\",\n            \"value\": 365468\n          },\n          \"duration\": {\n            \"text\": \"3 hours 54 mins\",\n            \"value\": 14064\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"94.6 mi\",\n            \"value\": 152193\n          },\n          \"duration\": {\n            \"text\": \"1 hour 44 mins\",\n            \"value\": 6227\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"2,878 mi\",\n            \"value\": 4632197\n          },\n          \"duration\": {\n            \"text\": \"1 day 18 hours\",\n            \"value\": 151772\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"1,286 mi\",\n            \"value\": 2069031\n          },\n          \"duration\": {\n            \"text\": \"18 hours 43 mins\",\n            \"value\": 67405\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"1,742 mi\",\n            \"value\": 2802972\n          },\n          \"duration\": {\n            \"text\": \"1 day 2 hours\",\n            \"value\": 93070\n          },\n          \"status\": \"OK\"\n        },\n        {\n          \"distance\": {\n            \"text\": \"2,871 mi\",\n            \"value\": 4620514\n          },\n          \"duration\": {\n            \"text\": \"1 day 18 hours\",\n            \"value\": 152913\n          },\n          \"status\": \"OK\"\n        }\n      ]\n    }\n  ],\n  \"status\": \"OK\"\n}\n\n\nA lot is happening here. There are objects. There are lists. There are lists of\nobjects which are part of an object. The last thing I'd want to deal with is\ntrying to parse this data only to accidentally get a useless key:value pair like\n \"status\": \"OK\".\n\nCode Snippet To The Rescue\nLet's say we only want the human-readable data from this JSON, which is labeled \n\"text\"  for both distance and duration. We've created a function below dubbed \nextract_values()  to help us resolve this very issue. The idea is that \nextract_values()  is flexible and agnostic, therefore can be imported as a\nmodule into any project you might need.\n\n# recursivejson.py\n\ndef extract_values(obj, key):\n    \"\"\"Pull all values of specified key from nested JSON.\"\"\"\n    arr = []\n\n    def extract(obj, arr, key):\n        \"\"\"Recursively search for values of key in JSON tree.\"\"\"\n        if isinstance(obj, dict):\n            for k, v in obj.items():\n                if isinstance(v, (dict, list)):\n                    extract(v, arr, key)\n                elif k == key:\n                    arr.append(v)\n        elif isinstance(obj, list):\n            for item in obj:\n                extract(item, arr, key)\n        return arr\n\n    results = extract(obj, arr, key)\n    return results\n\n\nWe need to pass this function two values:\n\n * A JSON object, such as r.json()  from an API request.\n * The name of the key  we're looking to extract values from.\n\nnames = extract_values('myjson.json', 'name')\nprint(names)\n\n\nRegardless of where the key \"text\"  lives in the JSON, this function returns\nevery value for the instance of \"key.\" Here's our function in action:\n\nimport requests\nimport API_KEY\nfrom recursivejson import extract_values\n\n\ndef google_api_matrix():\n    \"\"\"Example Google Distance Matrix function.\"\"\"\n    endpoint = \"https://maps.googleapis.com/maps/api/distancematrix/json\"\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': \"New York City,NY\",\n       'destinations': \"Washington,DC|Philadelphia,PA|Santa Barbara,CA|Miami,FL|Austin,TX|Napa Valley,CA\",\n       'transit_mode': 'car',\n    }\n\n   r = requests.get(endpoint, params=params)\n   travel_values = extract_values(r.json(), 'text')\n   return travel_values\n\n\nRunning this function will result in the following output:\n\n['227 mi', '3 hours 54 mins', '94.6 mi', '1 hour 44 mins', '2,878 mi', '1 day 18 hours', '1,286 mi', '18 hours 43 mins', '1,742 mi', '1 day 2 hours', '2,871 mi', '1 day 18 hours']\n\n\nOh fiddle me timbers! Because the Google API alternates between distance and \ntrip duration, every other value alternates between distance and time (can we\npause to appreciate this horrible design? There are infinitely better ways to\nstructure this response). Never fear, some simple Python can help us split this\nlist into two lists:\n\nmy_values = extract_values(r.json(), 'text')\n\ndurations = my_values[1::2]\ndistances = my_values[2::1]\n\nprint('DURATIONS = ', durations)\nprint('DISTANCES = ', distances)\n\n\nThis will take our one list and split it in to two  lists, alternating between\neven and odd:\n\nDURATIONS = ['3 hours 54 mins', '1 hour 44 mins', '1 day 18 hours', '18 hours 43 mins', '1 day 2 hours', '1 day 18 hours']\nDISTANCES = ['94.6 mi', '1 hour 44 mins', '2,878 mi', '1 day 18 hours', '1,286 mi', '18 hours 43 mins', '1,742 mi', '1 day 2 hours', '2,871 mi', '1 day 18 hours']\n\n\nGetting Creative With Lists\nA common theme I run in to while extracting lists of values from JSON objects\nlike these is that the lists of values I extract are very much related. Â In the\nabove example, for every duration  we have an accompanying distance, which is a\none-to-one basis. Imagine if we wanted to associate these values somehow?\n\nTo use a better example, I recently I used this exact_values()  function to\nextract lists of column names and their data types from a database schema. As\nseparate lists, the data looked something like this:\n\ncolumn_names = ['index', 'first_name', 'last_name', 'join_date']\ncolumn_datatypes = ['integer', 'string', 'string', 'date']\n\n\nClearly these two lists are directly related; the latter is describing the\nformer. How can this be useful? By using Python's zip  method!\n\nschema_dict = dict(zip(column_names, column_datatypes))\nprint(schema_dict)\n\n\nI like to think they call it zip  because it's like zipping up a zipper, where\neach side of the zipper is a list. This output a dictionary where list 1 serves\nas the keys, and list 2 serves as values:\n\n{\n'index': 'integer', \n'first_name': 'string', \n'last_name':'string',\n'join_date': 'date'\n}\n\n\nAnd there you have it folks: a free code snippet to copy and secretly pretend\nyou wrote forever. I've thrown the function up on Github Gists\n[https://gist.github.com/toddbirchard/b6f86f03f6cf4fc9492ad4349ee7ff8b], if such\na thing pleases you.\n\nIn the meantime, zip it up and zip it out. Zippity-do-da, buh bye.","html":"<p>We're all data people here, so you already know the scenario: it happens perhaps once a day, perhaps 5, or even more. There's an API you're working with, and it's great. It contains all the information you're looking for, but there's just one problem: the complexity of nested JSON objects is endless, and suddenly the job you love needs to be put on hold to painstakingly retrieve the data you actually want, and it's 5 levels deep in a nested JSON hell. Nobody feels like much of a \"scientist\" or an \"engineer\" when half their day becomes dealing with key value errors.</p><p>Luckily, we code in <strong><em>Python!</em></strong> (okay fine, language doesn't make much of a difference here. It felt like a rallying call at the time).</p><h2 id=\"using-google-maps-api-as-an-example\">Using Google Maps API as an Example</h2><p>To visualize the problem, let's take an example somebody might actually want to use. Â I think the<strong> Google Maps API </strong>is a good candidate to fit the bill here.</p><p>While Google Maps is actually a collection of APIs, the <a href=\"https://developers.google.com/maps/documentation/distance-matrix/start\">Google Maps Distance Matrix</a>. The idea is that with a single API call, a user can calculate the distance and time traveled between an origin and an infinite number of destinations. It's a great full-featured API, but as you might imagine the resulting JSON for calculating commute time between where you stand and <em>every location in the conceivable universe</em> makes an awfully complex JSON structure.</p><h3 id=\"getting-a-taste-of-json-hell\">Getting a Taste of JSON Hell</h3><p>Real quick, here's an example of the types of parameters this request accepts:</p><pre><code class=\"language-python\">import requests\nimport API_KEY\n\ndef google_api_matrix():\n    &quot;&quot;&quot;Example Google Distance Matrix function.&quot;&quot;&quot;\n    endpoint = &quot;https://maps.googleapis.com/maps/api/distancematrix/json&quot;\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': 'New York City, NY',\n       'destinations': 'Philadelphia,PA',\n       'transit_mode': 'car'\n    }\n    r = requests.get(endpoint, params=params)\n    return r.json\n</code></pre>\n<p>One origin, one destination. The JSON response for a request this straightforward is quite simple:</p><pre><code class=\"language-json\">{\n    &quot;destination_addresses&quot;: [\n        &quot;Philadelphia, PA, USA&quot;\n    ],\n    &quot;origin_addresses&quot;: [\n        &quot;New York, NY, USA&quot;\n    ],\n    &quot;rows&quot;: [\n        {\n            &quot;elements&quot;: [\n                {\n                    &quot;distance&quot;: {\n                        &quot;text&quot;: &quot;94.6 mi&quot;,\n                        &quot;value&quot;: 152193\n                    },\n                    &quot;duration&quot;: {\n                        &quot;text&quot;: &quot;1 hour 44 mins&quot;,\n                        &quot;value&quot;: 6227\n                    },\n                    &quot;status&quot;: &quot;OK&quot;\n                }\n            ]\n        }\n    ],\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre>\n<p>For each destination, we're getting two data points: the <em>commute distance</em>, and <em>estimated duration</em>. If we hypothetically wanted to extract those values, typing <code>response['rows'][0]['elements']['distance']['test']</code> isn't <em>too</em> crazy. I mean, it's somewhat awful and brings on casual thoughts of suicide, but nothing out of the ordinary</p><p>Now let's make things interesting by adding a few more stops on our trip:</p><pre><code class=\"language-python\">import requests \nimport API_KEY\n\ndef google_api_matrix():\n    &quot;&quot;&quot;Example Google Distance Matrix function.&quot;&quot;&quot;\n    endpoint = &quot;https://maps.googleapis.com/maps/api/distancematrix/json&quot;\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': 'New York City, NY',\n       'destinations': 'Washington,DC|Philadelphia,PA|Santa Barbara,CA|Miami,FL|Austin,TX|Napa County,CA',\n       'transit_mode': 'car'\n    }\n    r = requests.get(endpoint, params=params)\n    return r.json\n</code></pre>\n<p>Oh fuuucckkkk:</p><pre><code class=\"language-json\">{\n  &quot;destination_addresses&quot;: [\n    &quot;Washington, DC, USA&quot;,\n    &quot;Philadelphia, PA, USA&quot;,\n    &quot;Santa Barbara, CA, USA&quot;,\n    &quot;Miami, FL, USA&quot;,\n    &quot;Austin, TX, USA&quot;,\n    &quot;Napa County, CA, USA&quot;\n  ],\n  &quot;origin_addresses&quot;: [\n    &quot;New York, NY, USA&quot;\n  ],\n  &quot;rows&quot;: [\n    {\n      &quot;elements&quot;: [\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;227 mi&quot;,\n            &quot;value&quot;: 365468\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;3 hours 54 mins&quot;,\n            &quot;value&quot;: 14064\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        },\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;94.6 mi&quot;,\n            &quot;value&quot;: 152193\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;1 hour 44 mins&quot;,\n            &quot;value&quot;: 6227\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        },\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;2,878 mi&quot;,\n            &quot;value&quot;: 4632197\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;1 day 18 hours&quot;,\n            &quot;value&quot;: 151772\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        },\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;1,286 mi&quot;,\n            &quot;value&quot;: 2069031\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;18 hours 43 mins&quot;,\n            &quot;value&quot;: 67405\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        },\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;1,742 mi&quot;,\n            &quot;value&quot;: 2802972\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;1 day 2 hours&quot;,\n            &quot;value&quot;: 93070\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        },\n        {\n          &quot;distance&quot;: {\n            &quot;text&quot;: &quot;2,871 mi&quot;,\n            &quot;value&quot;: 4620514\n          },\n          &quot;duration&quot;: {\n            &quot;text&quot;: &quot;1 day 18 hours&quot;,\n            &quot;value&quot;: 152913\n          },\n          &quot;status&quot;: &quot;OK&quot;\n        }\n      ]\n    }\n  ],\n  &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre>\n<p>A lot is happening here. There are objects. There are lists. There are lists of objects which are part of an object. The last thing I'd want to deal with is trying to parse this data only to accidentally get a useless key:value pair like <strong>\"status\": \"OK\".</strong></p><h2 id=\"code-snippet-to-the-rescue\">Code Snippet To The Rescue</h2><p>Let's say we only want the human-readable data from this JSON, which is labeled <em>\"text\"</em> for both distance and duration. We've created a function below dubbed <code>extract_values()</code> to help us resolve this very issue. The idea is that <code>extract_values()</code> is flexible and agnostic, therefore can be imported as a module into any project you might need.</p><pre><code class=\"language-python\"># recursivejson.py\n\ndef extract_values(obj, key):\n    &quot;&quot;&quot;Pull all values of specified key from nested JSON.&quot;&quot;&quot;\n    arr = []\n\n    def extract(obj, arr, key):\n        &quot;&quot;&quot;Recursively search for values of key in JSON tree.&quot;&quot;&quot;\n        if isinstance(obj, dict):\n            for k, v in obj.items():\n                if isinstance(v, (dict, list)):\n                    extract(v, arr, key)\n                elif k == key:\n                    arr.append(v)\n        elif isinstance(obj, list):\n            for item in obj:\n                extract(item, arr, key)\n        return arr\n\n    results = extract(obj, arr, key)\n    return results\n</code></pre>\n<p>We need to pass this function two values:</p><ul><li>A JSON object, such as <code>r.json()</code> from an API request.</li><li>The name of the <strong>key</strong> we're looking to extract values from.</li></ul><pre><code class=\"language-python\">names = extract_values('myjson.json', 'name')\nprint(names)\n</code></pre>\n<p>Regardless of where the key <strong>\"text\"</strong> lives in the JSON, this function returns every value for the instance of <strong>\"key.\" </strong>Here's our function in action:</p><pre><code class=\"language-python\">import requests\nimport API_KEY\nfrom recursivejson import extract_values\n\n\ndef google_api_matrix():\n    &quot;&quot;&quot;Example Google Distance Matrix function.&quot;&quot;&quot;\n    endpoint = &quot;https://maps.googleapis.com/maps/api/distancematrix/json&quot;\n    params = {\n       'units': 'imperial',\n       'key': API_KEY,\n       'origins': &quot;New York City,NY&quot;,\n       'destinations': &quot;Washington,DC|Philadelphia,PA|Santa Barbara,CA|Miami,FL|Austin,TX|Napa Valley,CA&quot;,\n       'transit_mode': 'car',\n    }\n\n   r = requests.get(endpoint, params=params)\n   travel_values = extract_values(r.json(), 'text')\n   return travel_values\n</code></pre>\n<p>Running this function will result in the following output:</p><pre><code class=\"language-python\">['227 mi', '3 hours 54 mins', '94.6 mi', '1 hour 44 mins', '2,878 mi', '1 day 18 hours', '1,286 mi', '18 hours 43 mins', '1,742 mi', '1 day 2 hours', '2,871 mi', '1 day 18 hours']\n</code></pre>\n<p>Oh <em>fiddle me timbers</em>! Because the Google API alternates between <strong>distance </strong>and <strong>trip duration</strong>, every other value alternates between distance and time (can we pause to appreciate this horrible design? There are infinitely better ways to structure this response). Never fear, some simple Python can help us split this list into two lists:</p><pre><code class=\"language-python\">my_values = extract_values(r.json(), 'text')\n\ndurations = my_values[1::2]\ndistances = my_values[2::1]\n\nprint('DURATIONS = ', durations)\nprint('DISTANCES = ', distances)\n</code></pre>\n<p>This will take our one list and split it in to <em>two</em> lists, alternating between even and odd:</p><pre><code class=\"language-python\">DURATIONS = ['3 hours 54 mins', '1 hour 44 mins', '1 day 18 hours', '18 hours 43 mins', '1 day 2 hours', '1 day 18 hours']\nDISTANCES = ['94.6 mi', '1 hour 44 mins', '2,878 mi', '1 day 18 hours', '1,286 mi', '18 hours 43 mins', '1,742 mi', '1 day 2 hours', '2,871 mi', '1 day 18 hours']\n</code></pre>\n<h2 id=\"getting-creative-with-lists\">Getting Creative With Lists</h2><p>A common theme I run in to while extracting lists of values from JSON objects like these is that the lists of values I extract are very much related. Â In the above example, for every <em>duration</em> we have an accompanying <em>distance, </em>which is a one-to-one basis. Imagine if we wanted to associate these values somehow?</p><p>To use a better example, I recently I used this <code>exact_values()</code> function to extract lists of column names and their data types from a database schema. As separate lists, the data looked something like this:</p><pre><code class=\"language-python\">column_names = ['index', 'first_name', 'last_name', 'join_date']\ncolumn_datatypes = ['integer', 'string', 'string', 'date']\n</code></pre>\n<p>Clearly these two lists are directly related; the latter is describing the former. How can this be useful? By using Python's <code>zip</code> method!</p><pre><code class=\"language-python\">schema_dict = dict(zip(column_names, column_datatypes))\nprint(schema_dict)\n</code></pre>\n<p>I like to think they call it <em>zip</em> because it's like zipping up a zipper, where each side of the zipper is a list. This output a dictionary where list 1 serves as the keys, and list 2 serves as values:</p><pre><code class=\"language-python\">{\n'index': 'integer', \n'first_name': 'string', \n'last_name':'string',\n'join_date': 'date'\n}\n</code></pre>\n<p>And there you have it folks: a free code snippet to copy and secretly pretend you wrote forever. I've thrown the function up on <a href=\"https://gist.github.com/toddbirchard/b6f86f03f6cf4fc9492ad4349ee7ff8b\">Github Gists</a>, if such a thing pleases you.</p><p>In the meantime, zip it up and zip it out. Zippity-do-da, buh bye.</p>","url":"https://hackersandslackers.com/extract-data-from-complex-json-python/","uuid":"9a494df4-9e13-45ed-8648-efdda21c55a4","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5bbd7ce1b936605163ece407"}},"pageContext":{"slug":"extract-data-from-complex-json-python"}}