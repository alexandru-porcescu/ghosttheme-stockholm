{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736c6","title":"Using MongoDB Atlas as your Flask Database","slug":"using-mongodb-atlas-as-your-flask-database","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","excerpt":"Since you prefer using Python and Flask, I’ll assume we both prefer enjoyable dev.","custom_excerpt":"Since you prefer using Python and Flask, I’ll assume we both prefer enjoyable dev.","created_at_pretty":"28 July, 2018","published_at_pretty":"31 July, 2018","updated_at_pretty":"07 March, 2019","created_at":"2018-07-28T13:42:54.000-04:00","published_at":"2018-07-31T16:59:00.000-04:00","updated_at":"2019-03-07T01:02:11.000-05:00","meta_title":"Using MongoDB Atlas as your Flask Database | Hackers And Slackers","meta_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","og_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","og_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","og_title":"Using MongoDB Atlas as your Flask Database","twitter_description":"MongoDB Atlas and Stitch are easy to use, making Mongo’s cloud offering a natural choice for quick Flask-based applications.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/flaskpymongo@2x.jpg","twitter_title":"Using MongoDB Atlas as your Flask Database","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"It's been roughly a year since MongoDB launched their Stitch: a \"back-end as a\nservice\" cloud offering. I've been tinkering with Mongo on the cloud ever\nsince... Alright fine, \"tinkering with\"  may better be described as\"accidentally\nbecame dependent on it after developing new features in production\nenvironments,\" but I can't really complain thus-far. If you're not familiar, \nMongoDB Atlas  is MongoDB's cloud-hosted database offering; that is to say, the\nsame as any other MongoDB database, except very expensive.\n\nThe jury is still out on how MongoDB Atlas  and its counterpart Stitch  will fit\ninto the picture of next generation cloud services. That said, I can vouch that\nMongo products are simply fun to use  for developers, especially when compared\nto  traditional rigid alternatives. Since I would also group Python  and Flask \nin the 'fun to use' category, selecting MongoDB as the database for your Flask\napp makes a lot of sense.\n\nFor this tutorial we're going to set up a simple app where users can submit\ninformation via a form to MongoDB. After writing to our database, we'll query\nthe db to see the results. The result will be a Flask app with the following\nfile structure:\n\nmy-flask-project\n├── templates/\n├── static/\n├── app.py\n├── config.py\n├── currenttime.py\n└── form.py\n\n\nConnect to your Database with PyMongo\nPyMongo  is Python's go-to library for interacting with MongoDB. \n\nWe'll keep all database connection logic within db.py. After importing PyMongo,\nmost of the configuration we need to handle happens in a single line containing\nour MongoDB URI: the massive string which contains our DB location, creds, and\nauthorization DB. The string is broken down like this:\n\nmongodb+srv://[username]:[password]@[projectname]-gktww.gcp.mongodb.net/[authDB]\n\n\nAuthenticate with a [username]  and [password] you’ve set up in whichever\ndatabase handles authentication for your MongoDB instance (this is also what \n[authDB]  is referring to). \n\n[projectname]  is the unique name of your cloud instance. The rest of the URI\ncontains some nonsense, including the host of your particular instance (I’m\nusing Google Cloud, hence the .gcp in the URI). Most of this information can be\nfound just by jumping on mongodb.com [https://www.mongodb.com/]  and\ninvestigating your URI via the \"connect\" popup:\n\nThat should make things a bit easier.Now we can set up our connection:\n\nimport pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@hackerdata-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\n\nNote that we intentionally set the connection to False. Otherwise, we're going\nto find ourselves in a hell of managing open connections every time we interact\nwith the DB.\n\nSpeaking of the DB, we need to specify which database and collection we want to\ninteract with. This brings our config file to something as follows:\n\nimport pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\n\nLastly, if you'd like to access, say, all the objects inside of a collection (or\nsimilar query), we'll just need to add a few lines line to ensure we're reading\nthe collection's data:\n\nimport pymongo\nfrom bson.json_util import dumps\nimport json\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\ncol_results = json.loads(dumps(col.find().limit(5).sort(\"time\", -1)))\n\n\nRemember that Mongo returns BSON objects as opposed to JSON objects, which isn't\nvery useful for our purposes. To alleviate this we'll do a messy little dance to\nconvert Mongo's BSON into a string, and convert this to JSON using json.dumps().\n\nNote: the need to do this may have been something changed in recent versions of\nMongo, as I have older application functioning where this wasn't the case.\n¯\\_(ツ)_/¯.\n\nCreating a Form\nHeading over to form.py, we just need to set up a simple single-field form for\nusers to submit their URLs. For the sake of Python, let's say we're only\naccepting URLs for Jupyter noteboooks:\n\nfrom wtforms import Form, StringField, validators\nfrom wtforms.validators import DataRequired, Regexp\n\nclass myForm(Form):\n    \"\"\"Homepage form.\"\"\"\n    PlotlyURL = StringField('Provide a raw .ipynb URL from Github',\n    validators=[\n            DataRequired(),\n            Regexp(\".*\\.ipynb$\",\n            message=\"Please provide a URL ending in ipynb\"),\n          ])\n\n\nWe could have an entire tutorial just about Flask's WTForms\n[http://flask.pocoo.org/docs/1.0/patterns/wtforms/], but let's stay on topic\n and move on to currenttime.py.\n\nAdding Time Metadata\nIn a lot of cases where we store information to a database, we at least want to\nadd certain metadata such as the time something was added. This allows us to\narrange results by most recently updated, which we'll be doing in this example.\n\nfrom datetime import datetime, timezone\n\ndef getTime():\n    \"\"\"Get user's current time\"\"\"\n    rightnow = datetime.today()\n    return rightnow\n\ndef getPrettyTime():\n    \"\"\"Get user's pretty current time\"\"\"\n    rightnow = datetime.today()\n    prettytime = rightnow.ctime()\n    return prettytime\n\nyourtime = getTime()\nprettytime = getPrettyTime()\n\n\nThe variable yourtime  will be a datetime string representing the local time of\nthe user creating a new record. We will use this value to sort the queried\nresults by time. On the contrary,prettytime  will be the same time, only\nformatted in a way that is readable to humans.\n\nPutting the Pieces Together\nFinally we get to move on app.py and get this thing moving. We'll initiate our\napp by importing the necessary libraries, as well as the scripts we just\ncreated:\n\nfrom flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n\nNote that we need to import from the DB config we set earlier is the \"col\"\nvariable; we'll only be interacting directly with the collection we want to\nmodify, and the rest is assumed within the config file itself. Now let's build a\nroute for our homepage that does two things:\n\n * Allows users to submit a URL via the simple form we created\n * Displays all previous searches by all users.\n\nfrom flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    recent_searches = list(col_results)\n    return render_template('/index.html', form=myForm(), recents=recent_searches, template=\"home-template\")\n\n\nThere's only two significant lines here, but let's break them down piece by\npiece.\n\nrecent_searches\nFirst we set a recent_searches  variable which is essentially a query against\nour collection to retrieve a list of previous searches. We ask that these be\nreturned as a list()  upfront. Typically the find() method would contain the\nconstraints of our query, but we're simply asking to return all  results in the\ncollection, with a limit()  up to 5. Finally, we sort()  the results by the\nfield we refer to as 'time' is descending order, as noted by the -1 argument.\n\nThis is all probably very difficult to visualize without a graphic. Here's a\nsnapshot of the collection we're defining with dummy data added:\n\nSee why we need to differentiate \"time\" and \"prettytime\"?render_template\nWe already know [https://hackersandslackers.com/serving-static-assets-in-flask/] \n the basics of serving templates and assets in Flask, so it shouldn't be too\ndifficult to break down the last line in our route:\n\n * '/index.html'  specifies the base template we'll be serving up.\n * form=myForm()  passes the form class we created earlier to the form partial\n   we're including as part of the index page.\n * recents=recent_searches  passes the query of previous searches to the\n   template, with which we can build a widget.\n * template=\"home-template\" is a simple variable passed which we'll utilize as a\n   class on the page we're loading.\n\nThe Result\nFrom everything we've completed, you should be expecting to see a somewhat\nworthless page where users can submit links via a form, simply to see results\nposted by previous posters. If we expand on this idea just a bit, we can see how\nsomething so simple can actually be extended to a full product: \n\n> Planet Jupyter [https://planetjupyter.com]\nStyle your Jupyter Notebooks.\n\n\nPlanet Jupyter is demo product we built at H&S to style Jupyter notebooks.\nPerhaps 60% of the logic behind Planet Jupyter is the simple DB interactions we\njust covered, with the rest being added flair.\n\nThis is not a shameless plug for the barely functioning toys we've built, mind\nyou, but rather an example of simple DB interactions using Flask can be easily\nextensible into relevant, useful, products.\n\nWe hope you’ve found this tutorial to be useful!","html":"<p>It's been roughly a year since MongoDB launched their <strong>Stitch: </strong>a \"back-end as a service\" cloud offering. I've been tinkering with Mongo on the cloud ever since... Alright fine, <em>\"tinkering with\"</em> may better be described as  <em>\"accidentally became dependent on it after developing new features in production environments,\" </em>but I can't really complain thus-far. If you're not familiar, <strong>MongoDB Atlas</strong> is MongoDB's cloud-hosted database offering; that is to say, the same as any other MongoDB database, except very expensive.</p><p>The jury is still out on how MongoDB <strong>Atlas</strong> and its counterpart <strong>Stitch</strong> will fit into the picture of next generation cloud services. That said, I can vouch that Mongo products are simply <em>fun to use</em> for developers, especially when compared to  traditional rigid alternatives. Since I would also group <em>Python</em> and <em>Flask</em> in the 'fun to use' category, selecting MongoDB as the database for your Flask app makes a lot of sense.</p><p>For this tutorial we're going to set up a simple app where users can submit information via a form to MongoDB. After writing to our database, we'll query the db to see the results. The result will be a Flask app with the following file structure:</p><pre><code class=\"language-shell\">my-flask-project\n├── templates/\n├── static/\n├── app.py\n├── config.py\n├── currenttime.py\n└── form.py\n</code></pre>\n<h2 id=\"connect-to-your-database-with-pymongo\">Connect to your Database with PyMongo</h2><p><strong>PyMongo</strong> is Python's go-to library for interacting with MongoDB. </p><p>We'll keep all database connection logic within <strong>db.py</strong>. After importing PyMongo, most of the configuration we need to handle happens in a single line containing our MongoDB URI: the massive string which contains our DB location, creds, and authorization DB. The string is broken down like this:</p><pre><code class=\"language-shell\">mongodb+srv://[username]:[password]@[projectname]-gktww.gcp.mongodb.net/[authDB]\n</code></pre>\n<p>Authenticate with a <strong>[username]</strong> and <strong>[password] </strong>you’ve set up in whichever database handles authentication for your MongoDB instance (this is also what<strong> [authDB]</strong> is referring to). </p><p><strong>[projectname]</strong> is the unique name of your cloud instance. The rest of the URI contains some nonsense, including the host of your particular instance (I’m using Google Cloud, hence the .gcp in the URI). Most of this information can be found just by jumping on <a href=\"https://www.mongodb.com/\">mongodb.com</a> and investigating your URI via the \"connect\" popup:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2018-07-30-at-9.46.42-PM.png\" class=\"kg-image\"><figcaption>That should make things a bit easier.</figcaption></figure><p>Now we can set up our connection:</p><pre><code class=\"language-python\">import pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@hackerdata-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n</code></pre>\n<p>Note that we intentionally set the connection to <strong>False. </strong>Otherwise, we're going to find ourselves in a hell of managing open connections every time we interact with the DB.</p><p>Speaking of the DB, we need to specify which database and collection we want to interact with. This brings our config file to something as follows:</p><pre><code class=\"language-python\">import pymongo\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n</code></pre>\n<p>Lastly, if you'd like to access, say, all the objects inside of a collection (or similar query), we'll just need to add a few lines line to ensure we're reading the collection's data:</p><pre><code class=\"language-python\">import pymongo\nfrom bson.json_util import dumps\nimport json\n\nmongo = pymongo.MongoClient('mongodb+srv://username:password@myInstance-gktww.gcp.mongodb.net/admin', maxPoolSize=50, connect=False)\n\ndb = pymongo.database.Database(mongo, 'mydatabase')\ncol = pymongo.collection.Collection(db, 'mycollection')\n\ncol_results = json.loads(dumps(col.find().limit(5).sort(&quot;time&quot;, -1)))\n</code></pre>\n<p>Remember that Mongo returns BSON objects as opposed to JSON objects, which isn't very useful for our purposes. To alleviate this we'll do a messy little dance to convert Mongo's BSON into a string, and convert this to JSON using <strong>json.dumps()</strong>.</p><p><strong>Note: </strong>the need to do this may have been something changed in recent versions of Mongo, as I have older application functioning where this wasn't the case. ¯\\_(ツ)_/¯.</p><h2 id=\"creating-a-form\">Creating a Form</h2><p>Heading over to <strong>form.py, </strong>we just need to set up a simple single-field form for users to submit their URLs. For the sake of Python, let's say we're only accepting URLs for Jupyter noteboooks:</p><pre><code class=\"language-python\">from wtforms import Form, StringField, validators\nfrom wtforms.validators import DataRequired, Regexp\n\nclass myForm(Form):\n    &quot;&quot;&quot;Homepage form.&quot;&quot;&quot;\n    PlotlyURL = StringField('Provide a raw .ipynb URL from Github',\n    validators=[\n            DataRequired(),\n            Regexp(&quot;.*\\.ipynb$&quot;,\n            message=&quot;Please provide a URL ending in ipynb&quot;),\n          ])\n</code></pre>\n<p>We could have an entire tutorial just about Flask's WTF<a href=\"http://flask.pocoo.org/docs/1.0/patterns/wtforms/\">orms</a>, but let's stay on topic  and move on to <strong>currenttime.py.</strong></p><h2 id=\"adding-time-metadata\">Adding Time Metadata</h2><p>In a lot of cases where we store information to a database, we at least want to add certain metadata such as the time something was added. This allows us to arrange results by most recently updated, which we'll be doing in this example.</p><pre><code class=\"language-python\">from datetime import datetime, timezone\n\ndef getTime():\n    &quot;&quot;&quot;Get user's current time&quot;&quot;&quot;\n    rightnow = datetime.today()\n    return rightnow\n\ndef getPrettyTime():\n    &quot;&quot;&quot;Get user's pretty current time&quot;&quot;&quot;\n    rightnow = datetime.today()\n    prettytime = rightnow.ctime()\n    return prettytime\n\nyourtime = getTime()\nprettytime = getPrettyTime()\n</code></pre>\n<p>The variable <strong>yourtime</strong> will be a datetime string representing the local time of the user creating a new record. We will use this value to sort the queried results by time. On the contrary,  <strong>prettytime</strong> will be the same time, only formatted in a way that is readable to humans.</p><h2 id=\"putting-the-pieces-together\">Putting the Pieces Together</h2><p>Finally we get to move on <strong>app.py </strong>and get this thing moving. We'll initiate our app by importing the necessary libraries, as well as the scripts we just created:</p><pre><code class=\"language-python\">from flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n</code></pre>\n<p>Note that we need to import from the DB config we set earlier is the \"col\" variable; we'll only be interacting directly with the collection we want to modify, and the rest is assumed within the config file itself. Now let's build a route for our homepage that does two things:</p><ul><li>Allows users to submit a URL via the simple form we created</li><li>Displays all previous searches by all users.</li></ul><pre><code class=\"language-python\">from flask import Flask, render_template, Markup, request, redirect\nfrom config import col, col_results\nimport requests\nfrom form import myForm\nfrom flask_static_compress import FlaskStaticCompress\nfrom currenttime import yourtime, prettytime\nimport logging\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    recent_searches = list(col_results)\n    return render_template('/index.html', form=myForm(), recents=recent_searches, template=&quot;home-template&quot;)\n</code></pre>\n<p>There's only two significant lines here, but let's break them down piece by piece.</p><h3 id=\"recent_searches\">recent_searches</h3><p>First we set a <strong>recent_searches</strong> variable which is essentially a query against our collection to retrieve a list of previous searches. We ask that these be returned as a <strong>list()</strong> upfront. Typically the <strong>find() </strong>method would contain the constraints of our query, but we're simply asking to return <em>all</em> results in the collection, with a <strong>limit()</strong> up to 5. Finally, we <strong>sort()</strong> the results by the field we refer to as 'time' is descending order, as noted by the -1 argument.</p><p>This is all probably very difficult to visualize without a graphic. Here's a snapshot of the collection we're defining with dummy data added:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2018-07-31-at-11.08.44-AM.png\" class=\"kg-image\"><figcaption>See why we need to differentiate \"time\" and \"prettytime\"?</figcaption></figure><h3 id=\"render_template\">render_template</h3><p>We <a href=\"https://hackersandslackers.com/serving-static-assets-in-flask/\">already know</a> the basics of serving templates and assets in Flask, so it shouldn't be too difficult to break down the last line in our route:</p><ul><li><strong>'/index.html'</strong> specifies the base template we'll be serving up.</li><li><strong>form=myForm()</strong> passes the form class we created earlier to the form partial we're including as part of the index page.</li><li><strong>recents=recent_searches</strong> passes the query of previous searches to the template, with which we can build a widget.</li><li><strong>template=\"home-template\" </strong>is a simple variable passed which we'll utilize as a class on the page we're loading.</li></ul><h2 id=\"the-result\">The Result</h2><p>From everything we've completed, you should be expecting to see a somewhat worthless page where users can submit links via a form, simply to see results posted by previous posters. If we expand on this idea just a bit, we can see how something so simple can actually be extended to a full product: </p><blockquote class=\"embedly-card\" data-card-controls=\"0\"><h4><a href=\"https://planetjupyter.com\">Planet Jupyter</a></h4><p>Style your Jupyter Notebooks.</p></blockquote>\n<script async src=\"//cdn.embedly.com/widgets/platform.js\" charset=\"UTF-8\"></script><p>Planet Jupyter is demo product we built at H&amp;S to style Jupyter notebooks. Perhaps 60% of the logic behind Planet Jupyter is the simple DB interactions we just covered, with the rest being added flair.</p><p>This is not a shameless plug for the barely functioning toys we've built, mind you, but rather an example of simple DB interactions using Flask can be easily extensible into relevant, useful, products.</p><p>We hope you’ve found this tutorial to be useful!</p>","url":"https://hackersandslackers.com/using-mongodb-atlas-as-your-flask-database/","uuid":"e8c92cbd-6845-45b5-acfc-a744810eafcd","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b5cab1e2189c353565a2adf"}},"pageContext":{"slug":"using-mongodb-atlas-as-your-flask-database"}}