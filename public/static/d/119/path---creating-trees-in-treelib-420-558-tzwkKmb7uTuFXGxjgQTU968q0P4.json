{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb867362f","title":"Generating Tree Hierarchies with Treelib","slug":"creating-trees-in-treelib","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2017/11/tree7@2x.jpg","excerpt":"Using Python to visualize file hierarchies as trees.","custom_excerpt":"Using Python to visualize file hierarchies as trees.","created_at_pretty":"17 November, 2017","published_at_pretty":"17 November, 2017","updated_at_pretty":"28 March, 2019","created_at":"2017-11-17T15:45:10.000-05:00","published_at":"2017-11-17T15:56:40.000-05:00","updated_at":"2019-03-28T05:02:39.000-04:00","meta_title":"Tree Hierarchies with Treelib | Hackers and Slackers","meta_description":"Treelib is a Python library that allows you to create a visual tree hierarchy: a simple plaintext representation of parent-child relationships.","og_description":"Treelib is a Python library that allows you to create a visual tree hierarchy: a simple plaintext representation of parent-child relationships.","og_image":"https://hackersandslackers.com/content/images/2017/11/tree7@2x.jpg","og_title":"Tree Hierarchies with Treelib","twitter_description":"Treelib is a Python library that allows you to create a visual tree hierarchy: a simple plaintext representation of parent-child relationships.","twitter_image":"https://hackersandslackers.com/content/images/2017/11/tree7@2x.jpg","twitter_title":"Tree Hierarchies with Treelib","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Vis","slug":"datavis","description":"Visualize your data with charting tools like Matplotlib, Plotly, D3, Chart.js, Muze, Seaborn, and countless others. Primarily focused on programmatic visualization as opposed to Business Intelligence software.","feature_image":null,"meta_description":"Visualize your data with charting tools like Matplotlib, Plotly, D3, Chart.js, Muze, Seaborn, and countless others. Focused on programmatic visualization.","meta_title":"Data Visualization | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"The first part of understanding any type of software is taking a glance at its\nfile structure. It may seem like an outlandish and redundant statement to make\nto a generation who grew up on GUIs. GitHub is essentially no more than a GUI\nfor Git, so it’s unsurprisingly that one of the largest company to follow a\nsimilar business model recently bought Github for millions. \n\nAll that said, a question remains: how do we being to understand closed source\napplications? If we can’t see the structure behind an app, I suppose we’ll have\nto build this model ourselves.\n\nTreelib [https://treelib.readthedocs.io/en/latest/]  is a Python library that\nallows you to create a visual tree hierarchy: a simple plaintext representation\nof parent-child relationships.\n\nAside from scraping and mapping the intellectual property of others, Treelib\ncomes in handy in situations where we have access to flat information (like a\ndatabase table) where rows actually relate to one another (such as monolithic\ncontent-heavy site).\n\nTreelib prints results like this: \n\nHarry\n├── Bill\n│   └── n1\n│       ├── n2\n│       └── n3\n└── Jane\n    ├── Diane\n    │   └── Mary\n    └── Mark \n\n\nIt’s is a simple library, and only requires knowledge of a few lines of code in\norder to be used effectively. What’s more, we’re not simply spitting out flat\nuseless data; we're storing these node relationships in memory. If needed, the\ntrees we build can be modified or used for other the future.\n\nWhere da Treez At?\nInstall the Treelib package:\n\npip install treelib\n\n\nIn your project, import Treelib:\n\n# trees.py\nimport from treelib import Node, Tree\n\n\nCreate a Tree with a Parent Node\nThe first step in utilizing Treelib is to create a tree object. We need to give\nour tree a name - this is essentially creating the top-level node that all other\nnodes will stem from. \n\nIn createNode(x, y), X is the value which will be displayed in the node, while Y\nis the unique identifier for that node. Children will be added to this parent\nnode by referencing the unique identifier.\n\nNote that in trees created with TreeLib, unique identifiers may only occur once.\nTherefore it is good to follow a sort of GUI system for identifying nodes.\n\n# tree.py\n\n# Create tree object\ntree = Tree() \n\n# Create the base node\ntree.create_node(\"Confluence\", \"confluence\") \n\n\nCreate Child Nodes\nThe last necessary part of creating a tree is, of course, populating the\nresulting children.\n\nWe will once again use create_node to add additional nodes, but these nodes will\nbe associated with parents via parent=”x”. This will locate existing nodes in\nthe tree by ID and associate these new nodes to that parent. This is why IDs\nmust be unique for each node in the tree.\n\n# tree.py\ntree.create_node(spaceName, id, parent=\"confluence\")\n\n\nView the Tree\nFinally, you'll want to view the fruits of your labor:\n\nprint(tree.show())\n\n\nWay to go Johnny Appleseed, that’s pretty much the gist of it. There are\nadditional features in the way Trees can be parse, and the way that nodes store\nadditional data.\n\nCheck the official documentation [https://treelib.readthedocs.io/en/latest/] \nfor a full list of features.\n\nBonus Round\nIf all you care about is printing the file structure of a current directory with\nzero interest in working with the actual data, you’re in luck (at least on Mac,\nhell if I know anything about Windows).\n\nUnix systems come with a package named tree  which does just what we want. On\nMac OSX, we can install tree  using Homebrew:\n\n$ brew install tree\n\n\nGo ahead and explore the various features of tree, such as writing to files or\neven doing so on a schedule. For now, here's some basic usage:\n\n$ tree -v -L 1 --charset utf-8","html":"<p>The first part of understanding any type of software is taking a glance at its file structure. It may seem like an outlandish and redundant statement to make to a generation who grew up on GUIs. GitHub is essentially no more than a GUI for Git, so it’s unsurprisingly that one of the largest company to follow a similar business model recently bought Github for millions. </p><p>All that said, a question remains: how do we being to understand closed source applications? If we can’t see the structure behind an app, I suppose we’ll have to build this model ourselves.</p><p><strong><a href=\"https://treelib.readthedocs.io/en/latest/\">Treelib</a></strong> is a Python library that allows you to create a visual tree hierarchy: a simple plaintext representation of parent-child relationships.</p><p>Aside from scraping and mapping the intellectual property of others, Treelib comes in handy in situations where we have access to flat information (like a database table) where rows actually relate to one another (such as monolithic content-heavy site).</p><p>Treelib prints results like this: </p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">Harry\n├── Bill\n│   └── n1\n│       ├── n2\n│       └── n3\n└── Jane\n    ├── Diane\n    │   └── Mary\n    └── Mark \n</code></pre>\n<!--kg-card-end: markdown--><p>It’s is a simple library, and only requires knowledge of a few lines of code in order to be used effectively. What’s more, we’re not simply spitting out flat useless data; we're storing these node relationships in memory. If needed, the trees we build can be modified or used for other the future.</p><h2 id=\"where-da-treez-at\">Where da Treez At?</h2><p>Install the Treelib package:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">pip install treelib\n</code></pre>\n<!--kg-card-end: markdown--><p>In your project, import Treelib:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># trees.py\nimport from treelib import Node, Tree\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"create-a-tree-with-a-parent-node\">Create a Tree with a Parent Node</h3><p>The first step in utilizing Treelib is to create a tree object. We need to give our tree a name - this is essentially creating the top-level node that all other nodes will stem from. </p><p>In createNode(x, y), X is the value which will be displayed in the node, while Y is the unique identifier for that node. Children will be added to this parent node by referencing the unique identifier.</p><p>Note that in trees created with TreeLib, unique identifiers may only occur once. Therefore it is good to follow a sort of GUI system for identifying nodes.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># tree.py\n\n# Create tree object\ntree = Tree() \n\n# Create the base node\ntree.create_node(&quot;Confluence&quot;, &quot;confluence&quot;) \n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"create-child-nodes\">Create Child Nodes</h2><p>The last necessary part of creating a tree is, of course, populating the resulting children.</p><p>We will once again use create_node to add additional nodes, but these nodes will be associated with parents via parent=”x”. This will locate existing nodes in the tree by ID and associate these new nodes to that parent. This is why IDs must be unique for each node in the tree.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># tree.py\ntree.create_node(spaceName, id, parent=&quot;confluence&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"view-the-tree\">View the Tree</h3><p>Finally, you'll want to view the fruits of your labor:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">print(tree.show())\n</code></pre>\n<!--kg-card-end: markdown--><p>Way to go Johnny Appleseed, that’s pretty much the gist of it. There are additional features in the way Trees can be parse, and the way that nodes store additional data.</p><p>Check the <a href=\"https://treelib.readthedocs.io/en/latest/\">official documentation</a> for a full list of features.</p><h2 id=\"bonus-round\">Bonus Round</h2><p>If all you care about is printing the file structure of a current directory with zero interest in working with the actual data, you’re in luck (at least on Mac, hell if I know anything about Windows).</p><p>Unix systems come with a package named <strong>tree</strong> which does just what we want. On Mac OSX, we can install <strong>tree</strong> using Homebrew:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ brew install tree\n</code></pre>\n<!--kg-card-end: markdown--><p>Go ahead and explore the various features of tree, such as writing to files or even doing so on a schedule. For now, here's some basic usage:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ tree -v -L 1 --charset utf-8\n</code></pre>\n<!--kg-card-end: markdown-->","url":"https://hackersandslackers.com/creating-trees-in-treelib/","uuid":"f0c176ee-c88a-443c-a7b7-b5c5e7c5b9f7","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5a0f4a56e38d612cc826130d"}},"pageContext":{"slug":"creating-trees-in-treelib"}}