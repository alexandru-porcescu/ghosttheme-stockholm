{"data":{"ghostTag":{"slug":"dataengineering","name":"Data Engineering","visibility":"public","feature_image":null,"description":"The systematic collection and transformation of data via the creation of tools and pipelines.","meta_title":"Data Engineering | Hackers and Slackers","meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5c95e08ef654036aa06c6a02","title":"Building an ETL Pipeline: From JIRA to SQL","slug":"building-an-etl-pipeline-from-jira-to-postgresql","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-3.jpg","excerpt":"An example data pipeline which extracts data from the JIRA Cloud API and loads it to a SQL database.","custom_excerpt":"An example data pipeline which extracts data from the JIRA Cloud API and loads it to a SQL database.","created_at_pretty":"23 March, 2019","published_at_pretty":"28 March, 2019","updated_at_pretty":"09 April, 2019","created_at":"2019-03-23T03:30:22.000-04:00","published_at":"2019-03-28T04:15:00.000-04:00","updated_at":"2019-04-08T23:34:47.000-04:00","meta_title":"Building an ETL Pipeline: From JIRA to SQL | Hackers and Slackers","meta_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","og_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","og_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-2.jpg","og_title":"Building an ETL Pipeline: From JIRA to SQL","twitter_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-1.jpg","twitter_title":"Building an ETL Pipeline: From JIRA to SQL","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"}],"plaintext":"Something we haven't done just yet on this site is walking through the humble\nprocess of creating data pipelines: the art of taking a bunch of data, changing\nsaid data, and putting it somewhere else. It's kind of a weird thing to be into,\nhence why the MoMA has been rejecting my submissions of Github repositories.\nDon't worry; I'll keep at it.\n\nSomething you don't see every day are people sharing their pipelines, which is\nunderstandable. Presumably, the other people who do this kind of stuff do it for\nwork; nobody is happily building stupid pipelines in their free time begging to\nbe open sourced. Except me.\n\nWe've recently revamped our projects [https://hackersandslackers.com/projects/] \npage to include a public-facing Kanban board using GraphQL. To achieve this, we\nneed to extract JIRA data from the JIRA Cloud REST API and place it securely in\nour database.\n\nStructuring our Pipeline\nAn ETL pipeline which is considered 'well-structured' is in the eyes of the\nbeholder. There are a million different ways to pull and mess with data, so\nthere isn't a \"template\" for building these things out. In my case, the\nstructure of my script just so happened to end up as three modules: one for \nextracting, one for loading, and one for transforming. This was unplanned, but\nit's a good sign when our app matches our mindset. Here's the breakdown:\n\njira-database-etl\n├── __main__.py\n├── jira_etl\n│   ├── __init__.py\n│   ├── fetch.py\n│   ├── data.py\n│   └── db.py\n├── LICENSE\n├── MANIFEST.in\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── requirements.txt\n├── setup.cfg\n└── setup.py\n\n\nmain.py  is our application entry point. The logic of our pipeline is stored in\nthree parts under the jira_etl  directory:\n\n * fetch.py  grabs the data from the source (JIRA Cloud's REST API) and handles\n   fetching all JIRA issues.\n * data.py  transforms the data we've fetched and constructs a neat DataFrame\n   containing only the information we're after.\n * db.py  finally loads the data into a SQL database.\n\nDon't look into it too much, but here's our entry point:\n\nfrom jira_etl import fetch\nfrom jira_etl import data\nfrom jira_etl import db\n\n\ndef main():\n    \"\"\"Application Entry Point.\n\n    1. Fetch all desired JIRA issues from an instance's REST API.\n    2. Sanitize the data and add secondary metadata.\n    3. Upload resulting DataFrame to database.\n    \"\"\"\n    jira_issues_json = fetch.FetchJiraIssues.fetch_all_results()\n    jira_issues_df = data.TransformData.construct_dataframe(jira_issues_json)\n    upload_status = db.DatabaseImport.upload_dataframe(jira_issues_df)\n    return upload_status\n\n\nWithout further adieu, let's dig into the logic!\n\nExtracting Our Data\nBefore doing anything, it's essential we become familiar with the data we're\nabout to pull. Firstly, JIRA's REST API returns paginated results which max out\nat 100 results per page. This means we'll have to loop through the pages\nrecursively until all results are loaded.\n\nNext, let's look at an example of a single  JIRA issue JSON object returned by\nthe API:\n\n{\n    \"expand\": \"names,schema\",\n    \"startAt\": 0,\n    \"maxResults\": 1,\n    \"total\": 888,\n    \"issues\": [\n        {\n            \"expand\": \"operations,versionedRepresentations,editmeta,changelog,renderedFields\",\n            \"id\": \"11718\",\n            \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/11718\",\n            \"key\": \"HACK-756\",\n            \"fields\": {\n                \"issuetype\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issuetype/10014\",\n                    \"id\": \"10014\",\n                    \"description\": \"Placeholder item for \\\"holy shit this is going to be a lot of work\\\"\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&avatarId=10311&avatarType=issuetype\",\n                    \"name\": \"Major Functionality\",\n                    \"subtask\": false,\n                    \"avatarId\": 10311\n                },\n                \"customfield_10070\": null,\n                \"customfield_10071\": null,\n                \"customfield_10073\": null,\n                \"customfield_10074\": null,\n                \"customfield_10075\": null,\n                \"project\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/project/10015\",\n                    \"id\": \"10015\",\n                    \"key\": \"HACK\",\n                    \"name\": \"Hackers and Slackers\",\n                    \"projectTypeKey\": \"software\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?pid=10015&avatarId=10535\",\n                        \"24x24\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=small&pid=10015&avatarId=10535\",\n                        \"16x16\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=xsmall&pid=10015&avatarId=10535\",\n                        \"32x32\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=medium&pid=10015&avatarId=10535\"\n                    }\n                },\n                \"fixVersions\": [],\n                \"resolution\": null,\n                \"resolutiondate\": null,\n                \"workratio\": -1,\n                \"lastViewed\": \"2019-03-24T02:01:31.355-0400\",\n                \"watches\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/watchers\",\n                    \"watchCount\": 1,\n                    \"isWatching\": true\n                },\n                \"created\": \"2019-02-03T00:47:36.677-0500\",\n                \"customfield_10062\": null,\n                \"customfield_10063\": null,\n                \"customfield_10064\": null,\n                \"customfield_10065\": null,\n                \"customfield_10066\": null,\n                \"priority\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/priority/2\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/images/icons/priorities/high.svg\",\n                    \"name\": \"High\",\n                    \"id\": \"2\"\n                },\n                \"customfield_10067\": null,\n                \"customfield_10068\": null,\n                \"customfield_10069\": [],\n                \"labels\": [],\n                \"versions\": [],\n                \"issuelinks\": [],\n                \"assignee\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"updated\": \"2019-03-24T02:01:30.724-0400\",\n                \"status\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/status/10004\",\n                    \"description\": \"\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/\",\n                    \"name\": \"To Do\",\n                    \"id\": \"10004\",\n                    \"statusCategory\": {\n                        \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/statuscategory/2\",\n                        \"id\": 2,\n                        \"key\": \"new\",\n                        \"colorName\": \"blue-gray\",\n                        \"name\": \"To Do\"\n                    }\n                },\n                \"components\": [],\n                \"description\": {\n                    \"version\": 1,\n                    \"type\": \"doc\",\n                    \"content\": [\n                        {\n                            \"type\": \"paragraph\",\n                            \"content\": [\n                                {\n                                    \"type\": \"text\",\n                                    \"text\": \"https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/\",\n                                    \"marks\": [\n                                        {\n                                            \"type\": \"link\",\n                                            \"attrs\": {\n                                                \"href\": \"https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/\"\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                },\n                \"customfield_10010\": null,\n                \"customfield_10011\": \"0|i0064j:i\",\n                \"customfield_10012\": null,\n                \"customfield_10013\": null,\n                \"security\": null,\n                \"customfield_10008\": \"HACK-143\",\n                \"customfield_10009\": {\n                    \"hasEpicLinkFieldDependency\": false,\n                    \"showField\": false,\n                    \"nonEditableReason\": {\n                        \"reason\": \"PLUGIN_LICENSE_ERROR\",\n                        \"message\": \"Portfolio for Jira must be licensed for the Parent Link to be available.\"\n                    }\n                },\n                \"summary\": \"Automate newsletter\",\n                \"creator\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"subtasks\": [],\n                \"reporter\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"customfield_10000\": \"{}\",\n                \"customfield_10001\": null,\n                \"customfield_10004\": null,\n                \"environment\": null,\n                \"duedate\": null,\n                \"votes\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/votes\",\n                    \"votes\": 0,\n                    \"hasVoted\": false\n                }\n            }\n        }\n    ]\n}\n\n\nWhoa, mama! That's a ton of BS for a single issue. You can see now why we'd want\nto transform this data before importing ten million fields into any database.\nMake note of these important fields:\n\n * startAt: An integer which tells us which issue number the paginated results\n   start at.\n * maxResults: Denotes the maximum number of results page - maxes out at 100\n   issues.\n * total: The total number of issues across all pages.\n * issues: A list of objects which contain the information for exactly one JIRA\n   issue per object\n\nGreat. So the purpose of fetch.py will essentially consist of creating a list of\nall 888  issues (in my case), and passing that off for transformation. Check it\nthe source I came up with:\n\nimport os\nimport math\nimport requests\n\n\nclass FetchJiraIssues:\n    \"\"\"Fetch all public-facing issues from JIRA instance.\n\n    1. Retrieve all values from env vars.\n    2. Construct request against JIRA REST API.\n    3. Fetch paginated issues via recursion.\n    4. Pass final JSON to be transformed into a DataFrame.\n     \"\"\"\n    results_per_page = 100\n    username = os.environ.get('JIRA_USERNAME')\n    password = os.environ.get('JIRA_PASSWORD')\n    endpoint = os.environ.get('JIRA_ENDPOINT')\n    jql = os.environ.get('JIRA_QUERY')\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    @classmethod\n    def get_total_number_of_issues(cls):\n        \"\"\"Gets the total number of results.\"\"\"\n        params = {\n            \"jql\": cls.jql,\n            \"maxResults\": 0,\n            \"startAt\": 0\n        }\n        req = requests.get(cls.endpoint,\n                           headers=cls.headers,\n                           params=params,\n                           auth=(cls.username, cls.password)\n                           )\n        response = req.json()\n        try:\n            total_results = response['total']\n            return total_results\n        except KeyError:\n            print('Could not find any issues!')\n\n    @classmethod\n    def fetch_all_results(cls):\n        \"\"\"Recursively retrieve all pages of JIRA issues.\"\"\"\n        total_results = cls.get_total_number_of_issues()\n        issue_arr = []\n\n        def fetch_single_page():\n            \"\"\"Fetch one page of results, and determine if another page exists.\"\"\"\n            params = {\n                \"jql\": cls.jql,\n                \"maxResults\": cls.results_per_page,\n                \"startAt\": len(issue_arr)\n            }\n            req = requests.get(cls.endpoint,\n                               headers=cls.headers,\n                               params=params,\n                               auth=(cls.username, cls.password)\n                               )\n            response = req.json()\n            issues = response['issues']\n            issues_so_far = len(issue_arr) + cls.results_per_page\n            print(issues_so_far, ' out of', total_results)\n            issue_arr.extend(issues)\n            # Check if additional pages of results exist.\n        count = math.ceil(total_results/cls.results_per_page)\n        for x in range(0, count):\n            fetch_single_page()\n        return issue_arr\n\n\nYep, I'm using classes. This class has two methods:\n\n * get_total_number_of_issues: All this does is essentially pull the number of\n   issues (888) from the REST API. We'll use this number in our next function to\n   check if additional pages exist.\n * fetch_all_results: This is where things start getting fun. fetch_all_results \n   is a @classmethod  which contains a function within itself. fetch_all_results \n    gets the total number of JIRA issues and then calls upon child function \n   fetch_single_page to pull JIRA issue JSON objects and dump them into a list\n   called issue_arr  until all issues are accounted for.\n\nBecause we have 888 issues and can retrieve 100 issues  at a time, our function\nfetch_single_page  should run 9 times. And it does!\n\nTransforming Our Data\nSo now we have a list of 888 messy JIRA issues. The scope of data.py  should be\nto pull out only the data we want, and make sure that data is clean:\n\nimport os\nimport json\nfrom pandas.io.json import json_normalize\nfrom datetime import datetime\n\n\nclass TransformData:\n    \"\"\"Build JIRA issue DataFrame.\n\n    1. Loop through JIRA issues and create a dictionary of desired data.\n    2. Convert each issue dictionary into a JSON object.\n    3. Load all issues into a Pandas DataFrame.\n    \"\"\"\n\n    issue_count = 0\n\n    @classmethod\n    def construct_dataframe(cls, issue_list_chunk):\n        \"\"\"Make DataFrame out of data received from JIRA API.\"\"\"\n        issue_list = [cls.make_issue_body(issue) for issue in issue_list_chunk]\n        issue_json_list = [cls.dict_to_json_string(issue) for issue in issue_list]\n        jira_issues_df = json_normalize(issue_json_list)\n        return jira_issues_df\n\n    @staticmethod\n    def dict_to_json_string(issue_dict):\n        \"\"\"Convert dict to JSON to string.\"\"\"\n        issue_json_string = json.dumps(issue_dict)\n        issue_json = json.loads(issue_json_string)\n        return issue_json\n\n    @classmethod\n    def make_issue_body(cls, issue):\n        \"\"\"Create a JSON body for each ticket.\"\"\"\n        updated_date = datetime.strptime(issue['fields']['updated'], \"%Y-%m-%dT%H:%M:%S.%f%z\")\n        body = {\n            'id': str(cls.issue_count),\n            'key': str(issue['key']),\n            'assignee_name': str(issue['fields']['assignee']['displayName']),\n            'assignee_url': str(issue['fields']['assignee']['avatarUrls']['48x48']),\n            'summary': str(issue['fields']['summary']),\n            'status': str(issue['fields']['status']['name']),\n            'priority_url': str(issue['fields']['priority']['iconUrl']),\n            'priority_rank': int(issue['fields']['priority']['id']),\n            'issuetype_name': str(issue['fields']['issuetype']['name']),\n            'issuetype_icon': str(issue['fields']['issuetype']['iconUrl']),\n            'epic_link': str(issue['fields']['customfield_10008']),\n            'project': str(issue['fields']['project']['name']),\n            'updated': int(datetime.timestamp(updated_date)),\n            'updatedAt': str(updated_date)\n        }\n        cls.issue_count += 1\n        return body\n\n\nAgain, let's see the methods at work:\n\n * construct_dataframe: The main function we invoke to build our DataFrame\n   (mostly just calls other methods). Once all transformations are completed,\n   creates a DataFrame called jira_df  by using the Pandas json_normalize() \n   method.\n * make_issue_body: Creates a new dictionary per singular JIRA issue. Extracts \n   only  the fields we want to be imported into our database. Converts each\n   field into either a string or an int as a lazy way of avoiding null values\n   (for example, if issue['fields']['priority']['name']  contained a null value,\n   the script would error out. Wrapping this in str() is a dirty way of\n   converting null  to an empty string).\n * dict_to_json_string  Takes each issue dictionary and converts it to a JSON\n   object, which is then turned into a string (this is done for Pandas).\n\nLoading Our Data\nAnd now for the final step! Thanks to the joyful marriage of Pandas and\nSQLAlchemy, turning DataFrames into SQL tables is super simple. We never make\nthings simple, though.\n\nimport os\nimport logging\nfrom sqlalchemy import create_engine, text, MetaData\nfrom sqlalchemy.types import Integer, Text, TIMESTAMP, String\nimport pandas as pd\n\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n\n\nclass DatabaseImport:\n    \"\"\"Merge Epic metadata and upload JIRA issues.\n\n    1. Merge Epic metadata by fetching an existing table.\n    2. Explicitly set data types for all columns found in jira_issues_df.\n    2. Create a new table from the final jira_issues_df.\n    \"\"\"\n\n    URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    db_epic_table = os.environ.get('SQLALCHEMY_EPIC_TABLE')\n    db_jira_table = os.environ.get('SQLALCHEMY_JIRA_TABLE')\n    db_schema = os.environ.get('SQLALCHEMY_DB_SCHEMA')\n\n    # Create Engine\n    meta = MetaData(schema=\"hackers$prod\")\n    engine = create_engine(URI, echo=True)\n\n    @staticmethod\n    def truncate_table(engine):\n        \"\"\"Clear table of data.\"\"\"\n        sql = text('TRUNCATE TABLE \"hackers$prod\".\"JiraIssue\"')\n        engine.execute(sql)\n\n    @classmethod\n    def merge_epic_metadata(cls, jira_issues_df):\n        \"\"\"Merge epic metadata from existing SQL table.\"\"\"\n        cls.truncate_table(cls.engine)\n        epics_df = pd.read_sql_table(cls.db_epic_table,\n                                     cls.engine,\n                                     schema=cls.db_schema)\n        jira_issues_df = pd.merge(jira_issues_df,\n                                  epics_df[['epic_link', 'epic_name', 'epic_color']],\n                                  how='left',\n                                  on='epic_link',\n                                  copy=False)\n        return jira_issues_df\n\n    @classmethod\n    def upload_dataframe(cls, jira_issues_df):\n        \"\"\"Upload JIRA DataFrame to PostgreSQL database.\"\"\"\n        jira_issues_df = cls.merge_epic_metadata(jira_issues_df)\n        jira_issues_df.to_sql(cls.db_jira_table,\n                              cls.engine,\n                              if_exists='append',\n                              schema=cls.db_schema,\n                              index=False,\n                              dtype={\"assignee\": String(30),\n                                     \"assignee_url\": Text,\n                                     \"epic_link\": String(50),\n                                     \"issuetype_name\": String(50),\n                                     \"issuetype_icon\": Text,\n                                     \"key\": String(10),\n                                     \"priority_name\": String(30),\n                                     \"priority_rank\": Integer,\n                                     \"priority_url\": Text,\n                                     \"project\": String(50),\n                                     \"status\": String(30),\n                                     \"summary\": Text,\n                                     \"updated\": Integer,\n                                     \"updatedAt\": TIMESTAMP,\n                                     \"createdAt\": TIMESTAMP,\n                                     \"epic_color\": String(20),\n                                     \"epic_name\": String(50)\n                                     })\n        success_message = 'Successfully uploaded' \\\n                          + str(len(jira_issues_df.index)) \\\n                          + ' rows to ' + cls.db_jira_table\n        return success_message\n\n\n * merge_epic_metadata: Due to the nature of the JIRA REST API, some metadata is\n   missing per issue. If you're interested, the data missing revolves around \n   Epics: JIRA's REST API does not include the Epic Name  or Epic Color  fields\n   of linked epics.\n * upload_dataframe: Uses Panda's to_sql()  method to upload our DataFrame into\n   a SQL table (our target happens to be PostgreSQL, so we pass schema  here).\n   To make things explicit, we set the data type of every column on upload.\n\nWell, let's see how we made out!\n\nA look at our resulting database table.Whoaaa nelly, we did it! With our data\nclean, we can now build something useful! Here's what I built:\n\nFruits of our labor!There we have it: a pipeline that takes a bunch of messy\ndata, cleans it, and puts it somewhere else for proper use.\n\nIf you're interested in how we created the frontend for our Kanban board, check\nout our series on building features with GraphQL\n[https://hackersandslackers.com/series/graphql-hype/]. For the source code,\ncheck out the Github repository\n[https://github.com/toddbirchard/jira-database-etl].","html":"<p>Something we haven't done just yet on this site is walking through the humble process of creating data pipelines: the art of taking a bunch of data, changing said data, and putting it somewhere else. It's kind of a weird thing to be into, hence why the MoMA has been rejecting my submissions of Github repositories. Don't worry; I'll keep at it.</p><p>Something you don't see every day are people sharing their pipelines, which is understandable. Presumably, the other people who do this kind of stuff do it for work; nobody is happily building stupid pipelines in their free time begging to be open sourced. Except me.</p><p>We've recently revamped our <strong><a href=\"https://hackersandslackers.com/projects/\">projects</a></strong> page to include a public-facing Kanban board using GraphQL. To achieve this, we need to extract JIRA data from the JIRA Cloud REST API and place it securely in our database.</p><h2 id=\"structuring-our-pipeline\">Structuring our Pipeline</h2><p>An ETL pipeline which is considered 'well-structured' is in the eyes of the beholder. There are a million different ways to pull and mess with data, so there isn't a \"template\" for building these things out. In my case, the structure of my script just so happened to end up as three modules: one for <em>extracting</em>, one for <em>loading</em>, and one for <em>transforming</em>. This was unplanned, but it's a good sign when our app matches our mindset. Here's the breakdown:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">jira-database-etl\n├── __main__.py\n├── jira_etl\n│   ├── __init__.py\n│   ├── fetch.py\n│   ├── data.py\n│   └── db.py\n├── LICENSE\n├── MANIFEST.in\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── requirements.txt\n├── setup.cfg\n└── setup.py\n</code></pre>\n<!--kg-card-end: markdown--><p><strong>main.py</strong> is our application entry point. The logic of our pipeline is stored in three parts under the <strong>jira_etl</strong> directory:</p><ul><li><strong>fetch.py</strong> grabs the data from the source (JIRA Cloud's REST API) and handles fetching all JIRA issues.</li><li><strong>data.py</strong> transforms the data we've fetched and constructs a neat DataFrame containing only the information we're after.</li><li><strong>db.py</strong> finally loads the data into a SQL database.</li></ul><p>Don't look into it too much, but here's our entry point:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from jira_etl import fetch\nfrom jira_etl import data\nfrom jira_etl import db\n\n\ndef main():\n    &quot;&quot;&quot;Application Entry Point.\n\n    1. Fetch all desired JIRA issues from an instance's REST API.\n    2. Sanitize the data and add secondary metadata.\n    3. Upload resulting DataFrame to database.\n    &quot;&quot;&quot;\n    jira_issues_json = fetch.FetchJiraIssues.fetch_all_results()\n    jira_issues_df = data.TransformData.construct_dataframe(jira_issues_json)\n    upload_status = db.DatabaseImport.upload_dataframe(jira_issues_df)\n    return upload_status\n</code></pre>\n<!--kg-card-end: markdown--><p>Without further adieu, let's dig into the logic!</p><h2 id=\"extracting-our-data\">Extracting Our Data</h2><p>Before doing anything, it's essential we become familiar with the data we're about to pull. Firstly, JIRA's REST API returns paginated results which max out at 100 results per page. This means we'll have to loop through the pages recursively until all results are loaded.</p><p>Next, let's look at an example of a <strong><em>single</em></strong> JIRA issue JSON object returned by the API:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n    &quot;expand&quot;: &quot;names,schema&quot;,\n    &quot;startAt&quot;: 0,\n    &quot;maxResults&quot;: 1,\n    &quot;total&quot;: 888,\n    &quot;issues&quot;: [\n        {\n            &quot;expand&quot;: &quot;operations,versionedRepresentations,editmeta,changelog,renderedFields&quot;,\n            &quot;id&quot;: &quot;11718&quot;,\n            &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/11718&quot;,\n            &quot;key&quot;: &quot;HACK-756&quot;,\n            &quot;fields&quot;: {\n                &quot;issuetype&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issuetype/10014&quot;,\n                    &quot;id&quot;: &quot;10014&quot;,\n                    &quot;description&quot;: &quot;Placeholder item for \\&quot;holy shit this is going to be a lot of work\\&quot;&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&amp;avatarId=10311&amp;avatarType=issuetype&quot;,\n                    &quot;name&quot;: &quot;Major Functionality&quot;,\n                    &quot;subtask&quot;: false,\n                    &quot;avatarId&quot;: 10311\n                },\n                &quot;customfield_10070&quot;: null,\n                &quot;customfield_10071&quot;: null,\n                &quot;customfield_10073&quot;: null,\n                &quot;customfield_10074&quot;: null,\n                &quot;customfield_10075&quot;: null,\n                &quot;project&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/project/10015&quot;,\n                    &quot;id&quot;: &quot;10015&quot;,\n                    &quot;key&quot;: &quot;HACK&quot;,\n                    &quot;name&quot;: &quot;Hackers and Slackers&quot;,\n                    &quot;projectTypeKey&quot;: &quot;software&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?pid=10015&amp;avatarId=10535&quot;,\n                        &quot;24x24&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=small&amp;pid=10015&amp;avatarId=10535&quot;,\n                        &quot;16x16&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=xsmall&amp;pid=10015&amp;avatarId=10535&quot;,\n                        &quot;32x32&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=medium&amp;pid=10015&amp;avatarId=10535&quot;\n                    }\n                },\n                &quot;fixVersions&quot;: [],\n                &quot;resolution&quot;: null,\n                &quot;resolutiondate&quot;: null,\n                &quot;workratio&quot;: -1,\n                &quot;lastViewed&quot;: &quot;2019-03-24T02:01:31.355-0400&quot;,\n                &quot;watches&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/watchers&quot;,\n                    &quot;watchCount&quot;: 1,\n                    &quot;isWatching&quot;: true\n                },\n                &quot;created&quot;: &quot;2019-02-03T00:47:36.677-0500&quot;,\n                &quot;customfield_10062&quot;: null,\n                &quot;customfield_10063&quot;: null,\n                &quot;customfield_10064&quot;: null,\n                &quot;customfield_10065&quot;: null,\n                &quot;customfield_10066&quot;: null,\n                &quot;priority&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/priority/2&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/images/icons/priorities/high.svg&quot;,\n                    &quot;name&quot;: &quot;High&quot;,\n                    &quot;id&quot;: &quot;2&quot;\n                },\n                &quot;customfield_10067&quot;: null,\n                &quot;customfield_10068&quot;: null,\n                &quot;customfield_10069&quot;: [],\n                &quot;labels&quot;: [],\n                &quot;versions&quot;: [],\n                &quot;issuelinks&quot;: [],\n                &quot;assignee&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;updated&quot;: &quot;2019-03-24T02:01:30.724-0400&quot;,\n                &quot;status&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/status/10004&quot;,\n                    &quot;description&quot;: &quot;&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/&quot;,\n                    &quot;name&quot;: &quot;To Do&quot;,\n                    &quot;id&quot;: &quot;10004&quot;,\n                    &quot;statusCategory&quot;: {\n                        &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/statuscategory/2&quot;,\n                        &quot;id&quot;: 2,\n                        &quot;key&quot;: &quot;new&quot;,\n                        &quot;colorName&quot;: &quot;blue-gray&quot;,\n                        &quot;name&quot;: &quot;To Do&quot;\n                    }\n                },\n                &quot;components&quot;: [],\n                &quot;description&quot;: {\n                    &quot;version&quot;: 1,\n                    &quot;type&quot;: &quot;doc&quot;,\n                    &quot;content&quot;: [\n                        {\n                            &quot;type&quot;: &quot;paragraph&quot;,\n                            &quot;content&quot;: [\n                                {\n                                    &quot;type&quot;: &quot;text&quot;,\n                                    &quot;text&quot;: &quot;https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/&quot;,\n                                    &quot;marks&quot;: [\n                                        {\n                                            &quot;type&quot;: &quot;link&quot;,\n                                            &quot;attrs&quot;: {\n                                                &quot;href&quot;: &quot;https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/&quot;\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                },\n                &quot;customfield_10010&quot;: null,\n                &quot;customfield_10011&quot;: &quot;0|i0064j:i&quot;,\n                &quot;customfield_10012&quot;: null,\n                &quot;customfield_10013&quot;: null,\n                &quot;security&quot;: null,\n                &quot;customfield_10008&quot;: &quot;HACK-143&quot;,\n                &quot;customfield_10009&quot;: {\n                    &quot;hasEpicLinkFieldDependency&quot;: false,\n                    &quot;showField&quot;: false,\n                    &quot;nonEditableReason&quot;: {\n                        &quot;reason&quot;: &quot;PLUGIN_LICENSE_ERROR&quot;,\n                        &quot;message&quot;: &quot;Portfolio for Jira must be licensed for the Parent Link to be available.&quot;\n                    }\n                },\n                &quot;summary&quot;: &quot;Automate newsletter&quot;,\n                &quot;creator&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;subtasks&quot;: [],\n                &quot;reporter&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;customfield_10000&quot;: &quot;{}&quot;,\n                &quot;customfield_10001&quot;: null,\n                &quot;customfield_10004&quot;: null,\n                &quot;environment&quot;: null,\n                &quot;duedate&quot;: null,\n                &quot;votes&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/votes&quot;,\n                    &quot;votes&quot;: 0,\n                    &quot;hasVoted&quot;: false\n                }\n            }\n        }\n    ]\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Whoa, mama! That's a ton of BS for a single issue. You can see now why we'd want to transform this data before importing ten million fields into any database. Make note of these important fields:</p><ul><li><code>startAt</code>: An integer which tells us which issue number the paginated results start at.</li><li><code>maxResults</code>: Denotes the maximum number of results page - maxes out at 100 issues.</li><li><code>total</code>: The total number of issues across all pages.</li><li><code>issues</code>: A list of objects which contain the information for exactly one JIRA issue per object</li></ul><p>Great. So the purpose of <strong>fetch.py </strong>will essentially consist of creating a list of all <strong>888</strong> issues (in my case), and passing that off for transformation. Check it the source I came up with:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport math\nimport requests\n\n\nclass FetchJiraIssues:\n    &quot;&quot;&quot;Fetch all public-facing issues from JIRA instance.\n\n    1. Retrieve all values from env vars.\n    2. Construct request against JIRA REST API.\n    3. Fetch paginated issues via recursion.\n    4. Pass final JSON to be transformed into a DataFrame.\n     &quot;&quot;&quot;\n    results_per_page = 100\n    username = os.environ.get('JIRA_USERNAME')\n    password = os.environ.get('JIRA_PASSWORD')\n    endpoint = os.environ.get('JIRA_ENDPOINT')\n    jql = os.environ.get('JIRA_QUERY')\n    headers = {\n        &quot;Accept&quot;: &quot;application/json&quot;\n    }\n\n    @classmethod\n    def get_total_number_of_issues(cls):\n        &quot;&quot;&quot;Gets the total number of results.&quot;&quot;&quot;\n        params = {\n            &quot;jql&quot;: cls.jql,\n            &quot;maxResults&quot;: 0,\n            &quot;startAt&quot;: 0\n        }\n        req = requests.get(cls.endpoint,\n                           headers=cls.headers,\n                           params=params,\n                           auth=(cls.username, cls.password)\n                           )\n        response = req.json()\n        try:\n            total_results = response['total']\n            return total_results\n        except KeyError:\n            print('Could not find any issues!')\n\n    @classmethod\n    def fetch_all_results(cls):\n        &quot;&quot;&quot;Recursively retrieve all pages of JIRA issues.&quot;&quot;&quot;\n        total_results = cls.get_total_number_of_issues()\n        issue_arr = []\n\n        def fetch_single_page():\n            &quot;&quot;&quot;Fetch one page of results, and determine if another page exists.&quot;&quot;&quot;\n            params = {\n                &quot;jql&quot;: cls.jql,\n                &quot;maxResults&quot;: cls.results_per_page,\n                &quot;startAt&quot;: len(issue_arr)\n            }\n            req = requests.get(cls.endpoint,\n                               headers=cls.headers,\n                               params=params,\n                               auth=(cls.username, cls.password)\n                               )\n            response = req.json()\n            issues = response['issues']\n            issues_so_far = len(issue_arr) + cls.results_per_page\n            print(issues_so_far, ' out of', total_results)\n            issue_arr.extend(issues)\n            # Check if additional pages of results exist.\n        count = math.ceil(total_results/cls.results_per_page)\n        for x in range(0, count):\n            fetch_single_page()\n        return issue_arr\n</code></pre>\n<!--kg-card-end: markdown--><p>Yep, I'm using classes. This class has two methods:</p><ul><li><code>get_total_number_of_issues</code>: All this does is essentially pull the number of issues (888) from the REST API. We'll use this number in our next function to check if additional pages exist.</li><li><code>fetch_all_results</code>: This is where things start getting fun. <strong>fetch_all_results</strong> is a <em>@classmethod</em> which contains a function within itself. <strong>fetch_all_results</strong> gets the total number of JIRA issues and then calls upon child function <strong>fetch_single_page </strong>to pull JIRA issue JSON objects and dump them into a list called <code>issue_arr</code> until all issues are accounted for.</li></ul><p>Because we have <em>888 issues </em>and can retrieve <em>100 issues</em> at a time, our function  <code>fetch_single_page</code> should run <em>9 times</em>. And it does!</p><h2 id=\"transforming-our-data\">Transforming Our Data</h2><p>So now we have a list of 888 messy JIRA issues. The scope of <strong>data.py</strong> should be to pull out only the data we want, and make sure that data is clean:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport json\nfrom pandas.io.json import json_normalize\nfrom datetime import datetime\n\n\nclass TransformData:\n    &quot;&quot;&quot;Build JIRA issue DataFrame.\n\n    1. Loop through JIRA issues and create a dictionary of desired data.\n    2. Convert each issue dictionary into a JSON object.\n    3. Load all issues into a Pandas DataFrame.\n    &quot;&quot;&quot;\n\n    issue_count = 0\n\n    @classmethod\n    def construct_dataframe(cls, issue_list_chunk):\n        &quot;&quot;&quot;Make DataFrame out of data received from JIRA API.&quot;&quot;&quot;\n        issue_list = [cls.make_issue_body(issue) for issue in issue_list_chunk]\n        issue_json_list = [cls.dict_to_json_string(issue) for issue in issue_list]\n        jira_issues_df = json_normalize(issue_json_list)\n        return jira_issues_df\n\n    @staticmethod\n    def dict_to_json_string(issue_dict):\n        &quot;&quot;&quot;Convert dict to JSON to string.&quot;&quot;&quot;\n        issue_json_string = json.dumps(issue_dict)\n        issue_json = json.loads(issue_json_string)\n        return issue_json\n\n    @classmethod\n    def make_issue_body(cls, issue):\n        &quot;&quot;&quot;Create a JSON body for each ticket.&quot;&quot;&quot;\n        updated_date = datetime.strptime(issue['fields']['updated'], &quot;%Y-%m-%dT%H:%M:%S.%f%z&quot;)\n        body = {\n            'id': str(cls.issue_count),\n            'key': str(issue['key']),\n            'assignee_name': str(issue['fields']['assignee']['displayName']),\n            'assignee_url': str(issue['fields']['assignee']['avatarUrls']['48x48']),\n            'summary': str(issue['fields']['summary']),\n            'status': str(issue['fields']['status']['name']),\n            'priority_url': str(issue['fields']['priority']['iconUrl']),\n            'priority_rank': int(issue['fields']['priority']['id']),\n            'issuetype_name': str(issue['fields']['issuetype']['name']),\n            'issuetype_icon': str(issue['fields']['issuetype']['iconUrl']),\n            'epic_link': str(issue['fields']['customfield_10008']),\n            'project': str(issue['fields']['project']['name']),\n            'updated': int(datetime.timestamp(updated_date)),\n            'updatedAt': str(updated_date)\n        }\n        cls.issue_count += 1\n        return body\n</code></pre>\n<!--kg-card-end: markdown--><p>Again, let's see the methods at work:</p><ul><li><code>construct_dataframe</code>: The main function we invoke to build our DataFrame (mostly just calls other methods). Once all transformations are completed, creates a DataFrame called <strong>jira_df</strong> by using the Pandas <em>json_normalize()</em> method.</li><li><code>make_issue_body</code>: Creates a new dictionary per singular JIRA issue. Extracts <em>only</em> the fields we want to be imported into our database. Converts each field into either a string or an int as a lazy way of avoiding null values (for example, if <code>issue['fields']['priority']['name']</code> contained a null value, the script would error out. Wrapping this in <strong>str() </strong>is a dirty way of converting <em>null</em> to an empty string).</li><li><code>dict_to_json_string</code> Takes each issue dictionary and converts it to a JSON object, which is then turned into a string (this is done for Pandas).</li></ul><h2 id=\"loading-our-data\">Loading Our Data</h2><p>And now for the final step! Thanks to the joyful marriage of Pandas and SQLAlchemy, turning DataFrames into SQL tables is super simple. We never make things simple, though.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport logging\nfrom sqlalchemy import create_engine, text, MetaData\nfrom sqlalchemy.types import Integer, Text, TIMESTAMP, String\nimport pandas as pd\n\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n\n\nclass DatabaseImport:\n    &quot;&quot;&quot;Merge Epic metadata and upload JIRA issues.\n\n    1. Merge Epic metadata by fetching an existing table.\n    2. Explicitly set data types for all columns found in jira_issues_df.\n    2. Create a new table from the final jira_issues_df.\n    &quot;&quot;&quot;\n\n    URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    db_epic_table = os.environ.get('SQLALCHEMY_EPIC_TABLE')\n    db_jira_table = os.environ.get('SQLALCHEMY_JIRA_TABLE')\n    db_schema = os.environ.get('SQLALCHEMY_DB_SCHEMA')\n\n    # Create Engine\n    meta = MetaData(schema=&quot;hackers$prod&quot;)\n    engine = create_engine(URI, echo=True)\n\n    @staticmethod\n    def truncate_table(engine):\n        &quot;&quot;&quot;Clear table of data.&quot;&quot;&quot;\n        sql = text('TRUNCATE TABLE &quot;hackers$prod&quot;.&quot;JiraIssue&quot;')\n        engine.execute(sql)\n\n    @classmethod\n    def merge_epic_metadata(cls, jira_issues_df):\n        &quot;&quot;&quot;Merge epic metadata from existing SQL table.&quot;&quot;&quot;\n        cls.truncate_table(cls.engine)\n        epics_df = pd.read_sql_table(cls.db_epic_table,\n                                     cls.engine,\n                                     schema=cls.db_schema)\n        jira_issues_df = pd.merge(jira_issues_df,\n                                  epics_df[['epic_link', 'epic_name', 'epic_color']],\n                                  how='left',\n                                  on='epic_link',\n                                  copy=False)\n        return jira_issues_df\n\n    @classmethod\n    def upload_dataframe(cls, jira_issues_df):\n        &quot;&quot;&quot;Upload JIRA DataFrame to PostgreSQL database.&quot;&quot;&quot;\n        jira_issues_df = cls.merge_epic_metadata(jira_issues_df)\n        jira_issues_df.to_sql(cls.db_jira_table,\n                              cls.engine,\n                              if_exists='append',\n                              schema=cls.db_schema,\n                              index=False,\n                              dtype={&quot;assignee&quot;: String(30),\n                                     &quot;assignee_url&quot;: Text,\n                                     &quot;epic_link&quot;: String(50),\n                                     &quot;issuetype_name&quot;: String(50),\n                                     &quot;issuetype_icon&quot;: Text,\n                                     &quot;key&quot;: String(10),\n                                     &quot;priority_name&quot;: String(30),\n                                     &quot;priority_rank&quot;: Integer,\n                                     &quot;priority_url&quot;: Text,\n                                     &quot;project&quot;: String(50),\n                                     &quot;status&quot;: String(30),\n                                     &quot;summary&quot;: Text,\n                                     &quot;updated&quot;: Integer,\n                                     &quot;updatedAt&quot;: TIMESTAMP,\n                                     &quot;createdAt&quot;: TIMESTAMP,\n                                     &quot;epic_color&quot;: String(20),\n                                     &quot;epic_name&quot;: String(50)\n                                     })\n        success_message = 'Successfully uploaded' \\\n                          + str(len(jira_issues_df.index)) \\\n                          + ' rows to ' + cls.db_jira_table\n        return success_message\n</code></pre>\n<!--kg-card-end: markdown--><ul><li><code>merge_epic_metadata</code>: Due to the nature of the JIRA REST API, some metadata is missing per issue. If you're interested, the data missing revolves around <strong>Epics</strong>: JIRA's REST API does not include the <em>Epic Name</em> or <em>Epic Color</em> fields of linked epics.</li><li><code>upload_dataframe</code>: Uses Panda's <strong>to_sql()</strong> method to upload our DataFrame into a SQL table (our target happens to be PostgreSQL, so we pass <em>schema</em> here). To make things explicit, we set the data type of every column on upload.</li></ul><p>Well, let's see how we made out!</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-27-at-9.03.51-PM.png\" class=\"kg-image\"><figcaption>A look at our resulting database table.</figcaption></figure><!--kg-card-end: image--><p>Whoaaa nelly, we did it! With our data clean, we can now build something useful! Here's what I built:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-27-at-9.29.20-PM.png\" class=\"kg-image\"><figcaption>Fruits of our labor!</figcaption></figure><!--kg-card-end: image--><p>There we have it: a pipeline that takes a bunch of messy data, cleans it, and puts it somewhere else for proper use.</p><p>If you're interested in how we created the frontend for our Kanban board, check out our series on <a href=\"https://hackersandslackers.com/series/graphql-hype/\">building features with GraphQL</a>. For the source code, check out the <a href=\"https://github.com/toddbirchard/jira-database-etl\">Github repository</a>.</p>","url":"https://hackersandslackers.com/building-an-etl-pipeline-from-jira-to-postgresql/","uuid":"23647abe-9b47-4f58-8206-cff1fb2ae891","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c95e08ef654036aa06c6a02"}},{"node":{"id":"Ghost__Post__5c82cfe75af763016e85082e","title":"Working With GraphQL Fragments and Mutations","slug":"creating-updating-and-deleting-data-via-graphql-mutations","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","custom_excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","created_at_pretty":"08 March, 2019","published_at_pretty":"19 March, 2019","updated_at_pretty":"20 March, 2019","created_at":"2019-03-08T15:26:15.000-05:00","published_at":"2019-03-19T16:34:38.000-04:00","updated_at":"2019-03-20T18:39:27.000-04:00","meta_title":"Working With GraphQL Fragments and Mutations | Hackers and Slackers","meta_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","og_title":"Working With GraphQL Fragments and Mutations","twitter_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-2.jpg","twitter_title":"Working With GraphQL Fragments and Mutations","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"Last week we encountered a genuine scenario when working with GraphQL clients.\nWhen building real applications consuming data via GraphQL, we usually don't\nknow precisely the query we're going to want to run at runtime. Imagine a user\ncruising through your application, setting preferences, and arriving at core\npieces of functionality under a content which is specific only to them. Say\nwe're building a GrubHub knockoff (we hate profits and love entering\nimpenetrable parts of the market, it's not that uncommon really.) At its core,\nthe information we're serving will always be restaurants; we'll always want to\nreturn things like the restaurant address, name, rating, etc. Because we want\nour app to be intelligent, this means that circumstances in which User 1  makes\na query are vastly different than User 2. Aside from the obvious facts (residing\nin different locales), perhaps there's more metadata we can leverage from User 1\n's longterm app usage, versus User 2  who is a total noob to our knockoff app.\n\nYet, the information we're serving will always be restaurants. There's a core\nquery being reused at the heart of our requests: we need to be dynamic enough to\naccount for the fact that User 1  has checked off 13 different cuisines and\nstrict delivery time windows, whereas User 2  doesn't give a shit. User 2  just\nwants pizza.\n\nThis is where GraphQL Fragments  come in to play. We've already seen how we can\npass variables through our queries to receive contextual data: the next step is\ncreating blocks of reusable code which may never change, which become the\nfoundational building blocks of all future queries.\n\nWhen to Use Fragments\nBack to our JIRA example, I demonstrated precisely the sort of thing one should\nnever do: making more than one GraphQL request to serve a single purpose.\n\nTo recap, we're pulling in JIRA issues to a Kanban board. Our board has 4\ncolumns: one per \"status.\" Here's a god-awful way of hardcoding a query like\nthat:\n\nquery JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }\n\nSeems like a lot of repetition, yeah? What if we could define chunks of queries\nto be reused to simplify things?\n\n# Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}\n\nProgress! Instead of reiterating the fields we want to query for each time, we\nset these once.  We do this by creating a fragment  named JiraFields  (naming\nconventions for fragments are totally up to you- these don't relate to\nanything). To make this easier to visualize, let's just look at the parts:\n\nfragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}\n\nTake note of [nameOfDatamodelToQuery(SINGULAR)]. Our fragment will refer to data\nmodel in the singular syntax  - this is important.\n\nOur New Query Using a Fragment\nAgain, let's simply what we're looking at:\n\nquery [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}\n\n * [subsetName]  is the name of the embedded JSON object to be returned in the\n   response. The naming is up to us.\n * [DatamodelToQuery(PLURAL)]  contrasts the singular data model we specified in\n   our fragment.\n * Finally, ...[GivenNameToYourFragment]  is the syntax for dumping a fragment\n   into a query. Yes, the ...  is intentional.\n\nHere's how we managed to get on:\n\nNow we're talkin'.Implementing On The Client Side\nWith the big picture in hand, this is still all theoretical until we have some\nreal code making real dynamic queries. So which GraphQL client tools should we\nuse?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.\n\nAs we all know, Apollo [https://github.com/apollographql/apollo-client]  is\ncrushing the game with their seemingly endless libraries doing... a lot of\nsimilar stuff? Then there's Prisma\n[https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/]\n, the new hotshot looking to make a buck. But what about this repo\n[https://github.com/smooth-code/fraql]? It seems totally fine, but why won't it\nfreakin work?! And what about this Lokka [https://github.com/kadirahq/lokka] \nthing? Also, apparently you can just use node-fetch\n[https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher] \n anyway?\n\nFor somebody looking for simplicity, this gets very frustrating. Most clients\nare immediately concerned with integrating with React as fast as possible\n(totally understandable), but a small-town country boy like me just wants to\nstart with simple. I'm just trying to write a god damn tutorial!\n\nAnyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything\nrelated to JavaScript could be cohesive or straightforward. Instead of wrestling\nwith that reality, now's as good a time as ever to move on to the part of\nGraphQL we've failed to speak of: modifying data.\n\nGraphQL Mutation Cheatsheet\nAny form of creating, changing, or deleting data in GraphQL falls under the\numbrella of mutations. The structure is similar to queries, except that we take\ndata in (presumably through variables) and spit out whichever fields you'd like\nto see as a result of that.\n\nCreating Records\nA functioning \"create\" mutation with the resulting response:\n\nSimple enough.And the mutation itself, just in case anybody is copy/pasting out\nthere:\n\nmutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}\n\nUpdating Records\nWe can update records (aka nodes) by specifying the target node using where: {},\nand the data to be updated within data: {}\n\nSyntax is just like creating nodes, but with an added where:{} statement.mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}\n\nDeleting Records\nYou can even specify which fields you want returned from the node you're in the\nact of ruthlessly murdering! \n\nAnd with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue\nwith GraphQL\" to please its master once last time.mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}\n\nEnough For Now\nHopefully, I'm not the only one to have bee deceived by the simplicity of\nGraphQL's syntax at first glance. The minimalism of GraphQL queries and\nmutations would lead one to believe that they're simple to understand right off\nthe bat. The problem with that logic is the syntax is so  simplistic, that\nthere's hardly any way of telling what nearly identical queries or mutations\nmight do from one character to the next. Even in JSON, the combination of \nexplicit quotations, key:value relationships, and  comma-separation  affords us\na lot of inferred knowledge we take for granted.\n\nI'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much\nas it can easily be frustrating to newcomers (and rightfully so). As long as\npeople keep reading, I'll keep posting, so let's chip away at this thing week by\nweek.","html":"<p>Last week we encountered a genuine scenario when working with GraphQL clients. When building real applications consuming data via GraphQL, we usually don't know precisely the query we're going to want to run at runtime. Imagine a user cruising through your application, setting preferences, and arriving at core pieces of functionality under a content which is specific only to them. Say we're building a GrubHub knockoff (we hate profits and love entering impenetrable parts of the market, it's not that uncommon really.) At its core, the information we're serving will always be restaurants; we'll always want to return things like the restaurant address, name, rating, etc. Because we want our app to be intelligent, this means that circumstances in which <strong>User 1</strong> makes a query are vastly different than <strong>User 2</strong>. Aside from the obvious facts (residing in different locales), perhaps there's more metadata we can leverage from <strong>User 1</strong>'s longterm app usage, versus <strong>User 2</strong> who is a total noob to our knockoff app.</p><p>Yet, <em>the information we're serving will always be restaurants</em>. There's a core query being reused at the heart of our requests: we need to be dynamic enough to account for the fact that <strong>User 1</strong> has checked off 13 different cuisines and strict delivery time windows, whereas <strong>User 2</strong> doesn't give a shit. <strong>User 2</strong> just wants pizza.</p><p>This is where GraphQL <em><strong>Fragments</strong></em> come in to play. We've already seen how we can pass variables through our queries to receive contextual data: the next step is creating blocks of reusable code which may never change, which become the foundational building blocks of all future queries.</p><h2 id=\"when-to-use-fragments\">When to Use Fragments</h2><p>Back to our JIRA example, I demonstrated precisely the sort of thing one should never do: making more than one GraphQL request to serve a single purpose.</p><p>To recap, we're pulling in JIRA issues to a Kanban board. Our board has 4 columns: one per \"status.\" Here's a god-awful way of hardcoding a query like that:</p><!--kg-card-begin: code--><pre><code>query JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }</code></pre><!--kg-card-end: code--><p>Seems like a lot of repetition, yeah? What if we could define chunks of queries to be reused to simplify things?</p><!--kg-card-begin: code--><pre><code># Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}</code></pre><!--kg-card-end: code--><p>Progress! Instead of reiterating the fields we want to query for each time, we set these <em>once.</em> We do this by creating a <code>fragment</code> named <strong>JiraFields</strong> (naming conventions for fragments are totally up to you- these don't relate to anything). To make this easier to visualize, let's just look at the parts:</p><!--kg-card-begin: code--><pre><code>fragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}</code></pre><!--kg-card-end: code--><p>Take note of <code>[nameOfDatamodelToQuery(SINGULAR)]</code>. Our fragment will refer to data model in the singular syntax  - this is important.</p><h3 id=\"our-new-query-using-a-fragment\">Our New Query Using a Fragment</h3><p>Again, let's simply what we're looking at:</p><!--kg-card-begin: code--><pre><code>query [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}</code></pre><!--kg-card-end: code--><ul><li><code>[subsetName]</code> is the name of the embedded JSON object to be returned in the response. The naming is up to us.</li><li><code>[DatamodelToQuery(PLURAL)]</code> contrasts the singular data model we specified in our fragment.</li><li>Finally, <code>...[GivenNameToYourFragment]</code> is the syntax for dumping a fragment into a query. Yes, the <code>...</code> is intentional.</li></ul><p>Here's how we managed to get on:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-18-at-8.15.19-AM.png\" class=\"kg-image\"><figcaption>Now we're talkin'.</figcaption></figure><!--kg-card-end: image--><h2 id=\"implementing-on-the-client-side\">Implementing On The Client Side</h2><p>With the big picture in hand, this is still all theoretical until we have some real code making real dynamic queries. So which GraphQL client tools should we use?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.</p><p>As we all know, <a href=\"https://github.com/apollographql/apollo-client\"><strong>Apollo</strong></a> is crushing the game with their seemingly endless libraries doing... a lot of similar stuff? Then there's <strong><a href=\"https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/\">Prisma</a></strong>, the new hotshot looking to make a buck. But what about <a href=\"https://github.com/smooth-code/fraql\"><strong>this repo</strong></a>? It seems totally fine, but why won't it freakin work?! And what about this <strong><a href=\"https://github.com/kadirahq/lokka\">Lokka</a></strong> thing? Also, <a href=\"https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher\">apparently you can just use <strong>node-fetch</strong></a> anyway?</p><p>For somebody looking for simplicity, this gets very frustrating. Most clients are immediately concerned with integrating with React as fast as possible (totally understandable), but a small-town country boy like me just wants to start with simple. I'm just trying to write a god damn tutorial!</p><p>Anyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything related to JavaScript could be cohesive or straightforward. Instead of wrestling with that reality, now's as good a time as ever to move on to the part of GraphQL we've failed to speak of: modifying data.</p><h2 id=\"graphql-mutation-cheatsheet\">GraphQL Mutation Cheatsheet</h2><p>Any form of creating, changing, or deleting data in GraphQL falls under the umbrella of mutations. The structure is similar to queries, except that we take data in (presumably through variables) and spit out whichever fields you'd like to see as a result of that.</p><h3 id=\"creating-records\">Creating Records</h3><p>A functioning \"create\" mutation with the resulting response:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.41-PM.png\" class=\"kg-image\"><figcaption>Simple enough.</figcaption></figure><!--kg-card-end: image--><p>And the mutation itself, just in case anybody is copy/pasting out there:</p><!--kg-card-begin: code--><pre><code>mutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"updating-records\">Updating Records</h3><p>We can update records (aka nodes) by specifying the target node using <code>where: {}</code>, and the data to be updated within <code>data: {}</code></p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-19-at-1.23.28-PM.png\" class=\"kg-image\"><figcaption>Syntax is just like creating nodes, but with an added where:{} statement.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"deleting-records\">Deleting Records</h3><p>You can even specify which fields you want returned from the node you're in the act of ruthlessly murdering! </p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.20-PM.png\" class=\"kg-image\"><figcaption>And with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue with GraphQL\" to please its master once last time.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"enough-for-now\">Enough For Now</h3><p>Hopefully, I'm not the only one to have bee deceived by the simplicity of GraphQL's syntax at first glance. The minimalism of GraphQL queries and mutations would lead one to believe that they're simple to understand right off the bat. The problem with that logic is the syntax is <em>so</em> simplistic, that there's hardly any way of telling what nearly identical queries or mutations might do from one character to the next. Even in JSON, the combination of <strong>explicit quotations</strong>, <strong>key:value relationships</strong>, and<strong> comma-separation</strong> affords us a lot of inferred knowledge we take for granted.</p><p>I'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much as it can easily be frustrating to newcomers (and rightfully so). As long as people keep reading, I'll keep posting, so let's chip away at this thing week by week.</p><p></p>","url":"https://hackersandslackers.com/creating-updating-and-deleting-data-via-graphql-mutations/","uuid":"a042692b-1812-49a1-a2fb-c0bd97973edf","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c82cfe75af763016e85082e"}},{"node":{"id":"Ghost__Post__5c838ee05af763016e85085b","title":"Building a Client For Your GraphQL API","slug":"interacting-with-your-graphql-api","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","excerpt":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","custom_excerpt":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","created_at_pretty":"09 March, 2019","published_at_pretty":"09 March, 2019","updated_at_pretty":"18 March, 2019","created_at":"2019-03-09T05:01:04.000-05:00","published_at":"2019-03-09T15:43:14.000-05:00","updated_at":"2019-03-18T03:10:39.000-04:00","meta_title":"Building a Client For Your GraphQL API | Hackers and Slackers","meta_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","og_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","og_title":"Building a Client For Your GraphQL API","twitter_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","twitter_title":"Building a Client For Your GraphQL API","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"If you had the pleasure of joining us last time, we had just completed a crash\ncourse in structuring GraphQL Queries\n[https://hackersandslackers.com/writing-your-first-graphql-queries/]. As much we\nall love studying abstract queries within the confines of a playground\nenvironment, the only real way to learn anything to overzealously attempt to\nbuild something way out of our skill level. Thus, we're going to shift gears and\nactually make something  with all the dry technical knowledge we've accumulated\nso far. Hooray!\n\nData Gone Wild: Exposing Your GraphQL Endpoint\nIf you're following along with Prisma as your GraphQL service, the endpoint for\nyour API defaults to [your_ip_address]:4466. What's more, you've probably\nnoticed it is publicly accessible. THIS IS VERY BAD.  Your server has full\nread/write access to whichever database you configured with it... if anybody\nfinds your endpoint hanging out in a Github commit somewhere, you've just lost\nyour database and everything in it. You're pretty much Equifax, and you should\nfeel bad.\n\nPrisma has a straightforward solution. While SSHed into\nwherever-you-set-up-your-server, check out the prisma.yaml  file which was\ngenerated as a result of when we first started getting set up. You know, this\ndirectory:\n\nmy-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n\n\nprisma.yaml  seems inglorious, but that's because it's hiding a secret; or\nshould I say, it's not  hiding a secret! Hah! You know, like, credentials. For\nconnecting to your API. Anyway. Add one more line to your prisma.yaml  file\nwhich defines a secret, like this:\n\nendpoint: http://localhost:4466\ndatamodel: datamodel.prisma\nsecret: HIIHGUTFTUY$VK$G$YI&TUYCUY$DT$\n\ngenerate:\n  - generator: typescript-client\n    output: ./generated/prisma-client/\n\n\nWith your secret stashed away safely, the Prisma CLI can now use this secret to\ncreate an authentication token: that  will be the value you need to actually\nconnect to your Prisma server remotely.\n\nType prisma token  in your project directory to get the work of art:\n\n$ prisma token\neyJhbGciOiJIUzI1NiIsInUYGFUJGSFKHFGSJFKSFJKSFGJdfSwiaWF0IjoxNTUyMTYwMDQ5LCJleHAiOjE1NTI3NjQ4NDl9.xrubUg_dRc93bqqR4f6jGt-KvQRS2Xq6lRi0a0uw-C0\n\n\nNice; believe it or not, that was the \"hard\" part.\n\nEXTRA CREDIT: Assign a DNS Record and Apply a Security Certificate\nIf really want to, you could already query against your insecure IP address and\nstart receiving some information. That said, making HTTP  requests as such from \nHTTPS  origins will fail. Not only that, but you kind of look shitty for not\neven bothering to name your API, much less apply a free SSL certificate. For the\neasiest possible way to do this, see our post on using Caddy as an HTTP server\n[https://hackersandslackers.com/serve-docker-containers-with-custom-dns-and-ssl/]\n.\n\nBuilding a Javascript Client to Consume Our API\nWith our API nice and secure, we can start hitting this baby from wherever we\nwant... as long as it's a Node app. We'll start by requiring two packages:\n\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\n\nGraphQLClient  is the magic behind our client- it's everything. It also happens\nto be very similar to existing npm  libraries for making requests, such as \nnode-fetch [https://hackersandslackers.com/making-api-requests-with-nodejs/].\n\nWe'll also leverage the dotenv  library to make sure our API endpoint  and \nBearer token  stay out of source code. Try not to be Equifax whenever possible. \ndotenv  allows us to load sensitive values from a .env  file. Just in case you\nneed a refresher, that file should look like this:\n\nNODE_ENV=Production\nENDPOINT=https://yourapiendpoint.com\nAUTH=Bearer eyJhbGciOBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHGUYFIERIBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHZl-UGnMrOk3w\n\nInitialize The GraphQL Client\nI like to set up a one-time client for our API that we can go back and reuse if\nneed be. After pulling the API endpoint and token from our .env  file, setting\nup the client is easy:\n\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n\nEMERGENCY MEETING: EVERYBODY HUDDLE UP\nOh I'm sorry, were you focusing on development? Unfortunately for you, I spent 8\nyears as a product manager, and I love  stopping everything suddenly to call\nemergency meetings.\n\nReal talk though, let's think back to the JIRA Kanban board example we've been\nusing for the last two posts. If you recall, we're going to write a query that\npopulates a 4-column Kanban board. The board represents a project (in this case,\n Hackers and Slackers) and each column represents a status  of ticket, like\nthis:\n\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n\nWe've previously established that GraphQL queries are friendly to drop-in\nvariables. Let's use this to build some logic into our client, as opposed to\nhardcoding a massive query, which is really just the same 4 queries stitched\ntogether. Here's what a query to populate a single JIRA column looks like:\n\n// Structured query\nconst query = `\n    query JiraIssuesByStatus($project: String, $status: String) {\n         jiraIssues(where: {project: $project, status: $status}, \n         orderBy: timestamp_DESC, \n         first: 6) {\n            key\n            summary\n            epic\n            status\n            project\n            priority\n            issuetype\n            timestamp\n            }\n         }\n       `\n\nWe're passing both the project  and the issue status  as variables to our query.\nWe can make things a bit dynamic here by looping through our statuses and\nexecuting this query four times: each time resulting in a callback filling the\nappropriate columns with JIRA issues.\n\nThis approach is certainly less clunky and more dynamic than a hardcoded query.\nThat said, this still  isn't the best solution. Remember: the strength of\nGraphQL is the ability to get obscene amounts of data across complex\nrelationships in a single call. The best approach here would probably be to\nbuild the query string itself dynamically using fragments,  which we'll review\nin the next post.Game On: Our Client in Action\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n// Structured query\nconst query = `\n   query JiraIssuesByStatus($project: String, $status: String) {\n      jiraIssues(where: {project: $project, status: $status}, orderBy: timestamp_DESC, first: 6) {\n         key\n         summary\n         epic\n         status\n         project\n         priority\n         issuetype\n         timestamp\n        }\n      }\n    `;\n\n// All Possible Issue Statuses\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n// Execute a query per issue status\nfor(var i = 0; i < statuses.length; i++){\n  var variables = {\n    project: \"Hackers and Slackers\",\n    status: statuses[i]\n  }\n\n  client.request(query, variables).then((data) => {\n    console.log(data)\n  }).catch(err => {\n    console.log(err.response.errors) // GraphQL response errors\n    console.log(err.response.data) // Response data if available\n  });\n}\n\n\nWorks like a charm. We only had one endpoint, only had to set one header, and\ndidn't spend any time reading through hundreds of pages of documentation to\nfigure out which combination of REST API endpoint, parameters, and methods\nactually get us what we want. It's almost as if we're writing SQL now, except...\nit looks a lot more like... NoSQL. Thanks for the inspiration, MongoDB! Hope\nthat whole selling-open-source-software  thing works out.\n\nOh, and of course, here were the results of my query:\n\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550194791,\n       project: 'Hackers and Slackers',\n       key: 'HACK-778',\n       epic: 'Code snippets',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'HLJS: set indentation level' },\n     { priority: 'Medium',\n       timestamp: 1550194782,\n\n       project: 'Hackers and Slackers',\n       key: 'HACK-555',\n       epic: 'Optimization',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Minify Babel' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-785',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Unix commands for data' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-251',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Using Ghost\\'s content filtering' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-302',\n       epic: 'Widgets',\n       status: 'Backlog',\n       issuetype: 'Integration',\n       summary: 'Discord channel signups ' },\n     { priority: 'Low',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-336',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Linux: Configuring your server to send SMTP emails' } ] }\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550224412,\n       project: 'Hackers and Slackers',\n       key: 'HACK-769',\n       epic: 'Projects Page',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'Fix projects dropdown' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-710',\n       epic: 'Lynx',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Implement auto text synopsis for Lynx posts' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-777',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Redesign footer to be informative; link-heavy' },\n     { priority: 'Highest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-779',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Changeover from cloudinary to DO' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-780',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Make mobile post title bold' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-781',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'This post consistently doesn’t work on mobile' } ] }\n{ jiraIssues:\n   [ { priority: 'Low',\n       timestamp: 1550223282,\n       project: 'Hackers and Slackers',\n       key: 'HACK-782',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary:\n        'Lynx: on mobile, instead of full link, show domainname.com/...' },\n     { priority: 'High',\n       timestamp: 1550194799,\n       project: 'Hackers and Slackers',\n       key: 'HACK-774',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'New Widget: Next/Previous article in series' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-395',\n       epic: 'Page Templates',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Create fallback image for posts with no image' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-756',\n       epic: 'Newsletter',\n       status: 'To Do',\n       issuetype: 'Major Functionality',\n       summary: 'Automate newsletter' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-775',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Data & Analytics',\n       summary: 'Update issuetype icons' },\n     { priority: 'Lowest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-776',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Add fork icon to repos' } ] }\n{ jiraIssues:\n   [ { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-784',\n       epic: 'New Post',\n       status: 'In Progress',\n       issuetype: 'Content',\n       summary: 'Welcome to SQL part1' } ] }\n\n\nBefore we say \"GG, 2ez, 1v1 me,\" know that we're  only getting started \nuncovering what GraphQL can do. It's not all just creating and deleting records\neither; we're talking full-on database JOIN equivalent type shit here. Stick\naround folks, the bandwagon's just getting warmed up.","html":"<p>If you had the pleasure of joining us last time, we had just completed a <a href=\"https://hackersandslackers.com/writing-your-first-graphql-queries/\">crash course in structuring GraphQL Queries</a>. As much we all love studying abstract queries within the confines of a playground environment, the only real way to learn anything to overzealously attempt to build something way out of our skill level. Thus, we're going to shift gears and actually <em>make something</em> with all the dry technical knowledge we've accumulated so far. Hooray!</p><h2 id=\"data-gone-wild-exposing-your-graphql-endpoint\">Data Gone Wild: Exposing Your GraphQL Endpoint</h2><p>If you're following along with Prisma as your GraphQL service, the endpoint for your API defaults to <code>[your_ip_address]:4466</code>. What's more, you've probably noticed it is publicly accessible. <strong>THIS IS VERY BAD.</strong> Your server has full read/write access to whichever database you configured with it... if anybody finds your endpoint hanging out in a Github commit somewhere, you've just lost your database and everything in it. You're pretty much Equifax, and you should feel bad.</p><p>Prisma has a straightforward solution. While SSHed into wherever-you-set-up-your-server, check out the <code>prisma.yaml</code> file which was generated as a result of when we first started getting set up. You know, this directory:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">my-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n</code></pre>\n<!--kg-card-end: markdown--><p><code>prisma.yaml</code> seems inglorious, but that's because it's hiding a secret; or should I say, it's <em>not</em> hiding a secret! Hah! You know, like, credentials. For connecting to your API. Anyway. Add one more line to your <code>prisma.yaml</code> file which defines a <code>secret</code>, like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">endpoint: http://localhost:4466\ndatamodel: datamodel.prisma\nsecret: HIIHGUTFTUY$VK$G$YI&amp;TUYCUY$DT$\n\ngenerate:\n  - generator: typescript-client\n    output: ./generated/prisma-client/\n</code></pre>\n<!--kg-card-end: markdown--><p>With your secret stashed away safely, the <strong>Prisma CLI </strong>can now use this secret to create an authentication token: <em>that</em> will be the value you need to actually connect to your Prisma server remotely.</p><p>Type <code>prisma token</code> in your project directory to get the work of art:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ prisma token\neyJhbGciOiJIUzI1NiIsInUYGFUJGSFKHFGSJFKSFJKSFGJdfSwiaWF0IjoxNTUyMTYwMDQ5LCJleHAiOjE1NTI3NjQ4NDl9.xrubUg_dRc93bqqR4f6jGt-KvQRS2Xq6lRi0a0uw-C0\n</code></pre>\n<!--kg-card-end: markdown--><p>Nice; believe it or not, that was the \"hard\" part.</p><h3 id=\"extra-credit-assign-a-dns-record-and-apply-a-security-certificate\">EXTRA CREDIT: Assign a DNS Record and Apply a Security Certificate</h3><p>If really want to, you could already query against your insecure IP address and start receiving some information. That said, making <strong>HTTP</strong> requests as such from <strong>HTTPS</strong> origins will fail. Not only that, but you kind of look shitty for not even bothering to name your API, much less apply a free SSL certificate. For the easiest possible way to do this, see our post on <a href=\"https://hackersandslackers.com/serve-docker-containers-with-custom-dns-and-ssl/\">using Caddy as an HTTP server</a>.</p><h2 id=\"building-a-javascript-client-to-consume-our-api\">Building a Javascript Client to Consume Our API</h2><p>With our API nice and secure, we can start hitting this baby from wherever we want... as long as it's a Node app. We'll start by requiring two packages:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n</code></pre>\n<!--kg-card-end: markdown--><p><code>GraphQLClient</code> is the magic behind our client- it's everything. It also happens to be very similar to existing <strong>npm</strong> libraries for making requests, such as <a href=\"https://hackersandslackers.com/making-api-requests-with-nodejs/\">node-fetch</a>.</p><p>We'll also leverage the <code>dotenv</code> library to make sure our <strong>API endpoint</strong> and <strong>Bearer token</strong> stay out of source code. Try not to be Equifax whenever possible. <code>dotenv</code> allows us to load sensitive values from a <code>.env</code> file. Just in case you need a refresher, that file should look like this:</p><!--kg-card-begin: code--><pre><code>NODE_ENV=Production\nENDPOINT=https://yourapiendpoint.com\nAUTH=Bearer eyJhbGciOBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHGUYFIERIBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHZl-UGnMrOk3w</code></pre><!--kg-card-end: code--><h3 id=\"initialize-the-graphql-client\">Initialize The GraphQL Client</h3><p>I like to set up a one-time client for our API that we can go back and reuse if need be. After pulling the API endpoint and token from our <code>.env</code> file, setting up the client is easy:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"emergency-meeting-everybody-huddle-up\">EMERGENCY MEETING: EVERYBODY HUDDLE UP</h2><p>Oh I'm sorry, were you focusing on development? Unfortunately for you, I spent 8 years as a product manager, and I <em>love</em> stopping everything suddenly to call emergency meetings.</p><p>Real talk though, let's think back to the JIRA Kanban board example we've been using for the last two posts. If you recall, we're going to write a query that populates a 4-column Kanban board. The board represents a <em>project </em>(in this case, <strong>Hackers and Slackers</strong>) and each column represents a <em>status</em> of ticket, like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n</code></pre>\n<!--kg-card-end: markdown--><p>We've previously established that GraphQL queries are friendly to drop-in variables. Let's use this to build some logic into our client, as opposed to hardcoding a massive query, which is really just the same 4 queries stitched together. Here's what a query to populate a single JIRA column looks like:</p><!--kg-card-begin: code--><pre><code>// Structured query\nconst query = `\n    query JiraIssuesByStatus($project: String, $status: String) {\n         jiraIssues(where: {project: $project, status: $status}, \n         orderBy: timestamp_DESC, \n         first: 6) {\n            key\n            summary\n            epic\n            status\n            project\n            priority\n            issuetype\n            timestamp\n            }\n         }\n       `</code></pre><!--kg-card-end: code--><p>We're passing both the <em>project</em> and the <em>issue status</em> as variables to our query. We can make things a bit dynamic here by looping through our statuses and executing this query four times: each time resulting in a callback filling the appropriate columns with JIRA issues.</p><!--kg-card-begin: html--><div class=\"protip\">\nThis approach is certainly less clunky and more dynamic than a hardcoded query. That said, this <i>still</i> isn't the best solution. Remember: the strength of GraphQL is the ability to get obscene amounts of data across complex relationships in a single call. The best approach here would probably be to build the query string itself dynamically using <strong>fragments,</strong> which we'll review in the next post.\n</div><!--kg-card-end: html--><h2 id=\"game-on-our-client-in-action\">Game On: Our Client in Action</h2><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n// Structured query\nconst query = `\n   query JiraIssuesByStatus($project: String, $status: String) {\n      jiraIssues(where: {project: $project, status: $status}, orderBy: timestamp_DESC, first: 6) {\n         key\n         summary\n         epic\n         status\n         project\n         priority\n         issuetype\n         timestamp\n        }\n      }\n    `;\n\n// All Possible Issue Statuses\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n// Execute a query per issue status\nfor(var i = 0; i &lt; statuses.length; i++){\n  var variables = {\n    project: &quot;Hackers and Slackers&quot;,\n    status: statuses[i]\n  }\n\n  client.request(query, variables).then((data) =&gt; {\n    console.log(data)\n  }).catch(err =&gt; {\n    console.log(err.response.errors) // GraphQL response errors\n    console.log(err.response.data) // Response data if available\n  });\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Works like a charm. We only had one endpoint, only had to set one header, and didn't spend any time reading through hundreds of pages of documentation to figure out which combination of REST API endpoint, parameters, and methods actually get us what we want. It's almost as if we're writing SQL now, except... it looks a lot more like... NoSQL. Thanks for the inspiration, <strong>MongoDB</strong>! Hope that whole <em>selling-open-source-software</em> thing works out.</p><p>Oh, and of course, here were the results of my query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550194791,\n       project: 'Hackers and Slackers',\n       key: 'HACK-778',\n       epic: 'Code snippets',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'HLJS: set indentation level' },\n     { priority: 'Medium',\n       timestamp: 1550194782,\n\n       project: 'Hackers and Slackers',\n       key: 'HACK-555',\n       epic: 'Optimization',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Minify Babel' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-785',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Unix commands for data' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-251',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Using Ghost\\'s content filtering' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-302',\n       epic: 'Widgets',\n       status: 'Backlog',\n       issuetype: 'Integration',\n       summary: 'Discord channel signups ' },\n     { priority: 'Low',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-336',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Linux: Configuring your server to send SMTP emails' } ] }\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550224412,\n       project: 'Hackers and Slackers',\n       key: 'HACK-769',\n       epic: 'Projects Page',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'Fix projects dropdown' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-710',\n       epic: 'Lynx',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Implement auto text synopsis for Lynx posts' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-777',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Redesign footer to be informative; link-heavy' },\n     { priority: 'Highest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-779',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Changeover from cloudinary to DO' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-780',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Make mobile post title bold' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-781',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'This post consistently doesn’t work on mobile' } ] }\n{ jiraIssues:\n   [ { priority: 'Low',\n       timestamp: 1550223282,\n       project: 'Hackers and Slackers',\n       key: 'HACK-782',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary:\n        'Lynx: on mobile, instead of full link, show domainname.com/...' },\n     { priority: 'High',\n       timestamp: 1550194799,\n       project: 'Hackers and Slackers',\n       key: 'HACK-774',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'New Widget: Next/Previous article in series' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-395',\n       epic: 'Page Templates',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Create fallback image for posts with no image' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-756',\n       epic: 'Newsletter',\n       status: 'To Do',\n       issuetype: 'Major Functionality',\n       summary: 'Automate newsletter' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-775',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Data &amp; Analytics',\n       summary: 'Update issuetype icons' },\n     { priority: 'Lowest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-776',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Add fork icon to repos' } ] }\n{ jiraIssues:\n   [ { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-784',\n       epic: 'New Post',\n       status: 'In Progress',\n       issuetype: 'Content',\n       summary: 'Welcome to SQL part1' } ] }\n</code></pre>\n<!--kg-card-end: markdown--><p>Before we say \"GG, 2ez, 1v1 me,\" know that we're<em> only getting started</em> uncovering what GraphQL can do. It's not all just creating and deleting records either; we're talking full-on database JOIN equivalent type shit here. Stick around folks, the bandwagon's just getting warmed up.</p>","url":"https://hackersandslackers.com/interacting-with-your-graphql-api/","uuid":"34fef193-6a56-4754-a329-3d34571fcd15","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c838ee05af763016e85085b"}},{"node":{"id":"Ghost__Post__5c806baf199621174e904b03","title":"Writing Your First GraphQL Query","slug":"writing-your-first-graphql-queries","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-3.jpg","excerpt":"Begin to structure complex queries against your GraphQL API.","custom_excerpt":"Begin to structure complex queries against your GraphQL API.","created_at_pretty":"07 March, 2019","published_at_pretty":"07 March, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-03-06T19:54:07.000-05:00","published_at":"2019-03-07T10:37:00.000-05:00","updated_at":"2019-03-28T11:01:59.000-04:00","meta_title":"Writing Your First GraphQL Queries | Hackers and Slackers","meta_description":"Structure your first GraphQL Queries and begin to build a client.","og_description":"Structure your first GraphQL Queries and begin to build a client.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-3.jpg","og_title":"Writing Your First GraphQL Queries","twitter_description":"Structure your first GraphQL Queries and begin to build a client.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-2.jpg","twitter_title":"Writing Your First GraphQL Queries","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"In our last run-in with GraphQL, we used Prisma  to assist in setting up a\nGraphQL server\n[https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/]. This\neffectively gave us an endpoint to work with for making GraphQL requests against\nthe database we specified when getting started. If you're still in the business\nof setting up a GraphQL server, there are plenty of alternative services to\nPrisma you could explore. Apollo [https://www.apollographql.com/]  is perhaps\nthe most popular. A different approach could be to use GraphCMS\n[https://graphcms.com/]: a headless CMS for building GraphQL models with a\nbeautiful interface.\n\nWith our first models are created and deployed, we’re now able to explore\nGraphQL hands-on. Prisma (and just about any other service) gives us the luxury\nof a “playground” interface, where we can write all sorts of nonsensical and\notherwise dangerous shit. This is our opportunity to get comfortable before\nunleashing our ignorance upon the world in a production environment. To guide\nus, I’ll be using my own example of creating models, importing dummy data, and\nhow to write the queries to fetch said data.\n\nOur Example Model\nIn my case, I created a model for one of my favorite things: JIRA issues. I'll\nbe creating a Kanban widget using the data we play with here down the line, so\nthis is a real live use-case we'll be working with.\n\nHere are the contents of my datamodel.prisma  file:\n\ntype jiraissue {\n  id: ID! @unique,\n  key: String! @unique,\n  assignee: String,\n  summary: String,\n  status: String!,\n  priority: String,\n  issuetype: String,\n  epic_name: String,\n  updated: DateTime,\n  rank: Int,\n  timestamp: Int,\n  project: String\n}\n\nYou'll notice we have a good number of datatypes here, as well as two unique\nkeys. In case this point has been missed before, the exclamation marks in our\nmodel denote a required field.\n\nDeploying this model results in the following PostgreSQL query:\n\nCREATE TABLE \"default$default\".\"jiraissues\" (\n    \"id\" varchar(25) NOT NULL,\n    \"key\" text NOT NULL,\n    \"assignee\" text,\n    \"summary\" text,\n    \"status\" text NOT NULL,\n    \"priority\" text,\n    \"issuetype\" text,\n    \"epic_name\" text,\n    \"updated\" timestamp(3),\n    \"rank\" int4,\n    \"timestamp\" int4,\n    \"project\" text,\n    \"updatedAt\" timestamp(3) NOT NULL,\n    \"createdAt\" timestamp(3) NOT NULL,\n    PRIMARY KEY (\"id\")\n);\n\n\nLooks like everything lines up! The only caveat are the updatedAt  and createdAt \n fields: Prisma adds these to every database table for us.\n\nHere's a sample of the data I added by connecting to my database and importing a\nCSV:\n\nid\n key\n assignee\n summary\n status\n priority\n issuetype\n epic_name\n updated\n rank\n timestamp\n project\n updatedAt\n createdAt\n 430\n HACK-769\n Todd Birchard\n Fix projects dropdown\n Done\n Medium\n Bug\n Projects Page\n 2019-02-15 00:00:00\n 3\n 1550224412\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 465\n HACK-782\n Todd Birchard\n Lynx: on mobile, instead of full link, show domainname.com/...\n To Do\n Low\n Task\n Widgets\n 2019-02-15 00:00:00\n 4\n 1550223282\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 472\n HACK-774\n Todd Birchard\n New Widget: Next/Previous article in series\n To Do\n High\n Task\n Widgets\n 2019-02-14 00:00:00\n 2\n 1550194799\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 464\n HACK-778\n Todd Birchard\n HLJS: set indentation level\n Backlog\n Medium\n Task\n Code snippets\n 2019-02-14 00:00:00\n 3\n 1550194791\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 481\n HACK-555\n Todd Birchard\n Minify Babel\n Backlog\n Medium\n Task\n Optimization\n 2019-02-14 00:00:00\n 3\n 1550194782\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 432\n HACK-777\n Todd Birchard\n Redesign footer to be informative; link-heavy\n Done\n Medium\n Task\n Creative\n 2019-02-14 00:00:00\n 2\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 433\n HACK-779\n Todd Birchard\n Changeover from cloudinary to DO\n Done\n Highest\n Task\n Urgent\n 2019-02-14 00:00:00\n 0\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 428\n HACK-775\n Todd Birchard\n Update issuetype icons\n To Do\n Low\n Data & Analytics\n Projects Page\n 2019-02-14 00:00:00\n 3\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 374\n HACK-710\n Todd Birchard\n Implement auto text synopsis for Lynx posts\n Done\n High\n Task\n Lynx\n 2019-02-14 00:00:00\n 1\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 185\n HACK-395\n Todd Birchard\n Create fallback image for posts with no image\n To Do\n Low\n Task\n Page Templates\n 2019-02-14 00:00:00\n 3\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n A Few Things About GraphQL Queries\nBefore going any further, let's touch on a few concepts that are easy to stumble\nover.\n\nFirstly, a  GraphQL API only has a single endpoint. It makes sense: the logic of\nGraphQL API hits sit with the person creating the queries. That said, we've all\nbeen building REST APIs long enough to have this slip past us; I caught myself\nthinking through how to separate which endpoints I wanted before remembering\nthat's entirely not how this works.\n\nIt's import to understand that GraphQL is designed to be explicit. A significant\nadvantage of GraphQL is that we can be sure only to return the information which\nis essential to us.  For applications looking to optimize system resources (such\nas mobile apps), avoiding massive payloads is a feature, not a bug. This\nexplains many of the design decisions which went into designing GraphQL, as\nyou'll see it's intentionally difficult (but possible) to create a \"get all\nrecords\" query.\n\nLastly, GraphQL allows us to create queries in both shorthand and long-form  \nformats.  We'll take a look at both, starting with shorthand.\n\nGraphQL Shorthand Queries\nShorthand queries are an excellent place to start for beginners like us just\ntrying to get some data out of our database.\n\nThe structure of such a query looks like this:\n\n{\n  [model_name]s {\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n\nUsing our example, our model_name  in this case would be jiraissue made plural, \nresulting in jiraissues. This is an important thing to note: when creating\nmodels, we should name them as a single entity, as things get confusing very\nfast otherwise. I initially made the mistake of naming my model jiraissues,\nwhich would then drive me to query jiraissueses. That was a fun little trip.\n\nWithin the brackets of our model, we must explicitly specify which fields (aka\ndatabase columns) we'd like returned with our query. Here's a full example of a\nshorthand query:\n\n{\n  jiraissues {\n    key\n    summary\n    epic_name\n  }\n}\n\n\nCheck out what this results in when entered in our \"playground\":\n\nQuery on the left, results on the right.Just like that, we have liftoff!\n\nThe \"Where\" Clause\nAs mentioned earlier, a major point of GraphQL is to return only the data which\nis necessary. Thus, we should almost always make queries with a where clause.\nThus, we can extend our simple query as such:\n\n{\n  jiraissueses(where: {status: \"Backlog\"}) {\n    key\n    summary\n    epic_name\n    status\n  }\n}\n\n\nAnd here's the result:\n\nFiltering results \"where\" certain criteria are met.Adding to Our Query\nJust like SQL or MongoDB queries, we can add more to our query to get more\nspecific:\n\n{\n  jiraissues(where: {status: \"Backlog\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC,  first: 6) \n  {\n    key\n    summary\n    epic_name\n    status\n    updated\n  }\n}\n\n\nHere, we've expanded our filter to work on two  fields: now our query will only\nreturn issues which match our criteria for both status  and project. \n\nWe've also added a few other things to our query. With orderBy, we can set the\norder in which records will be returned to us by field, either in ascending\n(ASC) or descending (DESC) order. first  imposes a limit on our results, giving\nus the first 6 which meet our criteria. Alternatively, last  would give us the\nopposite.\n\nThere are plenty of more parameters we could add here. For example:\n\n * [fieldname]_contains: Filters results where the string field contains a\n   substring.\n * [fieldname]_in: Checks a list to return records where the value of the field\n   matches any substring in a provided list.\n * [fieldname]_starts_with: An expression to check for values that start with a\n   provided substring.\n * [fieldname]_ends_with: Similar to the above, only for ending with a\n   substring.\n\nNot only are there more to add to this list, but each as an accompanying reverse\nstatement which would return the opposite. For example, [fieldname]_not_contains \n is the opposite of [fieldname]_contains.\n\nGraphQL Longform Queries\nWhat we've seen so far is already pretty powerful, but we're far from seeing\njust how far GraphQL can go. \n\nTo demonstrate what a more complicated query is capable of, let's use out Kanban\nboard example. Our board is going to have 4 columns representing 4 statuses: \nBacklog, To Do, In Progress, and Done.  Check out how we can receive all of this\nwith a single query:\n\nquery KanbanJiraIssues {\n  backlog: jiraissues(where: {status: \"Backlog\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  todo: jiraissues(where: {status: \"To Do\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  inprogress: jiraissues(where: {status: \"In Progress\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  done: jiraissues(where: {status: \"Done\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n}\n\n\nUnlike our shorthand queries, we begin this query with the syntax query\n[your_query_name]. You can name your query anything you'd like.\n\nWithin that query, we can perform multiple individual queries which we too give\ndisplay names. In whole, the structure looks like this:\\\n\nquery [your_query_name] {\n  [subquery_name]: [model_name]s(where: {[your_criteria]}){\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n\n\nCheck out the result:\n\nNow THAT's a query.This format has helped us accomplish something previously\nimpossible with REST APIs: we've used a single endpoint to give us exactly  the\ninformation we need while omitting the information we don't.\n\nPassing Variables Into Queries\nAs you can see, queries can get lengthy pretty quick. It would suck if we had to\nwrite the entirety of the query above every time we wanted to hit an API.\nLuckily, we don't don't have to: that's where GraphQL variables come in.\n\nVariables allow us to use the structure of a GraphQL query repeatedly, while\nproviding different values where we see fit. That means if we have a\nparticularly complicated query structure that we'd like to repurpose, we can\npass dynamic values into said query. This is where things start to get really\npowerful.\n\nLet's assume that finding JIRA issues by epic link  is a common task we'll have\nto deal with. This is how we'd pass a dynamic value for epic_link:\n\nquery JiraIssuesByEpicName($epic_name: String) {\n  jiraissues(where: {epic_name: $epic_name}) {\n    key\n    summary\n    epic_name\n    status\n    updated\n    project\n    priority\n    issuetype\n    timestamp\n  }\n}\n\n$epic_name  is the name of our variable, which we set in the object we pass to\nthe query. That object looks like this:\n\n{\n  \"epic_name\": \"SEO\"\n}\n\nSo what we're saying on line 1  is that we're passing a variable named \n$epic_name, and that variable will be a String. When $epic_name  appears again\non line 2, the variable is interpreted as its value, which is \"SEO\".\n\nLuckily, our playground has a place specifically for setting variables which get\npassed to our queries. Here's how it all looks:\n\nHeavy breathing intensifies.Unlimited Power?\nWhile GraphQL's syntax looks clean and simple at first glance, it's easy to see\nhow quickly simple queries evolve into complex behemoths. It's no coincidence\nthat all GraphQL services come with a playground. It's hard to imagine how\nanybody could internalize GraphQL syntax without trial and error, and we're only\ngetting started.\n\nSo far we've only queried existing data; we haven't even begun to touch on\nmutations yet. Catch us next time when we start modifying data and get ourselves\ninto a whole lot of trouble.","html":"<p>In our last run-in with GraphQL, we used <strong>Prisma</strong> to assist in <a href=\"https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/\">setting up a GraphQL server</a>. This effectively gave us an endpoint to work with for making GraphQL requests against the database we specified when getting started. If you're still in the business of setting up a GraphQL server, there are plenty of alternative services to Prisma you could explore. <a href=\"https://www.apollographql.com/\"><strong>Apollo</strong></a> is perhaps the most popular. A different approach could be to use <a href=\"https://graphcms.com/\"><strong>GraphCMS</strong></a>: a headless CMS for building GraphQL models with a beautiful interface.</p><p>With our first models are created and deployed, we’re now able to explore GraphQL hands-on. Prisma (and just about any other service) gives us the luxury of a “playground” interface, where we can write all sorts of nonsensical and otherwise dangerous shit. This is our opportunity to get comfortable before unleashing our ignorance upon the world in a production environment. To guide us, I’ll be using my own example of creating models, importing dummy data, and how to write the queries to fetch said data.</p><h2 id=\"our-example-model\">Our Example Model</h2><p>In my case, I created a model for one of my favorite things: JIRA issues. I'll be creating a Kanban widget using the data we play with here down the line, so this is a real live use-case we'll be working with.</p><p>Here are the contents of my <code>datamodel.prisma</code> file:</p><!--kg-card-begin: code--><pre><code>type jiraissue {\n  id: ID! @unique,\n  key: String! @unique,\n  assignee: String,\n  summary: String,\n  status: String!,\n  priority: String,\n  issuetype: String,\n  epic_name: String,\n  updated: DateTime,\n  rank: Int,\n  timestamp: Int,\n  project: String\n}</code></pre><!--kg-card-end: code--><p>You'll notice we have a good number of datatypes here, as well as two unique keys. In case this point has been missed before, the exclamation marks in our model denote a required field.</p><p>Deploying this model results in the following PostgreSQL query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">CREATE TABLE &quot;default$default&quot;.&quot;jiraissues&quot; (\n    &quot;id&quot; varchar(25) NOT NULL,\n    &quot;key&quot; text NOT NULL,\n    &quot;assignee&quot; text,\n    &quot;summary&quot; text,\n    &quot;status&quot; text NOT NULL,\n    &quot;priority&quot; text,\n    &quot;issuetype&quot; text,\n    &quot;epic_name&quot; text,\n    &quot;updated&quot; timestamp(3),\n    &quot;rank&quot; int4,\n    &quot;timestamp&quot; int4,\n    &quot;project&quot; text,\n    &quot;updatedAt&quot; timestamp(3) NOT NULL,\n    &quot;createdAt&quot; timestamp(3) NOT NULL,\n    PRIMARY KEY (&quot;id&quot;)\n);\n</code></pre>\n<!--kg-card-end: markdown--><p>Looks like everything lines up! The only caveat are the <code>updatedAt</code> and <code>createdAt</code> fields: Prisma adds these to every database table for us.</p><p>Here's a sample of the data I added by connecting to my database and importing a CSV:</p><!--kg-card-begin: html--><div class=\"tableContainer\">\n<table>\n    <thead>\n       <tr>\n             <th>id</th>\n             <th>key</th>\n             <th>assignee</th>\n             <th>summary</th>\n             <th>status</th>\n             <th>priority</th>\n             <th>issuetype</th>\n             <th>epic_name</th>\n             <th>updated</th>\n             <th>rank</th>\n             <th>timestamp</th>\n             <th>project</th>\n             <th>updatedAt</th>\n             <th>createdAt</th>\n         </tr>\n    </thead>\n    <tbody>\n       <tr>\n              <td>430</td>\n              <td>HACK-769</td>\n              <td>Todd Birchard</td>\n              <td>Fix projects dropdown</td>\n              <td>Done</td>\n              <td>Medium</td>\n              <td>Bug</td>\n              <td>Projects Page</td>\n              <td>2019-02-15 00:00:00</td>\n              <td>3</td>\n              <td>1550224412</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>465</td>\n              <td>HACK-782</td>\n              <td>Todd Birchard</td>\n              <td>Lynx: on mobile, instead of full link, show domainname.com/...</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Task</td>\n              <td>Widgets</td>\n              <td>2019-02-15 00:00:00</td>\n              <td>4</td>\n              <td>1550223282</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>472</td>\n              <td>HACK-774</td>\n              <td>Todd Birchard</td>\n              <td>New Widget: Next/Previous article in series</td>\n              <td>To Do</td>\n              <td>High</td>\n              <td>Task</td>\n              <td>Widgets</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>2</td>\n              <td>1550194799</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>464</td>\n              <td>HACK-778</td>\n              <td>Todd Birchard</td>\n              <td>HLJS: set indentation level</td>\n              <td>Backlog</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Code snippets</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550194791</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>481</td>\n              <td>HACK-555</td>\n              <td>Todd Birchard</td>\n              <td>Minify Babel</td>\n              <td>Backlog</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Optimization</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550194782</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>432</td>\n              <td>HACK-777</td>\n              <td>Todd Birchard</td>\n              <td>Redesign footer to be informative; link-heavy</td>\n              <td>Done</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Creative</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>2</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>433</td>\n              <td>HACK-779</td>\n              <td>Todd Birchard</td>\n              <td>Changeover from cloudinary to DO</td>\n              <td>Done</td>\n              <td>Highest</td>\n              <td>Task</td>\n              <td>Urgent</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>0</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>428</td>\n              <td>HACK-775</td>\n              <td>Todd Birchard</td>\n              <td>Update issuetype icons</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Data & Analytics</td>\n              <td>Projects Page</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>374</td>\n              <td>HACK-710</td>\n              <td>Todd Birchard</td>\n              <td>Implement auto text synopsis for Lynx posts</td>\n              <td>Done</td>\n              <td>High</td>\n              <td>Task</td>\n              <td>Lynx</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>1</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>185</td>\n              <td>HACK-395</td>\n              <td>Todd Birchard</td>\n              <td>Create fallback image for posts with no image</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Task</td>\n              <td>Page Templates</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n    </tbody>\n   </table>\n</div><!--kg-card-end: html--><h2 id=\"a-few-things-about-graphql-queries\">A Few Things About GraphQL Queries</h2><p>Before going any further, let's touch on a few concepts that are easy to stumble over.</p><p>Firstly, a<strong> GraphQL API only has a single endpoint</strong>. It makes sense: the logic of GraphQL API hits sit with the person creating the queries. That said, we've all been building REST APIs long enough to have this slip past us; I caught myself thinking through how to separate which endpoints I wanted before remembering that's entirely not how this works.</p><p>It's import to understand that <strong>GraphQL is designed to be explicit</strong>. A significant advantage of GraphQL is that we can be sure <em>only to return the information which is essential to us.</em> For applications looking to optimize system resources (such as mobile apps), avoiding massive payloads is a feature, not a bug. This explains many of the design decisions which went into designing GraphQL, as you'll see it's intentionally difficult (but possible) to create a \"get all records\" query.</p><p>Lastly, GraphQL allows us to <strong>create queries in both shorthand and long-form</strong> <strong>formats</strong>.<strong> </strong>We'll take a look at both, starting with shorthand.</p><h2 id=\"graphql-shorthand-queries\">GraphQL Shorthand Queries</h2><p>Shorthand queries are an excellent place to start for beginners like us just trying to get some data out of our database.</p><p>The structure of such a query looks like this:</p><!--kg-card-begin: code--><pre><code>{\n  [model_name]s {\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}</code></pre><!--kg-card-end: code--><p>Using our example, our <strong>model_name</strong> in this case would be <strong>jiraissue </strong><em>made plural,</em> resulting in <strong>jiraissues</strong>. This is an important thing to note: when creating models, we should name them as a single entity, as things get confusing very fast otherwise. I initially made the mistake of naming my model <strong>jiraissues</strong>, which would then drive me to query <strong>jiraissueses</strong>. That was a fun little trip.</p><p>Within the brackets of our model, we must explicitly specify which fields (aka database columns) we'd like returned with our query. Here's a full example of a shorthand query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissues {\n    key\n    summary\n    epic_name\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Check out what this results in when entered in our \"playground\":</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-8.50.53-PM.png\" class=\"kg-image\"><figcaption>Query on the left, results on the right.</figcaption></figure><!--kg-card-end: image--><p>Just like that, we have liftoff!</p><h3 id=\"the-where-clause\">The \"Where\" Clause</h3><p>As mentioned earlier, a major point of GraphQL is to return only the data which is necessary. Thus, we should almost always make queries with a <em>where </em>clause. Thus, we can extend our simple query as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissueses(where: {status: &quot;Backlog&quot;}) {\n    key\n    summary\n    epic_name\n    status\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>And here's the result:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-9.21.23-PM.png\" class=\"kg-image\"><figcaption>Filtering results \"where\" certain criteria are met.</figcaption></figure><!--kg-card-end: image--><h3 id=\"adding-to-our-query\">Adding to Our Query</h3><p>Just like SQL or MongoDB queries, we can add more to our query to get more specific:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissues(where: {status: &quot;Backlog&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC,  first: 6) \n  {\n    key\n    summary\n    epic_name\n    status\n    updated\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Here, we've expanded our filter to work on <em>two</em> fields: now our query will only return issues which match our criteria for both <code>status</code> and <code>project</code>. </p><p>We've also added a few other things to our query. With <code>orderBy</code>, we can set the order in which records will be returned to us by field, either in ascending (ASC) or descending (DESC) order. <code>first</code> imposes a limit on our results, giving us the first 6 which meet our criteria. Alternatively, <code>last</code> would give us the opposite.</p><p>There are plenty of more parameters we could add here. For example:</p><ul><li><code>[fieldname]_contains</code>: Filters results where the string field contains a substring.</li><li><code>[fieldname]_in</code>: Checks a list to return records where the value of the field matches any substring in a provided list.</li><li><code>[fieldname]_starts_with</code>: An expression to check for values that start with a provided substring.</li><li><code>[fieldname]_ends_with</code>: Similar to the above, only for ending with a substring.</li></ul><p>Not only are there more to add to this list, but each as an accompanying reverse statement which would return the opposite. For example, <code>[fieldname]_not_contains</code> is the opposite of <code>[fieldname]_contains</code>.</p><h2 id=\"graphql-longform-queries\">GraphQL Longform Queries</h2><p>What we've seen so far is already pretty powerful, but we're far from seeing just how far GraphQL can go. </p><p>To demonstrate what a more complicated query is capable of, let's use out Kanban board example. Our board is going to have 4 columns representing 4 statuses: <strong>Backlog, To Do, In Progress, </strong>and <strong>Done.</strong> Check out how we can receive all of this with a single query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">query KanbanJiraIssues {\n  backlog: jiraissues(where: {status: &quot;Backlog&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  todo: jiraissues(where: {status: &quot;To Do&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  inprogress: jiraissues(where: {status: &quot;In Progress&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  done: jiraissues(where: {status: &quot;Done&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Unlike our shorthand queries, we begin this query with the syntax <code>query [your_query_name]</code>. You can name your query anything you'd like.</p><p>Within that query, we can perform multiple individual queries which we too give display names. In whole, the structure looks like this:\\</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">query [your_query_name] {\n  [subquery_name]: [model_name]s(where: {[your_criteria]}){\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Check out the result:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-11.22.29-PM.png\" class=\"kg-image\"><figcaption>Now THAT's a query.</figcaption></figure><!--kg-card-end: image--><p>This format has helped us accomplish something previously impossible with REST APIs: we've used a single endpoint to give us <em>exactly</em> the information we need while omitting the information we don't.</p><h2 id=\"passing-variables-into-queries\">Passing Variables Into Queries</h2><p>As you can see, queries can get lengthy pretty quick. It would suck if we had to write the entirety of the query above every time we wanted to hit an API. Luckily, we don't don't have to: that's where GraphQL <em>variables </em>come in.</p><p>Variables allow us to use the structure of a GraphQL query repeatedly, while providing different values where we see fit. That means if we have a particularly complicated query structure that we'd like to repurpose, we can pass dynamic values into said query. This is where things start to get really powerful.</p><p>Let's assume that finding JIRA issues by <em>epic link</em> is a common task we'll have to deal with. This is how we'd pass a dynamic value for <strong>epic_link:</strong></p><!--kg-card-begin: code--><pre><code>query JiraIssuesByEpicName($epic_name: String) {\n  jiraissues(where: {epic_name: $epic_name}) {\n    key\n    summary\n    epic_name\n    status\n    updated\n    project\n    priority\n    issuetype\n    timestamp\n  }\n}</code></pre><!--kg-card-end: code--><p><code>$epic_name</code> is the name of our variable, which we set in the object we pass to the query. That object looks like this:</p><!--kg-card-begin: code--><pre><code>{\n  \"epic_name\": \"SEO\"\n}</code></pre><!--kg-card-end: code--><p>So what we're saying on <strong>line 1</strong> is that we're passing a variable named <code>$epic_name</code>, and that variable will be a <code>String</code>. When <code>$epic_name</code> appears again on <strong>line 2</strong>, the variable is interpreted as its value, which is \"SEO\".</p><p>Luckily, our playground has a place specifically for setting variables which get passed to our queries. Here's how it all looks:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/graphql-variables.png\" class=\"kg-image\"><figcaption>Heavy breathing intensifies.</figcaption></figure><!--kg-card-end: image--><h3 id=\"unlimited-power\">Unlimited Power?</h3><p>While GraphQL's syntax looks clean and simple at first glance, it's easy to see how quickly simple queries evolve into complex behemoths. It's no coincidence that all GraphQL services come with a playground. It's hard to imagine how anybody could internalize GraphQL syntax without trial and error, and we're only getting started.</p><p>So far we've only queried existing data; we haven't even begun to touch on mutations yet. Catch us next time when we start modifying data and get ourselves into a whole lot of trouble.</p>","url":"https://hackersandslackers.com/writing-your-first-graphql-queries/","uuid":"4019e61f-0f68-4921-99d4-5085864f9143","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c806baf199621174e904b03"}},{"node":{"id":"Ghost__Post__5c5bb0ec7999ff33f06876e1","title":"Welcome to SQL: Modifying Databases and Tables","slug":"welcome-to-sql-modifying-databases-and-tables","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/SQLpt1-3.jpg","excerpt":"Brush up on SQL fundamentals such as creating tables, schemas, and views.","custom_excerpt":"Brush up on SQL fundamentals such as creating tables, schemas, and views.","created_at_pretty":"07 February, 2019","published_at_pretty":"19 February, 2019","updated_at_pretty":"28 February, 2019","created_at":"2019-02-06T23:15:40.000-05:00","published_at":"2019-02-19T18:28:00.000-05:00","updated_at":"2019-02-27T23:16:44.000-05:00","meta_title":"Welcome to SQL: Modifying Databases and Tables | Hackers and Slackers","meta_description":"Brush up on SQL fundamentals such as creating tables, schemas, and views. Part of a multi-part series on learning SQL.","og_description":"Brush up on SQL fundamentals such as creating tables, schemas, and views. Part of a multi-part series on learning SQL.","og_image":"https://hackersandslackers.com/content/images/2019/02/SQLpt1-3.jpg","og_title":"Welcome to SQL: Modifying Databases and Tables","twitter_description":"Brush up on SQL fundamentals such as creating tables, schemas, and views. Part of a multi-part series on learning SQL.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/SQLpt1-3.jpg","twitter_title":"Welcome to SQL: Modifying Databases and Tables","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"Data Analysis","slug":"data-analysis","description":"Drawing meaningful conclusions from data. Includes interpretation, dashboard creation, and data manipulation.","feature_image":null,"meta_description":"Drawing meaningful conclusions from data. Includes interpretation, dashboard creation, and data manipulation.","meta_title":"Data Analysis | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"PostgreSQL","slug":"postgresql","description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","feature_image":null,"meta_description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","meta_title":"Working with PostgreSQL | Hackers and Slackers","visibility":"public"},{"name":"MySQL","slug":"mysql","description":"Database configuration, building queries, and cloud hosting options for MySQL.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/mysqlrevamp_o.jpg","meta_description":"Database configuration, building queries, and cloud hosting options for MySQL.","meta_title":"Working with MySQL | Hackers and Slackers","visibility":"public"},{"name":"#Welcome to SQL","slug":"welcome-to-sql","description":"If you feel like you’re late to the data party, we all are. The party has been going strong since the 70s: brush up on SQL syntax the old-fashioned way.","feature_image":"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/welcometosqlseries.jpg","meta_description":"If you feel like you’re late to the data party, we all are. The party has been going strong since the 70s: brush up on SQL syntax the old-fashioned way.","meta_title":"Welcome to SQL","visibility":"internal"}],"plaintext":"SQL: we all pretend to be experts at it, and mostly get away with it thanks to\nStackOverflow. Paired with our vast experience of learning how to code in the\n90s, our field work of PHPMyAdmin and LAMP stacks basically makes us experts. Go\nahead and chalk up a win for your resume.\n\nSQL has been around longer than our careers have, so why start a series on it \nnow?  Surely there’s sufficient enough documentation that we can Google the\nspecifics whenever the time comes for us to write a query? That, my friends, is\nprecisely the problem. Regardless of what tools we have at our disposable, some\nskills are better learned and practiced by heart. SQL is one of those skills.\n\nSure, SQLAlchemy or similar ORMs might protect us here-and-there from writing\nraw queries. Considering SQL is just one of many query languages we'll use\nregularly (in addition to NoSQL, GraphQL, JQL, etc.), is becoming a SQL expert\nreally that critical? In short, yes: relational databases are not only here to\nstay, but thinking  in queries as a second language solidifies one's\nunderstanding of the fine details of data. Marc Laforet\n[https://towardsdatascience.com/python-vs-sql-comparison-for-data-pipelines-8ca727b34032] \n recently published a Medium post which drives home just how important leaning\non SQL is:\n\n> What’s even more interesting is that when these transformation scripts were\napplied to the 6.5 GB dataset, python completely failed. Out of 3 attempts,\npython crashed 2 times and my computer completely froze the 3rd time… while SQL\ntook 226 seconds.\n\n\nKeeping logic out of our apps and pipelines and in SQL results in exponentially\nfaster execution, while also being more readable and universally understood than\nwhatever we’d write in our language of choice. The lower down we can push\napplication logic in our stack, the better. This is why I’d much prefer to see\nthe datasphere saturated with SQL tutorials as opposed to Pandas tutorials.\n\nRelational Database Terminology\nI hate it when informational material kicks off with covering obvious\nterminology definitions. Under normal circumstances, I find this to be cliche,\nunhelpful, and damaging to an author's credibility; but these aren't normal\ncircumstances. In SQL, vocabulary commonly has multiple meanings depending on\ncontext, or even which flavor database you're using. Given this fact, it's\nentirely possible (and common) for individuals to rack up experience with\nrelational databases while completely misinterpreting fundamental concepts.\nLet's make sure that doesn't happen:\n\n * Databases: Every Database instance is separated at the highest level into \n   databases. Yes, a database is a collection of databases - we're already off\n   to a great start.\n * Schemas: In PostgreSQL (and other databases), a schema  is a grouping of\n   tables and other objects, including views, relations, etc. A schema is a way\n   of organizing data. Schemas imply that all the data belonging to it is at\n   some form related, even if only by concept. Note that the term schema  is\n   sometimes used to describe other concepts depending on the context.\n * Tables: The meat and potatos of relational databases. Tables consist of rows\n   and columns which hold our sweet, sweet data. Columns are best thought of as\n   'attributes', whereas rows are entries which consist of values for said\n   attributes. All values in a column must share the same data type. * Keys: Keys are used to help us organize and optimize data, as well as\n      place certain constraints on data coming in (for example, email addresses\n      of user accounts must be unique). Keys can also help us keep count of our\n      entries, ensure automatically unique values, and provide a bridge to link\n      multiple tables of data. * Primary keys: Identification tags for each row of data. The primary key\n         is different for every record in the relational database; values must\n         be provided, and they must be unique between rows.\n       * Foreign keys: Enable data searches and manipulation between the primary\n         database table and other related databases.\n      \n      \n   \n   \n * Objects: A blanket term for anything (including relations) that exist in a\n   schema (somewhat PostgreSQL-specific). * Views (PostgreSQL): Views display data in a fashion similar to tables,\n      with the difference that views do not store  data. Views are a snapshot of\n      data pulled from other tables in the form of a query; a good way to think\n      about views is to consider them to be 'virtual tables.'\n    * Functions (PostgreSQL): Logic for interacting with data saved for the\n      purpose of being reused.\n   \n   \n\nIn MySQL, a schema  is synonymous with a database. These keywords can even be\nswapped to use SCHEMA and DATABASE interchangably in MySQL. Thus, using CREATE\nSCHEMA  acheives the same effect as instead of CREATE DATABASE.Navigating and\nCreating Databases\nWe've got to start somewhere, so it might as well be with database management.\nAdmittedly, this will be the most useless of the things we'll cover. The act of\nnavigating databases is best suited for a GUI.\n\nShow Databases\nIf you access your database via command line shell (for some reason), the first\nlogical thing to do is to list the available databases:\n\nSHOW DATABASES;\n \n+--------------------+\n| Database           |\n+--------------------+\n| classicmodels      |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n\n\nUSE Database\nNow that we've listed the possible databases we can connect to, we can explore\nwhat each of these contains. To do this, we have to specify which database we\nwant to connect to, AKA \"use.\" \n\ndb> USE database_name;\nDatabase changed\n\n\nCreate Database\nCreating databases is straightforward. Be sure to pay attention to the character\nset  when creating a database: this will determine which types of characters\nyour database will be able to accept. For example, if we try to insert special\nencoded characters into a simple UTF-8 database, those characters won’t turn out\nas we’d expect.\n\nCREATE DATABASE IF NOT EXISTS database_name\nCHARACTER SET utf-8\n[COLLATE collation_name]\n\n\nBonus: here's the shorthand for creating a database and then showing the result:\n\nSHOW CREATE DATABASE database_name;\n\n\nCreating and Modifying Tables\nCreating tables via SQL syntax can be critical when automating data imports.\nWhen creating a table, we also set the column names, types, and keys:\n\nCREATE TABLE [IF NOT EXISTS] table_name (\n   column_name_1 [COLUMN_DATA_TYPE] [KEY_TYPE] [KEY_ATTRIBUTES] DEFAULT [DEFAULT_VALUE],\n   column_name_2 [COLUMN_DATA_TYPE] [KEY_TYPE] [KEY_ATTRIBUTES] DEFAULT [DEFAULT_VALUE],\n   PRIMARY KEY (column_name_1)\n) ENGINE=[ENGINE_TYPE];\n\nWe can specify IF NOT EXISTS  when creating our table if we'd like to include\nvalidation in our query. When present, the table will only be created if a table\nof the specified name does not exist.\n\nWhen creating each of our columns, there are a number of things we can specify\nper-column:\n\n * Data Type (required):  The data which can be saved to cells of this column\n   (such as INTEGER, TEXT, etc).\n * Key Type:  Creates a key for the column.\n * Key Attributes:  Any key-related attributes, such as auto-incrementing.\n * Default:  If rows are created in the table without values passed to the\n   current column, the value specified as DEFAULT  \n * Primary Key:  Allows any of the previous specified columns to be set as the\n   table's primary key.\n\nMySQL tables can have a 'storage engine' specified via ENGINE=[engine_type],\nwhich determines the core logic of how the table will interpret data. Leaving\nthis blank defaults to InnoDB and is almost certainly fine to be left alone. In\ncase you're interested, you can find more about MySQL engines here\n[https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html].\n\nHere's an example of what an actual CREATE TABLE  query would look like:\n\nCREATE TABLE IF NOT EXISTS awards (\n   id INTEGER PRIMARY KEY AUTO_INCREMENT,\n   recipient TEXT NOT NULL,\n   award_name TEXT DEFAULT 'Grammy',\n   PRIMARY KEY (id)\n) ENGINE=INNODB;\n\nManaging Keys for Existing Tables\nIf we don't specify our keys at table creation time, we can always do so after\nthe fact. SQL tables can accept the following key types:\n\n * Primary Key:  One or more fields/columns that uniquely identify a record in\n   the table. It can not accept null, duplicate values.\n * Candidate Key:  Candidate keys are kind of like groups of non-committed\n   Primary Keys; these keys only accept unique values, and could potentially  be\n   used in the place of a Primary Key if need be, but are not actual Primary\n   Keys. Unlike Primary Keys, multiple Candidate Keys may exist per table.\n * Alternate Key:  Refers to a single Candidate Key (an alternative which can\n   satisfy the duty of a Primary Key id need be).\n * Composite/Compound Key:  Defined by combing the values of multiple columns;\n   the sum of which will always produce a unique value. There can be multiple\n   Candidate Keys in one table. Each Candidate Key can work as Primary Key.\n * Unique Key:  A set of one or more fields/columns of a table that uniquely\n   identify a record in a database table. Similar to Primary key, but it can\n   accept only one null value, and it can not have duplicate values.\n * Foreign Key: Foreign keys denote fields that serve as another table's \n   Primary key. Foreign keys are useful for building relationships between\n   tables. While a foreign key is required in the parent table where they are\n   primary, foreign keys can be null or empty in the tables intended to relate\n   to the other table.\n\nLet's look at an example query where we add a key to a table and dissect the\npieces:\n\nALTER TABLE table_name\nADD FOREIGN KEY foreign_key_name (column_name)\nREFERENCES parent_table(columns)\nON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }\nON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }\n\n\nALTER TABLE  is used to make any changes to a table's structure, whether that be\nmodifying columns or keys.\n\nIn this example, we ADD  a key which happens to be a FOREIGN KEY. While keys\nalways refer to columns, keys themselves must have names of their own to\ndistinguish the column's data and a key's conceptual logic. We name our key \nforeign_key_name  and specify which column the key will act on with \n(column_name). Because this is a foreign key, we need to specify which table's \nprimary key  we want this to be associated with. REFERENCES\nparent_table(primary_key_column)  is stating that the foreign key in this table\ncorresponds to values held in a column named primary_key_column, in a table\nnamed parent_table.\n\nThe statements ON DELETE  and ON UPDATE  are actions which take place if the\nparent table's primary key is deleted or updated, respectively. ON DELETE\nCASCADE  would result in our tables foreign key being deleted if the\ncorresponding primary key were to disappear.\n\nAdding Columns\nAdding columns follows the same syntax we used when creating tables. An\ninteresting additional feature is the ability to place the new column before or\nafter preexisting columns:\n\nALTER TABLE table_name\nADD COLUMN column_name [DATA_TYPE] [FIRST|AFTER existing_column];\n\n\nWhen referencing tables in PostgreSQL databases, we must specify the schema\nbelongs to. Thus, ALTER TABLE table_name  becomes ALTER TABLE\nschema_name.table_name. This applies to any time we reference tables, including\nwhen we create and delete tables.Pop Quiz\nThe below statement uses elements of everything we've learned about modifying\nand creating table structures thus far. Can you discern what is happening here?\n\nCREATE TABLE vendors(\n    vdr_id int not null auto_increment primary key,\n    vdr_name varchar(255)\n)ENGINE=InnoDB;\n \nALTER TABLE products \nADD COLUMN vdr_id int not null AFTER cat_id;\n\nALTER TABLE products\nADD FOREIGN KEY fk_vendor(vdr_id)\nREFERENCES vendors(vdr_id)\nON DELETE NO ACTION\nON UPDATE CASCADE;\n\n\nDropping Data\nDANGER ZONE: this is where we can start to mess things up. Dropping columns or\ntables results in a complete loss of data: whenever you see the word \"drop,\" be\nscared.\n\nIf you're sure you know what you're doing and would like to remove a table\ncolumn, this can be done as such:\n\nALTER TABLE table\nDROP column;\n\n\nDropping a table destroys the table structure as well as all data within it:\n\nDROP TABLE table_name;\n\n\nTruncating a table, on the other hand, will purge the table of data but retain\nthe table itself:\n\nTRUNCATE TABLE table_name;\n\n\nDrop Foreign Key\nLike tables and columns, we can drop keys as well:\n\nALTER TABLE table_name \nDROP FOREIGN KEY constraint_name;\n\n\nThis can also be handed by dropping CONSTRAINT:\n\nALTER TABLE public.jira_epiccolors\nDROP CONSTRAINT jira_epiccolors_pkey;\n\n\nWorking with Views (Specific to PostgreSQL)\nLastly, let's explore the act of creating views. There are three types of views\nPostgreSQL can handle:\n\n * Simple Views: Virtual tables which represent data of underlying tables.\n   Simple views are automatically updatable: the system will allow INSERT,\n   UPDATE and DELETE statements to be used on the view in the same way as on a\n   regular table.\n * Materialized Views: PostgreSQL extends the view concept to a next level that\n   allows views to store data 'physically', and we call those views are\n   materialized views. A materialized view caches the result of a complex query\n   and then allow you to refresh the result periodically.\n * Recursive Views: Recursive views are a bit difficult to explain without\n   delving deep into the complicated (but cool!) functionality of recursive\n   reporting. I won't get into the details, but these views are able to\n   represent relationships which go multiple layers deep. Here's a quick taste,\n   if you;re curious:\n\nSample RECURSIVE  query:\n\nWITH RECURSIVE reporting_line AS (\n SELECT\n employee_id,\n full_name AS subordinates\n FROM\n employees\n WHERE\n manager_id IS NULL\n UNION ALL\n SELECT\n e.employee_id,\n (\n rl.subordinates || ' > ' || e.full_name\n ) AS subordinates\n FROM\n employees e\n INNER JOIN reporting_line rl ON e.manager_id = rl.employee_id\n) SELECT\n employee_id,\n subordinates\nFROM\n reporting_line\nORDER BY\n employee_id;\n\n\nOutput:\n\n employee_id |                         subordinates\n-------------+--------------------------------------------------------------\n           1 | Michael North\n           2 | Michael North > Megan Berry\n           3 | Michael North > Sarah Berry\n           4 | Michael North > Zoe Black\n           5 | Michael North > Tim James\n           6 | Michael North > Megan Berry > Bella Tucker\n           7 | Michael North > Megan Berry > Ryan Metcalfe\n           8 | Michael North > Megan Berry > Max Mills\n           9 | Michael North > Megan Berry > Benjamin Glover\n          10 | Michael North > Sarah Berry > Carolyn Henderson\n          11 | Michael North > Sarah Berry > Nicola Kelly\n          12 | Michael North > Sarah Berry > Alexandra Climo\n          13 | Michael North > Sarah Berry > Dominic King\n          14 | Michael North > Zoe Black > Leonard Gray\n          15 | Michael North > Zoe Black > Eric Rampling\n          16 | Michael North > Megan Berry > Ryan Metcalfe > Piers Paige\n          17 | Michael North > Megan Berry > Ryan Metcalfe > Ryan Henderson\n          18 | Michael North > Megan Berry > Max Mills > Frank Tucker\n          19 | Michael North > Megan Berry > Max Mills > Nathan Ferguson\n          20 | Michael North > Megan Berry > Max Mills > Kevin Rampling\n(20 rows)\n\n\nCreating a View\nCreating a simple view is as simple as writing a standard query! All that is\nrequired is the addition of CREATE VIEW view_name AS  before the query, and this\nwill create a saved place for us to always come back and reference the results\nof this query:\n\nCREATE VIEW comedies AS\n    SELECT *\n    FROM films\n    WHERE kind = 'Comedy';\n\n\nGet Out There and Start SQLing\nI highly encourage anybody to get in the habit of always writing SQL queries by\nhand. With the right GUI, autocompletion can be your best friend.\n\nExplicitly forcing one's self to write queries instead of copy & pasting\nanything forces us to come to realizations, such as SQL's order of operations.\nIndeed, this query holds the correct syntax...\n\nSELECT *\nFROM table_name\nWHERE column_name = 'Value';\n\n\n...Whereas this one does not:\n\nSELECT *\nWHERE column_name = 'Value'\nFROM table_name;\n\n\nGrasping the subtleties of SQL is the difference between being blazing fast and\nmostly clueless. The good news is, you’ll start to find that these concepts\naren’t nearly as daunting as they may have once seemed, so the track from ‘bad\ndata engineer’ to ‘expert’ is an easy win that would be foolish not to take.\n\nStick around for next time where we actually work with data in SQL: The Sequel,\nrated PG-13.","html":"<p>SQL: we all pretend to be experts at it, and mostly get away with it thanks to StackOverflow. Paired with our vast experience of learning how to code in the 90s, our field work of PHPMyAdmin and LAMP stacks basically makes us experts. Go ahead and chalk up a win for your resume.</p><p>SQL has been around longer than our careers have, so why start a series on it <em>now?</em> Surely there’s sufficient enough documentation that we can Google the specifics whenever the time comes for us to write a query? That, my friends, is precisely the problem. Regardless of what tools we have at our disposable, some skills are better learned and practiced by heart. SQL is one of those skills.</p><p>Sure, SQLAlchemy or similar ORMs might protect us here-and-there from writing raw queries. Considering SQL is just one of many query languages we'll use regularly (in addition to NoSQL, GraphQL, JQL, etc.), is becoming a SQL expert really that critical? In short, yes: relational databases are not only here to stay, but <em>thinking</em> in queries as a second language solidifies one's understanding of the fine details of data. <a href=\"https://towardsdatascience.com/python-vs-sql-comparison-for-data-pipelines-8ca727b34032\">Marc Laforet</a> recently published a Medium post which drives home just how important leaning on SQL is:</p><blockquote>\n<p>What’s even more interesting is that when these transformation scripts were applied to the 6.5 GB dataset, python completely failed. Out of 3 attempts, python crashed 2 times and my computer completely froze the 3rd time… while SQL took 226 seconds.</p>\n</blockquote>\n<p>Keeping logic out of our apps and pipelines and in SQL results in exponentially faster execution, while also being more readable and universally understood than whatever we’d write in our language of choice. The lower down we can push application logic in our stack, the better. This is why I’d much prefer to see the datasphere saturated with SQL tutorials as opposed to Pandas tutorials.</p><h2 id=\"relational-database-terminology\">Relational Database Terminology</h2><p>I hate it when informational material kicks off with covering obvious terminology definitions. Under normal circumstances, I find this to be cliche, unhelpful, and damaging to an author's credibility; but these aren't normal circumstances. In SQL, vocabulary commonly has multiple meanings depending on context, or even which flavor database you're using. Given this fact, it's entirely possible (and common) for individuals to rack up experience with relational databases while completely misinterpreting fundamental concepts. Let's make sure that doesn't happen:</p><ul>\n<li><strong>Databases</strong>: Every Database instance is separated at the highest level into <em>databases</em>. Yes, a database is a collection of databases - we're already off to a great start.</li>\n<li><strong>Schemas</strong>: In PostgreSQL (and other databases), a <em>schema</em> is a grouping of tables and other objects, including views, relations, etc. A schema is a way of organizing data. Schemas imply that all the data belonging to it is at some form related, even if only by concept. Note that the term <em>schema</em> is sometimes used to describe other concepts depending on the context.</li>\n<li><strong>Tables</strong>: The meat and potatos of relational databases. Tables consist of rows and columns which hold our sweet, sweet data. Columns are best thought of as 'attributes', whereas rows are entries which consist of values for said attributes. All values in a column must share the same data type.\n<ul>\n<li><strong>Keys</strong>: Keys are used to help us organize and optimize data, as well as place certain constraints on data coming in (for example, email addresses of user accounts must be <em>unique</em>). Keys can also help us keep count of our entries, ensure automatically unique values, and provide a bridge to link multiple tables of data.\n<ul>\n<li><strong>Primary keys</strong>:  Identification tags for each row of data. The primary key is different for every record in the relational database; values must be provided, and they must be unique between rows.</li>\n<li><strong>Foreign keys</strong>: Enable data searches and manipulation between the primary database table and other related databases.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Objects</strong>: A blanket term for anything (including relations) that exist in a schema (somewhat PostgreSQL-specific).\n<ul>\n<li><strong>Views (PostgreSQL)</strong>: Views display data in a fashion similar to tables, with the difference that views do not <em>store</em> data. Views are a snapshot of data pulled from other tables in the form of a query; a good way to think about views is to consider them to be 'virtual tables.'</li>\n<li><strong>Functions  (PostgreSQL)</strong>: Logic for interacting with data saved for the purpose of being reused.</li>\n</ul>\n</li>\n</ul>\n<div class=\"protip\">\nIn MySQL, a <strong>schema</strong> is synonymous with a <strong>database</strong>. These keywords can even be swapped to use SCHEMA and DATABASE interchangably in MySQL. Thus, using <code>CREATE SCHEMA</code> acheives the same effect as instead of <code>CREATE DATABASE</code>.   \n</div><h2 id=\"navigating-and-creating-databases\">Navigating and Creating Databases</h2><p>We've got to start somewhere, so it might as well be with database management. Admittedly, this will be the most useless of the things we'll cover. The act of navigating databases is best suited for a GUI.</p><h3 id=\"show-databases\">Show Databases</h3><p>If you access your database via command line shell (for some reason), the first logical thing to do is to list the available databases:</p><pre><code class=\"language-sql\">SHOW DATABASES;\n \n+--------------------+\n| Database           |\n+--------------------+\n| classicmodels      |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n</code></pre>\n<h3 id=\"use-database\">USE Database</h3><p>Now that we've listed the possible databases we can connect to, we can explore what each of these contains. To do this, we have to specify which database we want to connect to, AKA \"use.\" </p><pre><code class=\"language-sql\">db&gt; USE database_name;\nDatabase changed\n</code></pre>\n<h3 id=\"create-database\">Create Database</h3><p>Creating databases is straightforward. Be sure to pay attention to the <em>character set</em> when creating a database: this will determine which types of characters your database will be able to accept. For example, if we try to insert special encoded characters into a simple UTF-8 database, those characters won’t turn out as we’d expect.</p><pre><code class=\"language-sql\">CREATE DATABASE IF NOT EXISTS database_name\nCHARACTER SET utf-8\n[COLLATE collation_name]\n</code></pre>\n<p>Bonus: here's the shorthand for creating a database and then showing the result:</p><pre><code class=\"language-sql\">SHOW CREATE DATABASE database_name;\n</code></pre>\n<h2 id=\"creating-and-modifying-tables\">Creating and Modifying Tables</h2><p>Creating tables via SQL syntax can be critical when automating data imports. When creating a table, we also set the column names, types, and keys:</p><pre><code>CREATE TABLE [IF NOT EXISTS] table_name (\n   column_name_1 [COLUMN_DATA_TYPE] [KEY_TYPE] [KEY_ATTRIBUTES] DEFAULT [DEFAULT_VALUE],\n   column_name_2 [COLUMN_DATA_TYPE] [KEY_TYPE] [KEY_ATTRIBUTES] DEFAULT [DEFAULT_VALUE],\n   PRIMARY KEY (column_name_1)\n) ENGINE=[ENGINE_TYPE];</code></pre><p>We can specify <code>IF NOT EXISTS</code> when creating our table if we'd like to include validation in our query. When present, the table will only be created if a table of the specified name does not exist.</p><p>When creating each of our columns, there are a number of things we can specify per-column:</p><ul><li><strong>Data Type (required):</strong> The data which can be saved to cells of this column (such as INTEGER, TEXT, etc).</li><li><strong>Key Type:</strong> Creates a key for the column.</li><li><strong>Key Attributes:</strong> Any key-related attributes, such as auto-incrementing.</li><li><strong>Default:</strong> If rows are created in the table without values passed to the current column, the value specified as <code>DEFAULT</code> </li><li><strong>Primary Key:</strong> Allows any of the previous specified columns to be set as the table's primary key.</li></ul><p>MySQL tables can have a 'storage engine' specified via <code>ENGINE=[engine_type]</code>, which determines the core logic of how the table will interpret data. Leaving this blank defaults to InnoDB and is almost certainly fine to be left alone. In case you're interested, you can find more about MySQL engines <a href=\"https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html\">here</a>.</p><p>Here's an example of what an actual <code>CREATE TABLE</code> query would look like:</p><pre><code>CREATE TABLE IF NOT EXISTS awards (\n   id INTEGER PRIMARY KEY AUTO_INCREMENT,\n   recipient TEXT NOT NULL,\n   award_name TEXT DEFAULT 'Grammy',\n   PRIMARY KEY (id)\n) ENGINE=INNODB;</code></pre><h3 id=\"managing-keys-for-existing-tables\">Managing Keys for Existing Tables</h3><p>If we don't specify our keys at table creation time, we can always do so after the fact. SQL tables can accept the following key types:</p><ul><li><strong>Primary Key:</strong> One or more fields/columns that uniquely identify a record in the table. It can not accept null, duplicate values.</li><li><strong>Candidate Key:</strong> Candidate keys are kind of like groups of non-committed Primary Keys; these keys only accept unique values, and <em>could potentially</em> be used in the place of a Primary Key if need be, but are not actual Primary Keys. Unlike Primary Keys, multiple Candidate Keys may exist per table.</li><li><strong>Alternate Key:</strong> Refers to a single Candidate Key (an alternative which can satisfy the duty of a Primary Key id need be).</li><li><strong>Composite/Compound Key:</strong> Defined by combing the values of multiple columns; the sum of which will always produce a unique value. There can be multiple Candidate Keys in one table. Each Candidate Key can work as Primary Key.</li><li><strong>Unique Key:</strong> A set of one or more fields/columns of a table that uniquely identify a record in a database table. Similar to Primary key, but it can accept only one null value, and it can not have duplicate values.</li><li><strong>Foreign Key: </strong>Foreign keys denote fields that serve as <em>another table's</em> Primary key. Foreign keys are useful for building relationships between tables. While a foreign key is required in the parent table where they are primary, foreign keys can be null or empty in the tables intended to relate to the other table.</li></ul><p>Let's look at an example query where we add a key to a table and dissect the pieces:</p><pre><code class=\"language-sql\">ALTER TABLE table_name\nADD FOREIGN KEY foreign_key_name (column_name)\nREFERENCES parent_table(columns)\nON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }\nON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }\n</code></pre>\n<p><code>ALTER TABLE</code> is used to make any changes to a table's structure, whether that be modifying columns or keys.</p><p>In this example, we <code>ADD</code> a key which happens to be a <code>FOREIGN KEY</code>. While keys always refer to columns, keys themselves must have names of their own to distinguish the column's data and a key's conceptual logic. We name our key <code>foreign_key_name</code> and specify which column the key will act on with <code>(column_name)</code>. Because this is a foreign key, we need to specify which table's <em>primary key</em> we want this to be associated with. <code>REFERENCES parent_table(primary_key_column)</code> is stating that the foreign key in this table corresponds to values held in a column named <code>primary_key_column</code>, in a table named <code>parent_table</code>.</p><p>The statements <code>ON DELETE</code> and <code>ON UPDATE</code> are actions which take place if the parent table's primary key is deleted or updated, respectively. <code>ON DELETE CASCADE</code> would result in our tables foreign key being deleted if the corresponding primary key were to disappear.</p><h3 id=\"adding-columns\">Adding Columns</h3><p>Adding columns follows the same syntax we used when creating tables. An interesting additional feature is the ability to place the new column before or after preexisting columns:</p><pre><code class=\"language-sql\">ALTER TABLE table_name\nADD COLUMN column_name [DATA_TYPE] [FIRST|AFTER existing_column];\n</code></pre>\n<div class=\"protip\">\nWhen referencing tables in PostgreSQL databases, we must specify the schema belongs to. Thus, <code>ALTER TABLE table_name</code> becomes <code>ALTER TABLE schema_name.table_name</code>. This applies to any time we reference tables, including when we create and delete tables.\n</div><h3 id=\"pop-quiz\">Pop Quiz</h3><p>The below statement uses elements of everything we've learned about modifying and creating table structures thus far. Can you discern what is happening here?</p><pre><code class=\"language-sql\">CREATE TABLE vendors(\n    vdr_id int not null auto_increment primary key,\n    vdr_name varchar(255)\n)ENGINE=InnoDB;\n \nALTER TABLE products \nADD COLUMN vdr_id int not null AFTER cat_id;\n\nALTER TABLE products\nADD FOREIGN KEY fk_vendor(vdr_id)\nREFERENCES vendors(vdr_id)\nON DELETE NO ACTION\nON UPDATE CASCADE;\n</code></pre>\n<h2 id=\"dropping-data\">Dropping Data</h2><p>DANGER ZONE: this is where we can start to mess things up. Dropping columns or tables results in a complete loss of data: whenever you see the word \"drop,\" be scared.</p><p>If you're sure you know what you're doing and would like to remove a table column, this can be done as such:</p><pre><code class=\"language-sql\">ALTER TABLE table\nDROP column;\n</code></pre>\n<p>Dropping a table destroys the table structure as well as all data within it:</p><pre><code class=\"language-sql\">DROP TABLE table_name;\n</code></pre>\n<p>Truncating a table, on the other hand, will purge the table of data but retain the table itself:</p><pre><code class=\"language-sql\">TRUNCATE TABLE table_name;\n</code></pre>\n<h3 id=\"drop-foreign-key\">Drop Foreign Key</h3><p>Like tables and columns, we can drop keys as well:</p><pre><code class=\"language-sql\">ALTER TABLE table_name \nDROP FOREIGN KEY constraint_name;\n</code></pre>\n<p>This can also be handed by dropping CONSTRAINT:</p><pre><code class=\"language-sql\">ALTER TABLE public.jira_epiccolors\nDROP CONSTRAINT jira_epiccolors_pkey;\n</code></pre>\n<h2 id=\"working-with-views-specific-to-postgresql-\">Working with Views (Specific to PostgreSQL)</h2><p>Lastly, let's explore the act of creating views. There are three types of views PostgreSQL can handle:</p><ul>\n<li><strong>Simple Views</strong>: Virtual tables which represent data of underlying tables. Simple views are automatically updatable: the system will allow INSERT, UPDATE and DELETE statements to be used on the view in the same way as on a regular table.</li>\n<li><strong>Materialized Views</strong>: PostgreSQL extends the view concept to a next level that allows views to store data 'physically', and we call those views are materialized views. A materialized view caches the result of a complex query and then allow you to refresh the result periodically.</li>\n<li><strong>Recursive Views</strong>: Recursive views are a bit difficult to explain without delving deep into the complicated (but cool!) functionality of recursive reporting. I won't get into the details, but these views are able to represent relationships which go multiple layers deep. Here's a quick taste, if you;re curious:</li>\n</ul>\n<p><strong>Sample </strong><code>RECURSIVE</code> <strong>query:</strong></p><pre><code class=\"language-sql\">WITH RECURSIVE reporting_line AS (\n SELECT\n employee_id,\n full_name AS subordinates\n FROM\n employees\n WHERE\n manager_id IS NULL\n UNION ALL\n SELECT\n e.employee_id,\n (\n rl.subordinates || ' &gt; ' || e.full_name\n ) AS subordinates\n FROM\n employees e\n INNER JOIN reporting_line rl ON e.manager_id = rl.employee_id\n) SELECT\n employee_id,\n subordinates\nFROM\n reporting_line\nORDER BY\n employee_id;\n</code></pre>\n<p><strong>Output:</strong></p><pre><code class=\"language-shell\"> employee_id |                         subordinates\n-------------+--------------------------------------------------------------\n           1 | Michael North\n           2 | Michael North &gt; Megan Berry\n           3 | Michael North &gt; Sarah Berry\n           4 | Michael North &gt; Zoe Black\n           5 | Michael North &gt; Tim James\n           6 | Michael North &gt; Megan Berry &gt; Bella Tucker\n           7 | Michael North &gt; Megan Berry &gt; Ryan Metcalfe\n           8 | Michael North &gt; Megan Berry &gt; Max Mills\n           9 | Michael North &gt; Megan Berry &gt; Benjamin Glover\n          10 | Michael North &gt; Sarah Berry &gt; Carolyn Henderson\n          11 | Michael North &gt; Sarah Berry &gt; Nicola Kelly\n          12 | Michael North &gt; Sarah Berry &gt; Alexandra Climo\n          13 | Michael North &gt; Sarah Berry &gt; Dominic King\n          14 | Michael North &gt; Zoe Black &gt; Leonard Gray\n          15 | Michael North &gt; Zoe Black &gt; Eric Rampling\n          16 | Michael North &gt; Megan Berry &gt; Ryan Metcalfe &gt; Piers Paige\n          17 | Michael North &gt; Megan Berry &gt; Ryan Metcalfe &gt; Ryan Henderson\n          18 | Michael North &gt; Megan Berry &gt; Max Mills &gt; Frank Tucker\n          19 | Michael North &gt; Megan Berry &gt; Max Mills &gt; Nathan Ferguson\n          20 | Michael North &gt; Megan Berry &gt; Max Mills &gt; Kevin Rampling\n(20 rows)\n</code></pre>\n<h3 id=\"creating-a-view\">Creating a View</h3><p>Creating a simple view is as simple as writing a standard query! All that is required is the addition of <code>CREATE VIEW view_name AS</code> before the query, and this will create a saved place for us to always come back and reference the results of this query:</p><pre><code class=\"language-sql\">CREATE VIEW comedies AS\n    SELECT *\n    FROM films\n    WHERE kind = 'Comedy';\n</code></pre>\n<h2 id=\"get-out-there-and-start-sqling\">Get Out There and Start SQLing</h2><p>I highly encourage anybody to get in the habit of <em>always </em>writing SQL queries by hand. With the right GUI, autocompletion can be your best friend.</p><p>Explicitly forcing one's self to write queries instead of copy &amp; pasting anything forces us to come to realizations, such as SQL's order of operations. Indeed, this query holds the correct syntax...</p><pre><code class=\"language-sql\">SELECT *\nFROM table_name\nWHERE column_name = 'Value';\n</code></pre>\n<p>...Whereas this one does not:</p><pre><code class=\"language-sql\">SELECT *\nWHERE column_name = 'Value'\nFROM table_name;\n</code></pre>\n<p>Grasping the subtleties of SQL is the difference between being blazing fast and mostly clueless. The good news is, you’ll start to find that these concepts aren’t nearly as daunting as they may have once seemed, so the track from ‘bad data engineer’ to ‘expert’ is an easy win that would be foolish not to take.</p><p>Stick around for next time where we actually work with data in <strong>SQL: The Sequel</strong>, rated PG-13.</p>","url":"https://hackersandslackers.com/welcome-to-sql-modifying-databases-and-tables/","uuid":"fe99e822-f21a-432c-8bbf-4d399e575570","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c5bb0ec7999ff33f06876e1"}},{"node":{"id":"Ghost__Post__5c47584f4f3823107c9e8f23","title":"Google BigQuery's Python SDK: Creating Tables Programmatically","slug":"getting-started-google-big-query-python","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/bigquery101@2x.jpg","excerpt":"Create tables in Google BigQuery, auto-generate their schemas, and retrieve said schemas.","custom_excerpt":"Create tables in Google BigQuery, auto-generate their schemas, and retrieve said schemas.","created_at_pretty":"22 January, 2019","published_at_pretty":"02 February, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-22T12:52:15.000-05:00","published_at":"2019-02-02T09:24:00.000-05:00","updated_at":"2019-03-28T17:06:20.000-04:00","meta_title":"Google BigQuery's Python SDK: Creating Tables | Hackers and Slackers","meta_description":"Leverage Google Cloud's Python SDK to create tables in Google BigQuery, auto-generate their schemas, and retrieve said schemas.","og_description":"Leverage Google Cloud's Python SDK to create tables in Google BigQuery, auto-generate their schemas, and retrieve said schemas.","og_image":"https://hackersandslackers.com/content/images/2019/02/bigquery101@2x.jpg","og_title":"Google BigQuery's Python SDK: Creating Tables Programmatically","twitter_description":"Leverage Google Cloud's Python SDK to create tables in Google BigQuery, auto-generate their schemas, and retrieve said schemas.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/bigquery101@2x.jpg","twitter_title":"Google BigQuery's Python SDK: Creating Tables Programmatically","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Big Data","slug":"bigdata","description":"Work with unstructured data across file types and schemas. Tools such as data warehouses, Hadoop, Spark, BigQuery, etc.","feature_image":null,"meta_description":"Work with massive amounts of unstandardized data across file types and schemas. Includes working with data warehouses, Hadoop, Spark, BigQuery, etc.","meta_title":"Big Data | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Big Data","slug":"bigdata","description":"Work with unstructured data across file types and schemas. Tools such as data warehouses, Hadoop, Spark, BigQuery, etc.","feature_image":null,"meta_description":"Work with massive amounts of unstandardized data across file types and schemas. Includes working with data warehouses, Hadoop, Spark, BigQuery, etc.","meta_title":"Big Data | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Google Cloud","slug":"googlecloud","description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/googleseries2.jpg","meta_description":"Evaluating Google Cloud Platform’s offerings. Get introduced with tutorials, see our vendor comparisons, and endure biased opinions on GCP as a whole.","meta_title":"The Rise of Google Cloud | Hackers and Slackers","visibility":"public"},{"name":"#The Rise of Google Cloud","slug":"the-rise-of-google-cloud","description":"Build robust serverless architecture on Google Cloud Platform. Learn through tutorials, make comparisons, and hear opinions on GCP as a whole.","feature_image":"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/ADF7E324-9EAD-4F15-8670-AF205E6804EA.png","meta_description":"Build robust serverless architecture on Google Cloud Platform. Learn through tutorials, make comparisons, and hear opinions on GCP as a whole.","meta_title":"The Rise of Google Cloud","visibility":"internal"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"GCP is on the rise, and it's getting harder and harder to have conversations\naround data without addressing the 500-pound gorilla in the room: Google\nBigQuery. With most enterprises comfortably settled into their Apache-based Big\nData stacks, BigQuery rattles the cages of convention for many. Luckily, Hackers\nAnd Slackers is no such enterprise. Thus, we aren't afraid to ask the Big\nquestion: how much easier would life be with BigQuery?\n\nBig Data, BigQuery\nIn short, BigQuery trivializes the act of querying against multiple,\nunpredictable data sources. To better understand when this is useful, it would\nbetter serve us to identify the types of questions BigQuery can answer. Such as:\n\n * What are our users doing across our multiple systems? How do we leverage log\n   files outputted by multiple systems to find out?\n * How can we consolidate information about employee information, payroll, and\n   benefits, when these all live in isolated systems?\n * What the hell am I supposed to do with all these spreadsheets?\n\nUnlike previous solutions, BigQuery solves these problems in a single product\nand does so with SQL-like query syntax,  a web interface, and 7 native Client\nLibraries.  There are plenty of reasons to love BigQuery, but let's start with\none we've recently already talked about: the auto-generation of table schemas. \n\nMatt has demonstrated how to approach this problem manually with the help of\nPandas\n[https://hackersandslackers.com/downcast-numerical-columns-python-pandas/]. I\nprovided a more gimmicky approach by leveraging the Python table-schema library\n[https://hackersandslackers.com/infer-datatypes-from-csvs-to-create/]. With\nBigQuery, we find yet another alternative which is neither manual or gimmicky:\nperfect for those who are lazy, rich, and demand perfection (AKA: your clients,\nprobably).\n\nFirst, we'll need to get our data into BigQuery\n\nUploading Data into Google Cloud Storage via the Python SDK\nBigQuery requires us to go through Google Cloud Storage as a buffer before\ninputting data into tables. No big deal, we'll write a script!\n\nWe're assuming that you have a basic knowledge of Google Cloud, Google Cloud\nStorage, and how to download a JSON Service Account key\n[https://cloud.google.com/bigquery/docs/reference/libraries]  to store locally\n(hint: click the link).\n\nfrom google.cloud import storage\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    \"\"\"Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    \"\"\"\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n        \n        \nupload_blob(bucket_name, local_dataset, bucket_target)\n\n\nThe above is nearly a copy + paste of Google Cloud's sample code for the Google\nCloud Storage Python SDK:\n\n * bucket_uri  is found by inspecting any bucket's information on Google Cloud.\n * bucket_name  is... well, you know.\n * bucket_target  represents the resulting file structure representing the saved\n   CSV when completed.\n * local_dataset  is the path to a CSV we've stored locally: we can assume that\n   we've grabbed some data from somewhere, like an API, and tossed into a local\n   file temporarily.\n\nSuccessfully executing the above results in the following message:\n\nFile data/test.csv uploaded to datasets/data_upload.csv.\n\n\nInserting Data from Cloud Storage to BigQuery\nThat was the easy part. Let's move on to the good stuff:\n\nfrom google.cloud import storage\nfrom google.cloud import bigquery\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\nbucket_target_uri = bucket_uri + bucket_target\nbigquery_dataset = 'uploadtest'\nbigquery_table = 'my_table'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    \"\"\"Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    \"\"\"\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n\n\ndef insert_bigquery(target_uri, dataset_id, table_id):\n    \"\"\"Insert CSV from Google Storage to BigQuery Table.\n\n    1. Specify target dataset within BigQuery.\n    2. Create a Job configuration.\n    3. Specify that we are autodetecting datatypes.\n    4. Reserve row #1 for headers.\n    5. Specify the source format of the file (defaults to CSV).\n    6. Pass the URI of the data storage on Google Cloud Storage from.\n    7. Load BigQuery Job.\n    8. Execute BigQuery Job.\n    \"\"\"\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    job_config = bigquery.LoadJobConfig()\n    job_config.autodetect = True\n    job_config.skip_leading_rows = 1\n    job_config.source_format = bigquery.SourceFormat.CSV\n    uri = target_uri\n    load_job = bigquery_client.load_table_from_uri(\n        uri,\n        dataset_ref.table(table_id),\n        job_config=job_config)  # API request\n    print('Starting job {}'.format(load_job.job_id))\n    # Waits for table load to complete.\n    load_job.result()\n    print('Job finished.')\n\n\nupload_blob(bucket_name, local_dataset, bucket_target)\ninsert_bigquery(bucket_target_uri, bigquery_dataset, bigquery_table)\n\n\nWe've added the function insert_bigquery()  to handle creating a BigQuery table\nout of a CSV.\n\nAfter we set our client, we create a dataset reference. In BigQuery, tables can\nbelong to a 'dataset,' which is a grouping of tables. Compare this concept to\nMongoDB's collections, or PostgreSQL's schemas. Note that this process is made\nmuch easier by the fact that we stored our project key locally: otherwise, we'd\nhave to specify which Google Cloud project we're looking for, etc.\n\nWith the dataset specified, we begin to build our \"job\" object with \nLoadJobConfig. This is like loading a gun before unleashing a shotgun blast into\nthe face of our problems. Alternatively, a more relevant comparison could be\nwith the Python requests  library and the act of prepping an API request before\nexecution.\n\nWe set job_config.autodetect  to be True, obviously. \njob_config.skip_leading_rows  reserves our header row from screwing things up.\n\nload_job  puts our request together, and load_job.result()  executes said job.\nThe .result()  method graciously puts the rest of our script on hold until the\nspecified job is completed. In our case, we want this happen: it simplifies our\nscript so that we don't need to verify this manually before moving on.\n\nLet's see what running that job with our fake data looks like in the BigQuery\nUI:\n\nAll my fake friends are here!Getting Our Flawlessly Inferred Table Schema\nBigQuery surely gets table schemas wrong some of the time. That said, I have yet\nto see it happen. Let's wrap this script up:\n\nfrom google.cloud import storage\nfrom google.cloud import bigquery\nimport pprint\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\nbucket_target_uri = bucket_uri + bucket_target\nbigquery_dataset = 'uploadtest'\nbigquery_table = 'my_table'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    \"\"\"Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    \"\"\"\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n\n\ndef insert_bigquery(target_uri, dataset_id, table_id):\n    \"\"\"Insert CSV from Google Storage to BigQuery Table.\n\n    1. Specify target dataset within BigQuery.\n    2. Create a Job configuration.\n    3. Specify that we are autodetecting datatypes.\n    4. Reserve row #1 for headers.\n    5. Specify the source format of the file (defaults to CSV).\n    6. Pass the URI of the data storage on Google Cloud Storage from.\n    7. Load BigQuery Job.\n    8. Execute BigQuery Job.\n    \"\"\"\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    job_config = bigquery.LoadJobConfig()\n    job_config.autodetect = True\n    job_config.skip_leading_rows = 1\n    job_config.source_format = bigquery.SourceFormat.CSV\n    uri = target_uri\n    load_job = bigquery_client.load_table_from_uri(\n        uri,\n        dataset_ref.table(table_id),\n        job_config=job_config)  # API request\n    print('Starting job {}'.format(load_job.job_id))\n    # Waits for table load to complete.\n    load_job.result()\n    print('Job finished.')\n\n\ndef get_schema(dataset_id, table_id):\n    \"\"\"Get BigQuery Table Schema.\n\n    1. Specify target dataset within BigQuery.\n    2. Specify target table within given dataset.\n    3. Create Table class instance from existing BigQuery Table.\n    4. Print results to console.\n    5. Return the schema dict.\n    \"\"\"\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    bg_tableref = bigquery.table.TableReference(dataset_ref, table_id)\n    bg_table = bigquery_client.get_table(bg_tableref)\n    # Print Schema to Console\n    pp = pprint.PrettyPrinter(indent=4)\n    pp.pprint(bg_table.schema)\n    return bg_table.schema\n\n\nupload_blob(bucket_name, local_dataset, bucket_target)\ninsert_bigquery(bucket_target_uri, bigquery_dataset, bigquery_table)\nbigquery_table_schema = get_schema(bigquery_dataset, bigquery_table)\n\n\nWith the addition of get_bigquery_schema(), our script is complete!\n\nTableReference()  is similar to the dataset reference we went over earlier, only\nfor tables (duh). This allows us to call upon get_table(), which returns a Table\nclass representing the table we just created. Amongst the methods of that class,\nwe can call .schema(), which gives us precisely what we want: a beautiful\nrepresentation of a Table schema, generated from raw CSV information, where\nthere previously was none.\n\nBehold the fruits of your labor:\n\n[   SchemaField('id', 'INTEGER', 'NULLABLE', None, ()),\n    SchemaField('initiated', 'TIMESTAMP', 'NULLABLE', None, ()),\n    SchemaField('hiredate', 'DATE', 'NULLABLE', None, ()),\n    SchemaField('email', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('firstname', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('lastname', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('title', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('department', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('location', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('country', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('type', 'STRING', 'NULLABLE', None, ())]\n\n\nThere you have it; a correctly inferred schema, from data which wasn't entirely\nclean in the first place (our dates are in MM/DD/YY  format as opposed to \nMM/DD/YYYY, but Google still gets it right. How? Because Google).\n\nIt Doesn't End Here\nI hope it goes without saying that abusing Google BigQuery's API to generate\nschemas for you is only a small, obscure use case of what Google BigQuery is\nintended to do, and what it can do for you. That said, I need to stop this\nfanboying post before anybody realizes I'll promote their products for free\nforever (I think I may have passed that point).\n\nIn case you're interested, the source code for this script has been uploaded as\na Gist here\n[https://gist.github.com/toddbirchard/a743db3b8805dfe9834e73c530dc8a6e]. Have at\nit, and remember to think Big™*.\n\n*Not a real trademark, I'm making things up again.","html":"<p>GCP is on the rise, and it's getting harder and harder to have conversations around data without addressing the 500-pound gorilla in the room: Google BigQuery. With most enterprises comfortably settled into their Apache-based Big Data stacks, BigQuery rattles the cages of convention for many. Luckily, Hackers And Slackers is no such enterprise. Thus, we aren't afraid to ask the Big question: how much easier would life be with BigQuery?</p><h2 id=\"big-data-bigquery\">Big Data, BigQuery</h2><p>In short, BigQuery trivializes the act of querying against multiple, unpredictable data sources. To better understand when this is useful, it would better serve us to identify the types of questions BigQuery can answer. Such as:</p><ul><li>What are our users doing across our multiple systems? How do we leverage log files outputted by multiple systems to find out?</li><li>How can we consolidate information about employee information, payroll, and benefits, when these all live in isolated systems?</li><li>What the hell am I supposed to do with all these spreadsheets?</li></ul><p>Unlike previous solutions, BigQuery solves these problems in a single product and does so with <strong>SQL-like query syntax,</strong> a <strong>web interface</strong>, and <strong>7 native Client Libraries.</strong> There are plenty of reasons to love BigQuery, but let's start with one we've recently already talked about: the <em>auto-generation of table schemas</em>. </p><p>Matt has demonstrated how to approach this problem <a href=\"https://hackersandslackers.com/downcast-numerical-columns-python-pandas/\">manually with the help of Pandas</a>. I provided a more gimmicky approach by leveraging the <a href=\"https://hackersandslackers.com/infer-datatypes-from-csvs-to-create/\">Python table-schema library</a>. With BigQuery, we find yet another alternative which is neither manual or gimmicky: perfect for those who are lazy, rich, and demand perfection (AKA: your clients, probably).</p><p>First, we'll need to get our data into BigQuery</p><h2 id=\"uploading-data-into-google-cloud-storage-via-the-python-sdk\">Uploading Data into Google Cloud Storage via the Python SDK</h2><p>BigQuery requires us to go through Google Cloud Storage as a buffer before inputting data into tables. No big deal, we'll write a script!</p><p>We're assuming that you have a basic knowledge of Google Cloud, Google Cloud Storage, and how to download a <a href=\"https://cloud.google.com/bigquery/docs/reference/libraries\">JSON Service Account key</a> to store locally (hint: click the link).</p><pre><code class=\"language-python\">from google.cloud import storage\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    &quot;&quot;&quot;Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    &quot;&quot;&quot;\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n        \n        \nupload_blob(bucket_name, local_dataset, bucket_target)\n</code></pre>\n<p>The above is nearly a copy + paste of Google Cloud's sample code for the Google Cloud Storage Python SDK:</p><ul><li><code>bucket_uri</code> is found by inspecting any bucket's information on Google Cloud.</li><li><code>bucket_name</code> is... well, you know.</li><li><code>bucket_target</code><strong> </strong>represents the resulting file structure representing the saved CSV when completed.</li><li><code>local_dataset</code> is the path to a CSV we've stored locally: we can assume that we've grabbed some data from somewhere, like an API, and tossed into a local file temporarily.</li></ul><p>Successfully executing the above results in the following message:</p><pre><code class=\"language-shell\">File data/test.csv uploaded to datasets/data_upload.csv.\n</code></pre>\n<h2 id=\"inserting-data-from-cloud-storage-to-bigquery\">Inserting Data from Cloud Storage to BigQuery</h2><p>That was the easy part. Let's move on to the good stuff:</p><pre><code class=\"language-python\">from google.cloud import storage\nfrom google.cloud import bigquery\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\nbucket_target_uri = bucket_uri + bucket_target\nbigquery_dataset = 'uploadtest'\nbigquery_table = 'my_table'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    &quot;&quot;&quot;Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    &quot;&quot;&quot;\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n\n\ndef insert_bigquery(target_uri, dataset_id, table_id):\n    &quot;&quot;&quot;Insert CSV from Google Storage to BigQuery Table.\n\n    1. Specify target dataset within BigQuery.\n    2. Create a Job configuration.\n    3. Specify that we are autodetecting datatypes.\n    4. Reserve row #1 for headers.\n    5. Specify the source format of the file (defaults to CSV).\n    6. Pass the URI of the data storage on Google Cloud Storage from.\n    7. Load BigQuery Job.\n    8. Execute BigQuery Job.\n    &quot;&quot;&quot;\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    job_config = bigquery.LoadJobConfig()\n    job_config.autodetect = True\n    job_config.skip_leading_rows = 1\n    job_config.source_format = bigquery.SourceFormat.CSV\n    uri = target_uri\n    load_job = bigquery_client.load_table_from_uri(\n        uri,\n        dataset_ref.table(table_id),\n        job_config=job_config)  # API request\n    print('Starting job {}'.format(load_job.job_id))\n    # Waits for table load to complete.\n    load_job.result()\n    print('Job finished.')\n\n\nupload_blob(bucket_name, local_dataset, bucket_target)\ninsert_bigquery(bucket_target_uri, bigquery_dataset, bigquery_table)\n</code></pre>\n<p>We've added the function <code>insert_bigquery()</code> to handle creating a BigQuery table out of a CSV.</p><p>After we set our client, we create a <strong>dataset reference</strong>. In BigQuery, tables can belong to a 'dataset,' which is a grouping of tables. Compare this concept to MongoDB's <strong>collections, </strong>or PostgreSQL's <strong>schemas</strong>. Note that this process is made much easier by the fact that we stored our project key locally: otherwise, we'd have to specify which Google Cloud project we're looking for, etc.</p><p>With the dataset specified, we begin to build our \"job\" object with <code>LoadJobConfig</code>. This is like loading a gun before unleashing a shotgun blast into the face of our problems. Alternatively, a more relevant comparison could be with the Python <code>requests</code> library and the act of prepping an API request before execution.</p><p>We set <code>job_config.autodetect</code> to be <code>True</code>, obviously. <code>job_config.skip_leading_rows</code> reserves our header row from screwing things up.</p><p><code>load_job</code> puts our request together, and <code>load_job.result()</code> executes said job. The <code>.result()</code> method graciously puts the rest of our script on hold until the specified job is completed. In our case, we want this happen: it simplifies our script so that we don't need to verify this manually before moving on.</p><p>Let's see what running that job with our fake data looks like in the BigQuery UI:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2019-02-01-at-7.42.52-PM.png\" class=\"kg-image\"><figcaption>All my fake friends are here!</figcaption></figure><h2 id=\"getting-our-flawlessly-inferred-table-schema\">Getting Our Flawlessly Inferred Table Schema</h2><p>BigQuery surely gets table schemas wrong <em>some </em>of the time. That said, I have yet to see it happen. Let's wrap this script up:</p><pre><code class=\"language-python\">from google.cloud import storage\nfrom google.cloud import bigquery\nimport pprint\n\nbucket_uri = 'gs://your-bucket/'\nbucket_name = 'your-bucket'\nbucket_target = 'datasets/data_upload.csv'\nlocal_dataset = 'data/test.csv'\nbucket_target_uri = bucket_uri + bucket_target\nbigquery_dataset = 'uploadtest'\nbigquery_table = 'my_table'\n\n\ndef upload_blob(bucket_name, source_file_name, destination_blob_name):\n    &quot;&quot;&quot;Upload a CSV to Google Cloud Storage.\n\n    1. Retrieve the target bucket.\n    2. Set destination of data to be uploaded.\n    3. Upload local CSV.\n    &quot;&quot;&quot;\n    storage_client = storage.Client()\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob(destination_blob_name)\n    # Commence Upload\n    blob.upload_from_filename(source_file_name)\n    print('File {} uploaded to {}.'.format(\n        source_file_name,\n        destination_blob_name))\n\n\ndef insert_bigquery(target_uri, dataset_id, table_id):\n    &quot;&quot;&quot;Insert CSV from Google Storage to BigQuery Table.\n\n    1. Specify target dataset within BigQuery.\n    2. Create a Job configuration.\n    3. Specify that we are autodetecting datatypes.\n    4. Reserve row #1 for headers.\n    5. Specify the source format of the file (defaults to CSV).\n    6. Pass the URI of the data storage on Google Cloud Storage from.\n    7. Load BigQuery Job.\n    8. Execute BigQuery Job.\n    &quot;&quot;&quot;\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    job_config = bigquery.LoadJobConfig()\n    job_config.autodetect = True\n    job_config.skip_leading_rows = 1\n    job_config.source_format = bigquery.SourceFormat.CSV\n    uri = target_uri\n    load_job = bigquery_client.load_table_from_uri(\n        uri,\n        dataset_ref.table(table_id),\n        job_config=job_config)  # API request\n    print('Starting job {}'.format(load_job.job_id))\n    # Waits for table load to complete.\n    load_job.result()\n    print('Job finished.')\n\n\ndef get_schema(dataset_id, table_id):\n    &quot;&quot;&quot;Get BigQuery Table Schema.\n\n    1. Specify target dataset within BigQuery.\n    2. Specify target table within given dataset.\n    3. Create Table class instance from existing BigQuery Table.\n    4. Print results to console.\n    5. Return the schema dict.\n    &quot;&quot;&quot;\n    bigquery_client = bigquery.Client()\n    dataset_ref = bigquery_client.dataset(dataset_id)\n    bg_tableref = bigquery.table.TableReference(dataset_ref, table_id)\n    bg_table = bigquery_client.get_table(bg_tableref)\n    # Print Schema to Console\n    pp = pprint.PrettyPrinter(indent=4)\n    pp.pprint(bg_table.schema)\n    return bg_table.schema\n\n\nupload_blob(bucket_name, local_dataset, bucket_target)\ninsert_bigquery(bucket_target_uri, bigquery_dataset, bigquery_table)\nbigquery_table_schema = get_schema(bigquery_dataset, bigquery_table)\n</code></pre>\n<p>With the addition of <code>get_bigquery_schema()</code>, our script is complete!</p><p><code>TableReference()</code> is similar to the dataset reference we went over earlier, only for tables (duh). This allows us to call upon <code>get_table()</code>, which returns a Table class representing the table we just created. Amongst the methods of that class, we can call <code>.schema()</code>, which gives us precisely what we want: a beautiful representation of a Table schema, generated from raw CSV information, where there previously was none.</p><p>Behold the fruits of your labor:</p><pre><code class=\"language-python\">[   SchemaField('id', 'INTEGER', 'NULLABLE', None, ()),\n    SchemaField('initiated', 'TIMESTAMP', 'NULLABLE', None, ()),\n    SchemaField('hiredate', 'DATE', 'NULLABLE', None, ()),\n    SchemaField('email', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('firstname', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('lastname', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('title', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('department', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('location', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('country', 'STRING', 'NULLABLE', None, ()),\n    SchemaField('type', 'STRING', 'NULLABLE', None, ())]\n</code></pre>\n<p>There you have it; a correctly inferred schema, from data which wasn't entirely clean in the first place (our dates are in <strong>MM/DD/YY</strong> format as opposed to <strong>MM/DD/YYYY</strong>, but Google still gets it right. How? Because Google).</p><h3 id=\"it-doesn-t-end-here\">It Doesn't End Here</h3><p>I hope it goes without saying that abusing Google BigQuery's API to generate schemas for you is only a small, obscure use case of what Google BigQuery is intended to do, and what it can do for you. That said, I need to stop this fanboying post before anybody realizes I'll promote their products for free forever (I think I may have passed that point).</p><p>In case you're interested, the source code for this script has been uploaded as a Gist <a href=\"https://gist.github.com/toddbirchard/a743db3b8805dfe9834e73c530dc8a6e\">here</a>. Have at it, and remember to think Big<strong>™*</strong>.</p><span style=\"color: #a6a6a6;font-style: italic; font-size: .8em;\">*Not a real trademark, I'm making things up again.</span>","url":"https://hackersandslackers.com/getting-started-google-big-query-python/","uuid":"30051eb2-7fa7-4a09-91fd-c3f11966b398","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c47584f4f3823107c9e8f23"}},{"node":{"id":"Ghost__Post__5c4e57144b23df2da7332b80","title":"Downcast Numerical Data Types with Pandas","slug":"downcast-numerical-columns-python-pandas","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","excerpt":"Using an Example Where We Downcast Numerical Columns.","custom_excerpt":"Using an Example Where We Downcast Numerical Columns.","created_at_pretty":"28 January, 2019","published_at_pretty":"28 January, 2019","updated_at_pretty":"14 February, 2019","created_at":"2019-01-27T20:12:52.000-05:00","published_at":"2019-01-28T07:30:00.000-05:00","updated_at":"2019-02-13T22:50:18.000-05:00","meta_title":"Using Pandas' Assign Function on Multiple Columns | Hackers and Slackers","meta_description":"Using Pandas' Assign function on multiple columns via an example: downcasting numerical columns.","og_description":"Using Pandas' Assign by example: downcasting numerical columns.","og_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","og_title":"Code Snippet Corner: Using Pandas' Assign Function on Multiple Columns","twitter_description":"Using Pandas' Assign by example: downcasting numerical columns.","twitter_image":"https://hackersandslackers.com/content/images/2019/01/codesnippetdatatypes@2x.jpg","twitter_title":"Code Snippet Corner: Using Pandas' Assign Function on Multiple Columns","authors":[{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null}],"primary_author":{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null},"primary_tag":{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#Code Snippet Corner","slug":"code-snippet-corner","description":"Your weekly dose of Python tidbits and Jupyter notebooks to get you feeling saucy.","feature_image":"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/codecornerseries_o_o.jpg","meta_description":"Your weekly dose of Python tidbits and Jupyter notebooks to get you feeling saucy.","meta_title":"Python Code Snippet Corner","visibility":"internal"}],"plaintext":"Recently, I had to find a way to reduce the memory footprint of a Pandas\nDataFrame in order to actually do operations on it.  Here's a trick that came in\nhandy!\n\nBy default, if you read a DataFrame from a file, it'll cast all the numerical\ncolumns as the float64  type.  This is in keeping with the philosophy behind\nPandas and NumPy - by using strict types (instead of normal Python \"duck\ntyping\"), you can do things a lot faster.  The float64  is the most flexible\nnumerical type - it can handle fractions, as well as turning missing values into\na NaN.  This will let us read it into memory, and then start messing with it.\n The downside is that it consumes a lot of memory.\n\nNow, let's say we want to save memory by manually downcasting our columns into\nthe smallest type that can handle its values?  And let's ALSO say that we want\nto be really, really lazy and don't want to look at a bunch of numbers by hand.\n And let's say we wanna do this via Method Chaining, because of all the\nadvantages outlined here: https://tomaugspurger.github.io/method-chaining\n\nLet's introduce our example DataFrame.  We'll convert all the values to floats\nmanually because that's what the default is when we read from a file.\n\ndf = pd.DataFrame({\n    \"stay_float\": [0.5, 3.7, 7.5],\n    \"to_int\": [-5, 7, 5],\n    \"to_uint\": [1, 100, 200]}).astype(float)\n\n\nFirst, let's introduce the workhorse of this exercise - Pandas's to_numeric \nfunction, and its handy optional argument, downcast.  This will take a numerical\ntype - float, integer  (not int), or unsigned  - and then downcast it to the\nsmallest version available.\n\nNext, let's make a function that checks to see if a column can be downcast from\na float to an integer.\n\ndef float_to_int(ser):\n    try:\n        int_ser = ser.astype(int)\n        if (ser == int_ser).all():\n            return int_ser\n        else:\n            return ser\n    except ValueError:\n        return ser\n\nWe're using the try/except pattern here because if we try to make a column with \nNaN  values into an integer column, it'll throw an error.  If it'd otherwise be\na good candidate for turning into an integer, we should figure a value to impute\nfor those missing values - but that'll be different for every column.  Sometimes\nit'd make sense to make it 0, other times the mean or median of the column, or\nsomething else entirely.\n\nI'd also like to direct your attention to Line 4, which has a very useful Pandas\npattern - if (ser == int_ser).all().  When you do operations on Pandas columns\nlike Equals or Greater Than, you get a new column where the operation was\napplied element-by-element.  If you're trying to set up a conditional, the\ninterpreter doesn't know what to do with an array containing [True, False, True] \n - you have to boil it down to a single value.  So, if you wan to check if two\ncolumns are completely equal, you have to call the .all()  method (which has a\nuseful sibling, any()) to make a conditional that can actually be used to\ncontrol execution.\n\nNext, let's make a function that lets us apply a transformation to multiple\ncolumns based on a condition.  The assign  method is pretty awesome, and it'd be\nfun to not have to leave it (or, if we do, to at least replace it with a\nfunction we can pipe as part of a chain of transformations to the DataFrame as a\nwhole).\n\ndef multi_assign(df, transform_fn, condition):\n    df_to_use = df.copy()\n    \n    return (df_to_use\n        .assign(\n            **{col: transform_fn(df_to_use[col])\n               for col in condition(df_to_use)})\n           )\n\n\nassign  lets us do multiple assignments, so long as we make a dictionary of\ncolumn names and target values and then unpack it.  Really, it'd actually be\neasier to skip the function and go directly to using this syntax, except that\nI'm not aware of a method of accessing a filterable list of the DF's columns\nwhile still \"in\" the chain.  I think future versions of Pandas' syntax will\ninclude this, as I've read they want to support more Method Chaining.\n Personally, I find the reduction in Cognitive Load is worth it, with having a\nlot of little modular lego-piece transformations chained together.\n\nIt also works as a nice foundation for other little helper functions.  So,\nhere's one to turn as many float columns to integers as we can.\n\ndef all_float_to_int(df):\n    df_to_use = df.copy()\n    transform_fn = float_to_int\n    condition = lambda x: list(x\n                    .select_dtypes(include=[\"float\"])\n                    .columns)    \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n\n\nSee the pattern in action!  We decide on a transformation function, we decide on\nwhat conditions we want to apply all these transformations (we could have a\nhundred columns, and who wants to make a note of all that?), and then we pass it\nto the multi-assign  function.\n\n(df\n     .pipe(all_float_to_int)).dtypes\n\n\nstay_float    float64\nto_int          int64\nto_uint         int64\ndtype: object\n\n\nCool!  But we didn't actually decrease the size of our DataFrame - 64 bytes of\ninteger takes up as many bytes as 64 bytes of float, just like how a hundred\npounds of feathers weighs as much as a hundred pounds of bricks.  What we did do\nis make it easier to downcast those columns later.\n\nNext, let's make a function that takes a subset of the columns, and tries to\ndowncast it to the smallest version that it can.  We've got fairly small values\nhere, so it should get some work done.\n\ndef downcast_all(df, target_type, inital_type=None):\n    #Gotta specify floats, unsigned, or integer\n    #If integer, gotta be 'integer', not 'int'\n    #Unsigned should look for Ints\n    if inital_type is None:\n        inital_type = target_type\n    \n    df_to_use = df.copy()\n    \n    transform_fn = lambda x: pd.to_numeric(x, \n                                downcast=target_type)\n    \n    condition = lambda x: list(x\n                    .select_dtypes(include=[inital_type])\n                    .columns) \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n\n\nSame basic pattern as before!  But now we have two arguments - one is the \ntarget_type, which tells us what types to try to downcast to.  By default, this\nwill be the same as the initial_type, with one exception that we'll grab in a\nsecond!\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n).dtypes\n\n\nstay_float    float32\nto_int           int8\nto_uint         int16\ndtype: object\n\n\nAlright, now we're getting somewhere!  Wonder if we can do even better, though?\n That last column has a conspicuous name!  And it has no values lower than 0 -\nmaybe we could save space if we store it as an unsigned integer!  Let's add a\npipe to our chain that'll try to downcast certain integers into unsigneds...\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n     .pipe(downcast_all,  \n           target_type = \"unsigned\", \n           inital_type = \"integer\")\n).dtypes\n\n\nstay_float    float32\nto_int           int8\nto_uint         uint8\ndtype: objec\n\n\nWhat do ya know, we can!\n\nLet's see how much memory we save by doing this.\n\ndf.info(memory_usage='deep')\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float64\nto_int        3 non-null float64\nto_uint       3 non-null float64\ndtypes: float64(3)\nmemory usage: 152.0 bytes\n\n\nvs\n\n(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, \"float\")\n     .pipe(downcast_all, \"integer\")\n     .pipe(downcast_all,  \n           target_type = \"unsigned\", \n           inital_type = \"integer\")\n).info(memory_usage='deep')\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float32\nto_int        3 non-null int8\nto_uint       3 non-null uint8\ndtypes: float32(1), int8(1), uint8(1)\nmemory usage: 98.0 bytes\n\n\n152 down to 98 - we reduced it by more than 1/3rd!","html":"<p>Recently, I had to find a way to reduce the memory footprint of a Pandas DataFrame in order to actually do operations on it.  Here's a trick that came in handy!</p><p>By default, if you read a DataFrame from a file, it'll cast all the numerical columns as the <code>float64</code> type.  This is in keeping with the philosophy behind Pandas and NumPy - by using strict types (instead of normal Python \"duck typing\"), you can do things a lot faster.  The <code>float64</code> is the most flexible numerical type - it can handle fractions, as well as turning missing values into a <code>NaN</code>.  This will let us read it into memory, and then start messing with it.  The downside is that it consumes a lot of memory.</p><p>Now, let's say we want to save memory by manually downcasting our columns into the smallest type that can handle its values?  And let's ALSO say that we want to be really, really lazy and don't want to look at a bunch of numbers by hand.  And let's say we wanna do this via Method Chaining, because of all the advantages outlined here: <a href=\"https://tomaugspurger.github.io/method-chaining\">https://tomaugspurger.github.io/method-chaining</a></p><p>Let's introduce our example DataFrame.  We'll convert all the values to floats manually because that's what the default is when we read from a file.</p><pre><code class=\"language-python\">df = pd.DataFrame({\n    &quot;stay_float&quot;: [0.5, 3.7, 7.5],\n    &quot;to_int&quot;: [-5, 7, 5],\n    &quot;to_uint&quot;: [1, 100, 200]}).astype(float)\n</code></pre>\n<p>First, let's introduce the workhorse of this exercise - Pandas's <code>to_numeric</code> function, and its handy optional argument, <code>downcast</code>.  This will take a numerical type - <code>float</code>, <code>integer</code> (not <code>int</code>), or <code>unsigned</code> - and then downcast it to the smallest version available.</p><p>Next, let's make a function that checks to see if a column can be downcast from a float to an integer.</p><pre><code>def float_to_int(ser):\n    try:\n        int_ser = ser.astype(int)\n        if (ser == int_ser).all():\n            return int_ser\n        else:\n            return ser\n    except ValueError:\n        return ser</code></pre><p>We're using the try/except pattern here because if we try to make a column with <code>NaN</code> values into an integer column, it'll throw an error.  If it'd otherwise be a good candidate for turning into an integer, we should figure a value to impute for those missing values - but that'll be different for every column.  Sometimes it'd make sense to make it 0, other times the mean or median of the column, or something else entirely.</p><p>I'd also like to direct your attention to Line 4, which has a very useful Pandas pattern - <code>if (ser == int_ser).all()</code>.  When you do operations on Pandas columns like Equals or Greater Than, you get a new column where the operation was applied element-by-element.  If you're trying to set up a conditional, the interpreter doesn't know what to do with an array containing <code>[True, False, True]</code> - you have to boil it down to a single value.  So, if you wan to check if two columns are completely equal, you have to call the <code>.all()</code> method (which has a useful sibling, <code>any()</code>) to make a conditional that can actually be used to control execution.</p><p>Next, let's make a function that lets us apply a transformation to multiple columns based on a condition.  The <code>assign</code> method is pretty awesome, and it'd be fun to not have to leave it (or, if we do, to at least replace it with a function we can pipe as part of a chain of transformations to the DataFrame as a whole).</p><pre><code class=\"language-python\">def multi_assign(df, transform_fn, condition):\n    df_to_use = df.copy()\n    \n    return (df_to_use\n        .assign(\n            **{col: transform_fn(df_to_use[col])\n               for col in condition(df_to_use)})\n           )\n</code></pre>\n<p><code>assign</code> lets us do multiple assignments, so long as we make a dictionary of column names and target values and then unpack it.  Really, it'd actually be easier to skip the function and go directly to using this syntax, except that I'm not aware of a method of accessing a filterable list of the DF's columns while still \"in\" the chain.  I think future versions of Pandas' syntax will include this, as I've read they want to support more Method Chaining.  Personally, I find the reduction in Cognitive Load is worth it, with having a lot of little modular lego-piece transformations chained together.  </p><p>It also works as a nice foundation for other little helper functions.  So, here's one to turn as many float columns to integers as we can.</p><pre><code class=\"language-python\">def all_float_to_int(df):\n    df_to_use = df.copy()\n    transform_fn = float_to_int\n    condition = lambda x: list(x\n                    .select_dtypes(include=[&quot;float&quot;])\n                    .columns)    \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n</code></pre>\n<p>See the pattern in action!  We decide on a transformation function, we decide on what conditions we want to apply all these transformations (we could have a hundred columns, and who wants to make a note of all that?), and then we pass it to the <code>multi-assign</code> function.  </p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float64\nto_int          int64\nto_uint         int64\ndtype: object\n</code></pre>\n<p>Cool!  But we didn't actually decrease the size of our DataFrame - 64 bytes of integer takes up as many bytes as 64 bytes of float, just like how a hundred pounds of feathers weighs as much as a hundred pounds of bricks.  What we did do is make it easier to downcast those columns later.</p><p>Next, let's make a function that takes a subset of the columns, and tries to downcast it to the smallest version that it can.  We've got fairly small values here, so it should get some work done.</p><pre><code class=\"language-python\">def downcast_all(df, target_type, inital_type=None):\n    #Gotta specify floats, unsigned, or integer\n    #If integer, gotta be 'integer', not 'int'\n    #Unsigned should look for Ints\n    if inital_type is None:\n        inital_type = target_type\n    \n    df_to_use = df.copy()\n    \n    transform_fn = lambda x: pd.to_numeric(x, \n                                downcast=target_type)\n    \n    condition = lambda x: list(x\n                    .select_dtypes(include=[inital_type])\n                    .columns) \n    \n    return multi_assign(df_to_use, transform_fn, condition)\n</code></pre>\n<p>Same basic pattern as before!  But now we have two arguments - one is the <code>target_type</code>, which tells us what types to try to downcast to.  By default, this will be the same as the <code>initial_type</code>, with one exception that we'll grab in a second!</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float32\nto_int           int8\nto_uint         int16\ndtype: object\n</code></pre>\n<p>Alright, now we're getting somewhere!  Wonder if we can do even better, though?  That last column has a conspicuous name!  And it has no values lower than 0 - maybe we could save space if we store it as an unsigned integer!  Let's add a pipe to our chain that'll try to downcast certain integers into unsigneds...</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n     .pipe(downcast_all,  \n           target_type = &quot;unsigned&quot;, \n           inital_type = &quot;integer&quot;)\n).dtypes\n</code></pre>\n<pre><code class=\"language-bash\">stay_float    float32\nto_int           int8\nto_uint         uint8\ndtype: objec\n</code></pre>\n<p>What do ya know, we can!</p><p>Let's see how much memory we save by doing this.</p><pre><code class=\"language-python\">df.info(memory_usage='deep')\n</code></pre>\n<pre><code class=\"language-bash\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float64\nto_int        3 non-null float64\nto_uint       3 non-null float64\ndtypes: float64(3)\nmemory usage: 152.0 bytes\n</code></pre>\n<p>vs</p><pre><code class=\"language-python\">(df\n     .pipe(all_float_to_int)\n     .pipe(downcast_all, &quot;float&quot;)\n     .pipe(downcast_all, &quot;integer&quot;)\n     .pipe(downcast_all,  \n           target_type = &quot;unsigned&quot;, \n           inital_type = &quot;integer&quot;)\n).info(memory_usage='deep')\n</code></pre>\n<pre><code class=\"language-bash\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nstay_float    3 non-null float32\nto_int        3 non-null int8\nto_uint       3 non-null uint8\ndtypes: float32(1), int8(1), uint8(1)\nmemory usage: 98.0 bytes\n</code></pre>\n<p>152 down to 98 - we reduced it by more than 1/3rd!</p>","url":"https://hackersandslackers.com/downcast-numerical-columns-python-pandas/","uuid":"58bbb902-99bb-404d-8a3c-232d56b6e776","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c4e57144b23df2da7332b80"}},{"node":{"id":"Ghost__Post__5c47b2bcf850c0618c1a59a0","title":"From CSVs to Tables: Infer Data Types From Raw Spreadsheets","slug":"infer-datatypes-from-csvs-to-create","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/01/schema@2x.jpg","excerpt":"The quest to never explicitly set a table schema ever again.","custom_excerpt":"The quest to never explicitly set a table schema ever again.","created_at_pretty":"23 January, 2019","published_at_pretty":"23 January, 2019","updated_at_pretty":"19 February, 2019","created_at":"2019-01-22T19:18:04.000-05:00","published_at":"2019-01-23T07:00:00.000-05:00","updated_at":"2019-02-19T04:02:36.000-05:00","meta_title":"Infer SQL Data Types From Raw Spreadsheets | Hackers and Slackers ","meta_description":"We join forces with Pandas, SQLAlchemy, PyTorch, Databricks, and tableschema with one goal in mind: to never explicitly create a table schema ever again.","og_description":"The quest to never explicitly set a table schema ever again.","og_image":"https://hackersandslackers.com/content/images/2019/01/schema@2x.jpg","og_title":"From CSVs to Tables: Infer Schema Data Types From Raw Spreadsheets","twitter_description":"The quest to never explicitly set a table schema ever again.","twitter_image":"https://hackersandslackers.com/content/images/2019/01/schema@2x.jpg","twitter_title":"From CSVs to Tables: Infer Schema Data Types From Raw Spreadsheets","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Big Data","slug":"bigdata","description":"Work with unstructured data across file types and schemas. Tools such as data warehouses, Hadoop, Spark, BigQuery, etc.","feature_image":null,"meta_description":"Work with massive amounts of unstandardized data across file types and schemas. Includes working with data warehouses, Hadoop, Spark, BigQuery, etc.","meta_title":"Big Data | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Big Data","slug":"bigdata","description":"Work with unstructured data across file types and schemas. Tools such as data warehouses, Hadoop, Spark, BigQuery, etc.","feature_image":null,"meta_description":"Work with massive amounts of unstandardized data across file types and schemas. Includes working with data warehouses, Hadoop, Spark, BigQuery, etc.","meta_title":"Big Data | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"Apache","slug":"apache","description":"Apache’s suite of big data products: Hadoop, Spark, Kafka, and so forth.","feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Data Science","slug":"datascience","description":"Watch as we attempt to maintain a delicate harmony of math, engineering, and intuition to solve larger-than-life problems.","feature_image":null,"meta_description":"Watch as we attempt to maintain a delicate harmony of math, engineering, and intuition to solve larger-than-life problems.","meta_title":"Data Science | Hackers and Slackers","visibility":"public"}],"plaintext":"Back in August of last year (roughly 8 months ago), I hunched over my desk at 4\nam desperate to fire off a post before boarding a flight the next morning. The\narticle was titled Creating Database Schemas: a Job for Robots, or Perhaps\nPandas. It was my intent at the time to solve a common annoyance: creating\ndatabase tables out of raw data, without the obnoxious process of explicitly\nsetting each column's datatype. I had a few leads that led me to believe I had\nthe answer... boy was I wrong.\n\nThe task seems somewhat reasonable from the surface. Surely we can spot columns\nwhere the data is always in integers, or match the expected format of a date,\nright? If anything, we'll fall back to text  or varchar  and call it a day.\nHell, even MongoDB's Compass does a great job of this by merely uploading a\nCSV... this has got to be some trivial task handled by third-party libraries by\nnow.\n\nFor one reason or another, searching for a solution to this problem almost\nalways comes up empty. Software developers probably have little need for\ndynamically generated tables if their applications run solely on self-defined\nmodels. Full-time Data Scientists have access to plenty of expensive tools which\nseem to claim this functionality, yet it all seems so... inaccessible.\n\nIs This NOT a Job For Pandas?\nFrom my experience, no. Pandas does offer hope but doesn't seem to get the job\ndone quite right. Let's start with a dataset so you can see what I mean. Here's\na bunch of fake identities I'll be using to mimic the outcome I experienced when\nworking with real data:\n\nidinitiatedhiredateemailfirstnamelastnametitledepartmentlocationcountrytype\n1000354352015-12-11T09:16:20.722-08:003/22/67GretchenRMorrow@jourrapide.com\nGretchenMorrowPower plant operatorPhysical ProductBritling CafeteriasUnited\nKingdomEmployee1000564352015-12-15T10:11:24.604-08:006/22/99\nElizabethLSnow@armyspy.comElizabethSnowOxygen therapistPhysical ProductGrade A\nInvestmentUnited States of AmericaEmployee1000379552015-12-16T14:31:32.765-08:00\n5/31/74AlbertMPeterson@einrot.comAlbertPetersonPsychologistPhysical ProductGrass\nRoots Yard ServicesUnited States of AmericaEmployee100035435\n2016-01-20T11:15:47.249-08:009/9/69JohnMLynch@dayrep.comJohnLynchEnvironmental\nhydrologistPhysical ProductWaccamaw's HomeplaceUnited States of AmericaEmployee\n1000576572016-01-21T12:45:38.261-08:004/9/83TheresaJCahoon@teleworm.usTheresa\nCahoonPersonal chefPhysical ProductCala FoodsUnited States of AmericaEmployee\n1000567472016-02-01T11:25:39.317-08:006/26/98KennethHPayne@dayrep.comKenneth\nPayneCentral office operatorFrontlineMagna ConsultingUnited States of America\nEmployee1000354352016-02-01T11:28:11.953-08:004/16/82LeifTSpeights@fleckens.hu\nLeifSpeightsStaff development directorFrontlineRivera Property MaintenanceUnited\nStates of AmericaEmployee1000354352016-02-01T12:21:01.756-08:008/6/80\nJamesSRobinson@teleworm.usJamesRobinsonScheduling clerkFrontlineDiscount\nFurniture ShowcaseUnited States of AmericaEmployee100074688\n2016-02-01T13:29:19.147-08:0012/14/74AnnaDMoberly@jourrapide.comAnnaMoberly\nPlaywrightPhysical ProductThe WizUnited States of AmericaEmployee100665778\n2016-02-04T14:40:05.223-08:009/13/66MarjorieBCrawford@armyspy.comMarjorie\nCrawfordCourt, municipal, and license clerkPhysical ProductThe Serendipity Dip\nUnited KingdomEmployee1008768762016-02-24T12:39:25.872-08:0012/19/67\nLyleCHackett@fleckens.huLyleHackettAirframe mechanicPhysical ProductInfinity\nInvestment PlanUnited States of AmericaEmployee100658565\n2016-02-29T15:52:12.933-08:0011/17/83MaryJDensmore@jourrapide.comMaryDensmore\nEmployer relations representativeFrontlineOne-Up RealtorsUnited States of\nAmericaEmployee1007665472016-03-01T12:32:53.357-08:0010/1/87\nCindyRDiaz@armyspy.comCindyDiazStudent affairs administratorPhysical ProductMr.\nAG'sUnited States of AmericaEmployee1000456772016-03-02T12:07:44.264-08:00\n8/16/65AndreaTLigon@einrot.comAndreaLigonRailroad engineerCentral GrowthRobinson\nFurnitureUnited States of AmericaEmployeeThere are some juicy datatypes in\nthere: integers, timestamps, dates, strings.... and those are only the first\nfour columns! Let's load this thing into a DataFrame and see what information we\ncan get that way:\n\nimport pandas as pd\n\ncsv = 'data/fake.csv'\n\nworkers_df = pd.read_csv(csv, header=0, encoding='utf-8')\nmeta = workers_df.info(verbose=True)\nprint(meta)\n\n\nUsing Pandas' info()  should do the trick! This returns a list of columns and\ntheir data types:\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 22 entries, 0 to 21\nData columns (total 11 columns):\nid            14 non-null float64\ninitiated     14 non-null object\nhiredate      14 non-null object\nemail         14 non-null object\nfirstname     14 non-null object\nlastname      14 non-null object\ntitle         14 non-null object\ndepartment    14 non-null object\nlocation      14 non-null object\ncountry       14 non-null object\ntype          14 non-null object\ndtypes: float64(1), object(10)\nmemory usage: 2.0+ KB\nNone\n\n\n...Or not. What is this garbage? Only one of our 11 columns identified a data\ntype, and it was incorrectly listed as a float! Okay, so maybe Pandas doesn't\nhave a secret one-liner for this. So who does?\n\nWhat about PySpark?\nIt's always been a matter of time before we'd turn to Apache's family of aged\ndata science products. Hadoop, Spark, Kafka... all of them have a particular\nmusty stench about them that tastes like \"I feel like I should be writing in\nJava right now.\" Heads up: they do  want you to write in Java. Misery loves\ncompany.\n\nNonetheless, PySpark  does  support reading data as DataFrames in Python, and\nalso comes with the elusive ability to infer schemas. Installing Hadoop and\nSpark locally still kind of sucks for solving this one particular problem. Cue \nDatabricks [https://databricks.com/]: a company that spun off from the Apache\nteam way back in the day, and offers free cloud notebooks integrated with- you\nguessed it: Spark.\n\nWith Databricks, we can upload our CSV and load it into a DataFrame by spinning\nup a free notebook. The source looks something like this:\n\n# File location and type\nfile_location = \"/FileStore/tables/fake.csv\"\nfile_type = \"csv\"\n\n# CSV options\ninfer_schema = \"true\"\nfirst_row_is_header = \"true\"\ndelimiter = \",\"\n\ndf = spark.read.format(file_type) \\\n  .option(\"inferSchema\", infer_schema) \\\n  .option(\"header\", first_row_is_header) \\\n  .option(\"sep\", delimiter) \\\n  .load(file_location)\n\ndisplay(df)\n\n\nLet's see out the output looks:\n\ndf:pyspark.sql.dataframe.DataFrame\nid:integer\ninitiated:timestamp\nhiredate:string\nemail:string\nfirstname:string\nlastname:string\ntitle:string\ndepartment:string\nlocation:string\ncountry:string\ntype:string\n\n\nNot bad! We correctly 'upgraded' our ID from float to integer, and we managed to\nget the timestamp correct also. With a bit of messing around, we could probably\nhave even gotten the date correct too, given that we stated the format\nbeforehand.\n\nA look at the Databricks Notebook interface.And Yet, This Still Kind of Sucks\nEven though we can solve our problem in a notebook, we still haven't solved the\nuse case: I want a drop-in solution to create tables out of CSVs... whenever I\nwant! I want to accomplish this while writing any app, at the drop of a hat\nwithout warning. I don't want to install Hadoop and have Java errors coming back\nat me through my terminal. Don't EVER  let me see Java in my terminal. UGH:\n\npy4j.protocol.Py4JJavaError: An error occurred while calling o43.count.\n: java.lang.IllegalArgumentException: Unsupported class file major version 55\n        at org.apache.xbean.asm6.ClassReader.<init>(ClassReader.java:166)\n        at org.apache.xbean.asm6.ClassReader.<init>(ClassReader.java:148)\n        at org.apache.xbean.asm6.ClassReader.<init>(ClassReader.java:136)\n        at org.apache.xbean.asm6.ClassReader.<init>(ClassReader.java:237)\n        at org.apache.spark.util.ClosureCleaner$.getClassReader(ClosureCleaner.scala:49)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3$$anonfun$visitMethodInsn$2.apply(ClosureCleaner.scala:517)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3$$anonfun$visitMethodInsn$2.apply(ClosureCleaner.scala:500)\n        at scala.collection.TraversableLike$WithFilter$$anonfun$foreach$1.apply(TraversableLike.scala:733)\n        at scala.collection.mutable.HashMap$$anon$1$$anonfun$foreach$2.apply(HashMap.scala:134)\n        at scala.collection.mutable.HashMap$$anon$1$$anonfun$foreach$2.apply(HashMap.scala:134)\n\n        at scala.collection.mutable.HashTable$class.foreachEntry(HashTable.scala:236)\n        at scala.collection.mutable.HashMap.foreachEntry(HashMap.scala:40)\n        at scala.collection.mutable.HashMap$$anon$1.foreach(HashMap.scala:134)\n        at scala.collection.TraversableLike$WithFilter.foreach(TraversableLike.scala:732)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3.visitMethodInsn(ClosureCleaner.scala:500)\n        at org.apache.xbean.asm6.ClassReader.readCode(ClassReader.java:2175)\n        at org.apache.xbean.asm6.ClassReader.readMethod(ClassReader.java:1238)\n        at org.apache.xbean.asm6.ClassReader.accept(ClassReader.java:631)\n\n\nPython's \"tableschema\" Library\nThankfully, there's at least one other person out there who has shared this\ndesire. That brings us to tableschema\n[https://github.com/frictionlessdata/tableschema-py], a\nnot-quite-perfect-but-perhaps-good-enough library to gunsling data like some\nkind of wild data cowboy. Let's give it a go:\n\nimport csv\nfrom tableschema import Table\n\n\ndata = 'data/fake.csv'\nschema = infer(data, limit=500, headers=1, confidence=0.85)\nprint(schema)\n\n\nIf our dataset is particularly large, we can use the limit  attribute to limit\nthe sample size to the first X  number of rows. Another nice feature is the \nconfidence  attribute: a 0-1 ratio for allowing casting errors during the\ninference. Here's what comes back:\n\n{\n  \"fields\": [{\n    \"name\": \"id\",\n    \"type\": \"integer\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"initiated\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"hiredate\",\n    \"type\": \"date\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"email\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"firstname\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"lastname\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"title\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"department\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"location\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"country\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }, {\n    \"name\": \"type\",\n    \"type\": \"string\",\n    \"format\": \"default\"\n  }],\n  \"missingValues\": [\"\"]\n}\n\n\nHey, that's good enough for me! Now let's automate the shit out this.\n\nCreating a Table in SQLAlchemy With Our New Schema\nI'm about to throw a bunch in your face right here. Here's a monster of a class:\n\nfrom sqlalchemy import create_engine\nimport config\nimport pandas as pd\nimport psycopg2\nfrom tableschema import Table, infer, Schema\nfrom functions.recursivejson import extract_values\nfrom sqlalchemy.types import Integer, Text, Date\n\n\nclass CreateTablesFromCSVs:\n    \"\"\"Infer a table schema from a CSV.\"\"\"\n\n    __uri = config.PG_URI\n    __engine = create_engine(__uri, convert_unicode=True, echo=True)\n    __data = 'data/fake.csv'\n    \n    @classmethod\n    def get_data(cls):\n        \"\"\"Pull latest data.\"\"\"\n        test_df = pd.read_csv(cls.__data, header=0, encoding='utf-8')\n        return test_df\n\n    @classmethod\n    def get_schema_from_csv(cls, csv):\n        \"\"\"Infers schema from CSV.\"\"\"\n        table = Table(csv)\n        table.infer(limit=500, confidence=0.55)\n        schema = table.schema.descriptor\n        names = cls.get_column_names(schema, 'name')\n        datatypes = cls.get_column_datatypes(schema, 'type')\n        schema_dict = dict(zip(names, datatypes))\n        return schema_dict\n\n    @classmethod\n    def get_column_names(cls, schema, key):\n        \"\"\"Get names of columns.\"\"\"\n        names = extract_values(schema, key)\n        return names\n\n    @classmethod\n    def get_column_datatypes(cls, schema, key):\n        \"\"\"Convert schema to recognizable by SQLAlchemy.\"\"\"\n        values = extract_values(schema, key)\n        for i, value in enumerate(values):\n            if value == 'integer':\n                values[i] = Integer\n            elif value == 'string':\n                values[i] = Text\n            elif value == 'date':\n                values[i] = Date\n        return values\n        \n    @classmethod\n    def create_new_table(cls, data, schema):\n          \"\"\"Create new table from CSV and generated schema.\"\"\"\n          workday_table.to_sql('faketable',\n                               con=cls.__engine,\n                               schema='testschema',\n                               if_exists='replace',\n                               chunksize=300,\n                               dtype=schema)\n                                 \ndata = CreateTablesFromCSVs.get_schema_from_csv()\nschema = CreateTablesFromCSVs.get_schema_from_csv(data)\nCreateTablesFromCSVs.create_new_table(data, schema)\n\n\nThe first thing worth mentioning is I'm importing a function\n[https://gist.github.com/toddbirchard/b6f86f03f6cf4fc9492ad4349ee7ff8b]  from my\npersonal secret library to extract values from JSON objects. I've spoken about\nit before\n[https://hackersandslackers.com/extract-data-from-complex-json-python/]. \n\nLet's break down this class:\n\n * get_data()  reads our CSV into a Pandas DataFrame.\n * get_schema_from_csv()  kicks off building a Schema that SQLAlchemy can use to\n   build a table.\n * get_column_names()  simply pulls column names as half our schema.\n * get_column_datatypes()  manually replaces the datatype names we received from\n    tableschema  and replaces them with SQLAlchemy datatypes.\n * create_new_table  Uses a beautiful marriage between Pandas and SQLAlchemy to\n   create a table in our database with the correct datatypes mapped.\n\nPromising Potential, Room to Grow\nWhile tableschema  works some of the time, it isn't perfect. The base of what we\naccomplish still stands: we now have a reliable formula for how we would create\nschemas on the fly if we trust our schemas to be accurate.\n\nJust wait until next time when we introduce Google BigQuery  into the mix.","html":"<p>Back in August of last year (roughly 8 months ago), I hunched over my desk at 4 am desperate to fire off a post before boarding a flight the next morning. The article was titled <strong><em>Creating Database Schemas: a Job for Robots, or Perhaps Pandas</em></strong>. It was my intent at the time to solve a common annoyance: creating database tables out of raw data, without the obnoxious process of explicitly setting each column's datatype. I had a few leads that led me to believe I had the answer... boy was I wrong.</p><p>The task seems somewhat reasonable from the surface. Surely we can spot columns where the data is always in integers, or match the expected format of a date, right? If anything, we'll fall back to <strong>text</strong> or <strong>varchar</strong> and call it a day. Hell, even MongoDB's Compass does a great job of this by merely uploading a CSV... this has got to be some trivial task handled by third-party libraries by now.</p><p>For one reason or another, searching for a solution to this problem almost always comes up empty. Software developers probably have little need for dynamically generated tables if their applications run solely on self-defined models. Full-time Data Scientists have access to plenty of expensive tools which seem to claim this functionality, yet it all seems so... inaccessible.</p><h2 id=\"is-this-not-a-job-for-pandas\">Is This NOT a Job For Pandas?</h2><p>From my experience, no. Pandas does offer hope but doesn't seem to get the job done quite right. Let's start with a dataset so you can see what I mean. Here's a bunch of fake identities I'll be using to mimic the outcome I experienced when working with real data:</p>\n<div class=\"row tableContainer\">\n<table border=\"1\" class=\"table table-striped table-bordered table-hover table-condensed\">\n<thead><tr><th title=\"Field #1\">id</th>\n<th title=\"Field #2\">initiated</th>\n<th title=\"Field #3\">hiredate</th>\n<th title=\"Field #4\">email</th>\n<th title=\"Field #5\">firstname</th>\n<th title=\"Field #6\">lastname</th>\n<th title=\"Field #7\">title</th>\n<th title=\"Field #8\">department</th>\n<th title=\"Field #9\">location</th>\n<th title=\"Field #10\">country</th>\n<th title=\"Field #11\">type</th>\n</tr></thead>\n<tbody><tr><td align=\"right\">100035435</td>\n<td>2015-12-11T09:16:20.722-08:00</td>\n<td>3/22/67</td>\n<td>GretchenRMorrow@jourrapide.com</td>\n<td>Gretchen</td>\n<td>Morrow</td>\n<td>Power plant operator</td>\n<td>Physical Product</td>\n<td>Britling Cafeterias</td>\n<td>United Kingdom</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100056435</td>\n<td>2015-12-15T10:11:24.604-08:00</td>\n<td>6/22/99</td>\n<td>ElizabethLSnow@armyspy.com</td>\n<td>Elizabeth</td>\n<td>Snow</td>\n<td>Oxygen therapist</td>\n<td>Physical Product</td>\n<td>Grade A Investment</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100037955</td>\n<td>2015-12-16T14:31:32.765-08:00</td>\n<td>5/31/74</td>\n<td>AlbertMPeterson@einrot.com</td>\n<td>Albert</td>\n<td>Peterson</td>\n<td>Psychologist</td>\n<td>Physical Product</td>\n<td>Grass Roots Yard Services</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100035435</td>\n<td>2016-01-20T11:15:47.249-08:00</td>\n<td>9/9/69</td>\n<td>JohnMLynch@dayrep.com</td>\n<td>John</td>\n<td>Lynch</td>\n<td>Environmental hydrologist</td>\n<td>Physical Product</td>\n<td>Waccamaw&#39;s Homeplace</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100057657</td>\n<td>2016-01-21T12:45:38.261-08:00</td>\n<td>4/9/83</td>\n<td>TheresaJCahoon@teleworm.us</td>\n<td>Theresa</td>\n<td>Cahoon</td>\n<td>Personal chef</td>\n<td>Physical Product</td>\n<td>Cala Foods</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100056747</td>\n<td>2016-02-01T11:25:39.317-08:00</td>\n<td>6/26/98</td>\n<td>KennethHPayne@dayrep.com</td>\n<td>Kenneth</td>\n<td>Payne</td>\n<td>Central office operator</td>\n<td>Frontline</td>\n<td>Magna Consulting</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100035435</td>\n<td>2016-02-01T11:28:11.953-08:00</td>\n<td>4/16/82</td>\n<td>LeifTSpeights@fleckens.hu</td>\n<td>Leif</td>\n<td>Speights</td>\n<td>Staff development director</td>\n<td>Frontline</td>\n<td>Rivera Property Maintenance</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100035435</td>\n<td>2016-02-01T12:21:01.756-08:00</td>\n<td>8/6/80</td>\n<td>JamesSRobinson@teleworm.us</td>\n<td>James</td>\n<td>Robinson</td>\n<td>Scheduling clerk</td>\n<td>Frontline</td>\n<td>Discount Furniture Showcase</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100074688</td>\n<td>2016-02-01T13:29:19.147-08:00</td>\n<td>12/14/74</td>\n<td>AnnaDMoberly@jourrapide.com</td>\n<td>Anna</td>\n<td>Moberly</td>\n<td>Playwright</td>\n<td>Physical Product</td>\n<td>The Wiz</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100665778</td>\n<td>2016-02-04T14:40:05.223-08:00</td>\n<td>9/13/66</td>\n<td>MarjorieBCrawford@armyspy.com</td>\n<td>Marjorie</td>\n<td>Crawford</td>\n<td>Court, municipal, and license clerk</td>\n<td>Physical Product</td>\n<td>The Serendipity Dip</td>\n<td>United Kingdom</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100876876</td>\n<td>2016-02-24T12:39:25.872-08:00</td>\n<td>12/19/67</td>\n<td>LyleCHackett@fleckens.hu</td>\n<td>Lyle</td>\n<td>Hackett</td>\n<td>Airframe mechanic</td>\n<td>Physical Product</td>\n<td>Infinity Investment Plan</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100658565</td>\n<td>2016-02-29T15:52:12.933-08:00</td>\n<td>11/17/83</td>\n<td>MaryJDensmore@jourrapide.com</td>\n<td>Mary</td>\n<td>Densmore</td>\n<td>Employer relations representative</td>\n<td>Frontline</td>\n<td>One-Up Realtors</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100766547</td>\n<td>2016-03-01T12:32:53.357-08:00</td>\n<td>10/1/87</td>\n<td>CindyRDiaz@armyspy.com</td>\n<td>Cindy</td>\n<td>Diaz</td>\n<td>Student affairs administrator</td>\n<td>Physical Product</td>\n<td>Mr. AG&#39;s</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n<tr><td align=\"right\">100045677</td>\n<td>2016-03-02T12:07:44.264-08:00</td>\n<td>8/16/65</td>\n<td>AndreaTLigon@einrot.com</td>\n<td>Andrea</td>\n<td>Ligon</td>\n<td>Railroad engineer</td>\n<td>Central Growth</td>\n<td>Robinson Furniture</td>\n<td>United States of America</td>\n<td>Employee</td>\n</tr>\n</tbody></table>\n</div><p>There are some juicy datatypes in there: <strong>integers</strong>, <strong>timestamps</strong>, <strong>dates</strong>, <strong>strings</strong>.... and those are only the first four columns! Let's load this thing into a DataFrame and see what information we can get that way:</p><pre><code class=\"language-python\">import pandas as pd\n\ncsv = 'data/fake.csv'\n\nworkers_df = pd.read_csv(csv, header=0, encoding='utf-8')\nmeta = workers_df.info(verbose=True)\nprint(meta)\n</code></pre>\n<p>Using Pandas' <code>info()</code> should do the trick! This returns a list of columns and their data types:</p><pre><code class=\"language-bash\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 22 entries, 0 to 21\nData columns (total 11 columns):\nid            14 non-null float64\ninitiated     14 non-null object\nhiredate      14 non-null object\nemail         14 non-null object\nfirstname     14 non-null object\nlastname      14 non-null object\ntitle         14 non-null object\ndepartment    14 non-null object\nlocation      14 non-null object\ncountry       14 non-null object\ntype          14 non-null object\ndtypes: float64(1), object(10)\nmemory usage: 2.0+ KB\nNone\n</code></pre>\n<p>...Or not. What is this garbage? Only one of our 11 columns identified a data type, and it was incorrectly listed as a <strong>float</strong>! Okay, so maybe Pandas doesn't have a secret one-liner for this. So who does?</p><h2 id=\"what-about-pyspark\">What about PySpark?</h2><p>It's always been a matter of time before we'd turn to Apache's family of aged data science products. Hadoop, Spark, Kafka... all of them have a particular musty stench about them that tastes like \"I feel like I should be writing in Java right now.\" Heads up: they <em>do</em> want you to write in Java. Misery loves company.</p><p>Nonetheless, <strong>PySpark</strong> <em>does</em> support reading data as DataFrames in Python, and also comes with the elusive ability to infer schemas. Installing Hadoop and Spark locally still kind of sucks for solving this one particular problem. Cue <strong><a href=\"https://databricks.com/\">Databricks</a></strong>: a company that spun off from the Apache team way back in the day, and offers free cloud notebooks integrated with- you guessed it: Spark.</p><p>With Databricks, we can upload our CSV and load it into a DataFrame by spinning up a free notebook. The source looks something like this:</p><pre><code class=\"language-python\"># File location and type\nfile_location = &quot;/FileStore/tables/fake.csv&quot;\nfile_type = &quot;csv&quot;\n\n# CSV options\ninfer_schema = &quot;true&quot;\nfirst_row_is_header = &quot;true&quot;\ndelimiter = &quot;,&quot;\n\ndf = spark.read.format(file_type) \\\n  .option(&quot;inferSchema&quot;, infer_schema) \\\n  .option(&quot;header&quot;, first_row_is_header) \\\n  .option(&quot;sep&quot;, delimiter) \\\n  .load(file_location)\n\ndisplay(df)\n</code></pre>\n<p>Let's see out the output looks:</p><pre><code class=\"language-bash\">df:pyspark.sql.dataframe.DataFrame\nid:integer\ninitiated:timestamp\nhiredate:string\nemail:string\nfirstname:string\nlastname:string\ntitle:string\ndepartment:string\nlocation:string\ncountry:string\ntype:string\n</code></pre>\n<p>Not bad! We correctly 'upgraded' our ID from float to integer, and we managed to get the timestamp correct also. With a bit of messing around, we could probably have even gotten the date correct too, given that we stated the format beforehand.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2019-01-22-at-8.41.30-PM.png\" class=\"kg-image\"><figcaption>A look at the Databricks Notebook interface.</figcaption></figure><h3 id=\"and-yet-this-still-kind-of-sucks\">And Yet, This Still Kind of Sucks</h3><p>Even though we can solve our problem in a notebook, we still haven't solved the use case: I want a drop-in solution to create tables out of CSVs... whenever I want! I want to accomplish this while writing any app, at the drop of a hat without warning. I don't want to install Hadoop and have Java errors coming back at me through my terminal. Don't <em>EVER</em> let me see Java in my terminal. UGH:</p><pre><code class=\"language-bash\">py4j.protocol.Py4JJavaError: An error occurred while calling o43.count.\n: java.lang.IllegalArgumentException: Unsupported class file major version 55\n        at org.apache.xbean.asm6.ClassReader.&lt;init&gt;(ClassReader.java:166)\n        at org.apache.xbean.asm6.ClassReader.&lt;init&gt;(ClassReader.java:148)\n        at org.apache.xbean.asm6.ClassReader.&lt;init&gt;(ClassReader.java:136)\n        at org.apache.xbean.asm6.ClassReader.&lt;init&gt;(ClassReader.java:237)\n        at org.apache.spark.util.ClosureCleaner$.getClassReader(ClosureCleaner.scala:49)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3$$anonfun$visitMethodInsn$2.apply(ClosureCleaner.scala:517)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3$$anonfun$visitMethodInsn$2.apply(ClosureCleaner.scala:500)\n        at scala.collection.TraversableLike$WithFilter$$anonfun$foreach$1.apply(TraversableLike.scala:733)\n        at scala.collection.mutable.HashMap$$anon$1$$anonfun$foreach$2.apply(HashMap.scala:134)\n        at scala.collection.mutable.HashMap$$anon$1$$anonfun$foreach$2.apply(HashMap.scala:134)\n\n        at scala.collection.mutable.HashTable$class.foreachEntry(HashTable.scala:236)\n        at scala.collection.mutable.HashMap.foreachEntry(HashMap.scala:40)\n        at scala.collection.mutable.HashMap$$anon$1.foreach(HashMap.scala:134)\n        at scala.collection.TraversableLike$WithFilter.foreach(TraversableLike.scala:732)\n        at org.apache.spark.util.FieldAccessFinder$$anon$3.visitMethodInsn(ClosureCleaner.scala:500)\n        at org.apache.xbean.asm6.ClassReader.readCode(ClassReader.java:2175)\n        at org.apache.xbean.asm6.ClassReader.readMethod(ClassReader.java:1238)\n        at org.apache.xbean.asm6.ClassReader.accept(ClassReader.java:631)\n</code></pre>\n<h2 id=\"python-s-tableschema-library\">Python's \"tableschema\" Library</h2><p>Thankfully, there's at least one other person out there who has shared this desire. That brings us to <a href=\"https://github.com/frictionlessdata/tableschema-py\">tableschema</a>, a not-quite-perfect-but-perhaps-good-enough library to gunsling data like some kind of wild data cowboy. Let's give it a go:</p><pre><code class=\"language-python\">import csv\nfrom tableschema import Table\n\n\ndata = 'data/fake.csv'\nschema = infer(data, limit=500, headers=1, confidence=0.85)\nprint(schema)\n</code></pre>\n<p>If our dataset is particularly large, we can use the <code>limit</code> attribute to limit the sample size to the first <strong>X</strong> number of rows. Another nice feature is the <code>confidence</code> attribute: a 0-1 ratio for allowing casting errors during the inference. Here's what comes back:</p><pre><code class=\"language-json\">{\n  &quot;fields&quot;: [{\n    &quot;name&quot;: &quot;id&quot;,\n    &quot;type&quot;: &quot;integer&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;initiated&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;hiredate&quot;,\n    &quot;type&quot;: &quot;date&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;email&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;firstname&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;lastname&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;title&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;department&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;location&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;country&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }, {\n    &quot;name&quot;: &quot;type&quot;,\n    &quot;type&quot;: &quot;string&quot;,\n    &quot;format&quot;: &quot;default&quot;\n  }],\n  &quot;missingValues&quot;: [&quot;&quot;]\n}\n</code></pre>\n<p>Hey, that's good enough for me! Now let's automate the shit out this.</p><h2 id=\"creating-a-table-in-sqlalchemy-with-our-new-schema\">Creating a Table in SQLAlchemy With Our New Schema</h2><p>I'm about to throw a bunch in your face right here. Here's a monster of a class:</p><pre><code class=\"language-python\">from sqlalchemy import create_engine\nimport config\nimport pandas as pd\nimport psycopg2\nfrom tableschema import Table, infer, Schema\nfrom functions.recursivejson import extract_values\nfrom sqlalchemy.types import Integer, Text, Date\n\n\nclass CreateTablesFromCSVs:\n    &quot;&quot;&quot;Infer a table schema from a CSV.&quot;&quot;&quot;\n\n    __uri = config.PG_URI\n    __engine = create_engine(__uri, convert_unicode=True, echo=True)\n    __data = 'data/fake.csv'\n    \n    @classmethod\n    def get_data(cls):\n        &quot;&quot;&quot;Pull latest data.&quot;&quot;&quot;\n        test_df = pd.read_csv(cls.__data, header=0, encoding='utf-8')\n        return test_df\n\n    @classmethod\n    def get_schema_from_csv(cls, csv):\n        &quot;&quot;&quot;Infers schema from CSV.&quot;&quot;&quot;\n        table = Table(csv)\n        table.infer(limit=500, confidence=0.55)\n        schema = table.schema.descriptor\n        names = cls.get_column_names(schema, 'name')\n        datatypes = cls.get_column_datatypes(schema, 'type')\n        schema_dict = dict(zip(names, datatypes))\n        return schema_dict\n\n    @classmethod\n    def get_column_names(cls, schema, key):\n        &quot;&quot;&quot;Get names of columns.&quot;&quot;&quot;\n        names = extract_values(schema, key)\n        return names\n\n    @classmethod\n    def get_column_datatypes(cls, schema, key):\n        &quot;&quot;&quot;Convert schema to recognizable by SQLAlchemy.&quot;&quot;&quot;\n        values = extract_values(schema, key)\n        for i, value in enumerate(values):\n            if value == 'integer':\n                values[i] = Integer\n            elif value == 'string':\n                values[i] = Text\n            elif value == 'date':\n                values[i] = Date\n        return values\n        \n    @classmethod\n    def create_new_table(cls, data, schema):\n          &quot;&quot;&quot;Create new table from CSV and generated schema.&quot;&quot;&quot;\n          workday_table.to_sql('faketable',\n                               con=cls.__engine,\n                               schema='testschema',\n                               if_exists='replace',\n                               chunksize=300,\n                               dtype=schema)\n                                 \ndata = CreateTablesFromCSVs.get_schema_from_csv()\nschema = CreateTablesFromCSVs.get_schema_from_csv(data)\nCreateTablesFromCSVs.create_new_table(data, schema)\n</code></pre>\n<p>The first thing worth mentioning is I'm <a href=\"https://gist.github.com/toddbirchard/b6f86f03f6cf4fc9492ad4349ee7ff8b\">importing a function</a> from my personal secret library to extract values from JSON objects. I've <a href=\"https://hackersandslackers.com/extract-data-from-complex-json-python/\">spoken about it before</a>. </p><p>Let's break down this class:</p><ul><li><code>get_data()</code> reads our CSV into a Pandas DataFrame.</li><li><code>get_schema_from_csv()</code> kicks off building a Schema that SQLAlchemy can use to build a table.</li><li><code>get_column_names()</code> simply pulls column names as half our schema.</li><li><code>get_column_datatypes()</code> manually replaces the datatype names we received from <strong>tableschema</strong> and replaces them with SQLAlchemy datatypes.</li><li><code>create_new_table</code> Uses a beautiful marriage between Pandas and SQLAlchemy to create a table in our database with the correct datatypes mapped.</li></ul><h3 id=\"promising-potential-room-to-grow\">Promising Potential, Room to Grow</h3><p>While <strong>tableschema</strong> works some of the time, it isn't perfect. The base of what we accomplish still stands: we now have a reliable formula for how we would create schemas on the fly if we trust our schemas to be accurate.</p><p>Just wait until next time when we introduce <strong>Google BigQuery</strong> into the mix.</p>","url":"https://hackersandslackers.com/infer-datatypes-from-csvs-to-create/","uuid":"addbd45d-f9a5-4beb-8b01-2c835b442750","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c47b2bcf850c0618c1a59a0"}},{"node":{"id":"Ghost__Post__5c3d0b441719dc6b38ee53b6","title":"Psycopg2: PostgreSQL & Python the Old Fashioned Way","slug":"psycopg2-postgres-python-the-old-fashioned-way","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/psycopg2.jpg","excerpt":"Manage PostgreSQL database interactions in Python with the Psycopg2 library.","custom_excerpt":"Manage PostgreSQL database interactions in Python with the Psycopg2 library.","created_at_pretty":"14 January, 2019","published_at_pretty":"15 January, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-14T17:20:52.000-05:00","published_at":"2019-01-15T15:57:34.000-05:00","updated_at":"2019-03-28T14:46:14.000-04:00","meta_title":"Psycopg2: PostgreSQL & Python the Old Way | Hackers and Slackers","meta_description":"Manage PostgreSQL database interactions in Python with the Psycopg2 library.","og_description":"Manage PostgreSQL database interactions in Python with the Psycopg2 library.","og_image":"https://hackersandslackers.com/content/images/2019/02/psycopg2.jpg","og_title":"Psycopg2: PostgreSQL & Python the Old Fashioned Way","twitter_description":"Manage PostgreSQL database interactions in Python with the Psycopg2 library.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/psycopg2.jpg","twitter_title":"Psycopg2: PostgreSQL & Python the Old Fashioned Way","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"PostgreSQL","slug":"postgresql","description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","feature_image":null,"meta_description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","meta_title":"Working with PostgreSQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"PostgreSQL","slug":"postgresql","description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","feature_image":null,"meta_description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","meta_title":"Working with PostgreSQL | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"Last time we met, we joyfully shared a little tirade\n[https://hackersandslackers.com/pythonic-database-management-with-sqlalchemy/] \nabout missing out on functionality provided to us by libraries such as \nSQLAlchemy, and the advantages of interacting with databases where ORMs are\ninvolved. I stand by that sentiment, but I’ll now directly contradict myself by\nsharing some tips on using vanilla Psycopg2  to interact with databases. \n\nWe never know when we’ll be stranded on a desert island without access to\nSQLAlchemy, but a lonesome Psycopg2 washes up on shore. Either that or perhaps\nyou’re part of a development team stuck in a certain way of doing things which\ndoesn't include utilize SQLAlchemy. Whatever the situation may be, we’re here\nfor you. \n\nThe Quintessential Boilerplate\nNo matter the type of database or the library, the boilerplate code for\nconnecting to databases remains mostly the same. To some extent, this even holds\ntrue across programming languages. Let's look at a barebones example while\nignoring the library at hand:\n\nimport SomeDatabaseLibrary\n\nclass Database:\n    \"\"\"A Generic Database class.\"\"\"\n\n    def __init__(self, config):\n        self.username = config.database('USERNAME')\n        self.password = config.database('PASSWORD')\n        self.host = config.database('HOST')\n        self.port = config.database('PORT')\n        self.db = config.database('DB')\n\n    def run_query(self, query):\n            conn = None\n            records = []\n            try:\n                conn = SomeDatabaseLibrary.connect(host=self.host, \n                                                user=self.username, \n                                                password=self.password,\n                                                port=self.port, \n                                                dbname=self.db)\n                with conn.cursor() as cur:\n                    cur.execute(query)\n                    result = cur.fetchall()\n                    for row in result:\n                        records.append(row)\n                    cur.close()\n                    return records\n            except (Exception, SomeDatabaseLibrary.DatabaseError) as error:\n                print(error)\n            finally:\n                if conn is not None:\n                    conn.close()\n                    print('Database connection closed.')\n\n\nIn the above example, we could swap SomeDatabaseLibrary  with either Psycopg2 \nor PyMySQL  just the same. If we compare this to our example with PyMySQL\n[https://hackersandslackers.com/using-pymysql/], it's easy to see that the\nbasics of utilizing connections, cursors, and the methods to close them\ntranscend libraries. If you know the basics of one, you know them all.\n\nIf you'd like to keep your connection logic separate (as I do), we can cleanly\nbreak the logic of handling connections out to a separate function. This time,\nwe'll replace SomeDatabaseLibrary  with Psycopg2  to produce some working code:\n\nimport psycopg2\n\nclass Database:\n    \"\"\"A Generic Database class.\"\"\"\n\n    def __init__(self, config):\n        self.username = config.database('USERNAME')\n        self.password = config.database('PASSWORD')\n        self.host = config.database('HOST')\n        self.port = config.database('PORT')\n        self.db = config.database('DB')\n        self.conn = None\n        \n    def open_connection():\n        \"\"\"Encapsulated connection management logic.\"\"\"\n        try:\n            if(self.conn is None):\n                self.conn = psycopg2.connect(host=self.host, \n                                       user=self.username, \n                                       password=self.password,\n                                       port=self.port, \n                                       dbname=self.db)\n            elif (not conn.open):\n                self.conn = psycopg2.connect(host=self.host, \n                                       user=self.username, \n                                       password=self.password,\n                                       port=self.port, \n                                       dbname=self.db)  \n        except:\n            logger.error(\"ERROR: Could not connect to Postgres.\")\n            sys.exit()\n\n    def run_query(self, query):\n            records = []\n            try:\n                open_connection()\n                with self.conn.cursor() as cur:\n                    cur.execute(query)\n                    result = cur.fetchall()\n                    for row in result:\n                        records.append(row)\n                    cur.close()\n                    return records\n            except (Exception, psycopg2.DatabaseError) as error:\n                print(error)\n            finally:\n                if conn is not None:\n                    conn.close()\n                    print('Database connection closed.')\n\n\nPsycopg2 Extras\nPsycopg2 has many useful features via a library called psycopg2.extras\n[http://initd.org/psycopg/docs/extras.html]. My personal favorite of these\nextras is the DictCursor, which renders the rows being returned by our query as\nPython dictionaries  as opposed to lists. \n\nUsing DictCursor to Return More Useful Results\nWhen using a DictCursor, the key  is always the column name, and the value is\nthe value of that column in that particular row.\n\nTo use extras, we import psycopg2.extras.\n\nThen, we turn our attention to the following line:\n\nself.conn.cursor() as cur:\n\n\nWithin cursor, we can pass an attribute named cursor_factory   and set it as\nsuch:\n\nconn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:\n\n\nWhile our cursor is open, all rows returned by the query will be returned as\ndictionaries. For example, the row  in the above example will be returned as a\ndict. To demonstrate, here's what a query on this exact post  you're reading now\nlooks like when returned as a Dict:\n\n{\n    title: \"Psycopg2: Postgres & Python the Old Fashioned Way\",\n    slug: \"psycopg2-postgres-python-the-old-fashioned-way\",\n    feature_image: \"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/psycopg2.jpg\",\n    status: \"draft\",\n    created_at: \"2019-01-14 22:20:52\",\n    custom_excerpt: \"Managing Postgres Database connections with Psycopg2\"\n}\n\n\nCompare this to what we would've seen had we not used DictCursor:\n\n[\"Psycopg2: Postgres & Python the Old Fashioned Way\",\n\"psycopg2-postgres-python-the-old-fashioned-way\",\n\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/psycopg2.jpg\",\n\"draft\",\n\"2019-01-14 22:20:52\",\n\"Managing Postgres Database connections with Psycopg2\"]\n\n\nYes, it's a list, and thereby much less useful. Even from a readability\nstandpoint, I (the human user) have no idea what these values represent unless\ncomparing them to the table schema. Even worse would be compiling CSVs or even\nPandas Dataframes this way. When building a table made of lists, you set your\nheaders and hope that every row to come matches the number of header columns\none-to-one. Otherwise, it's entirely unclear as to which value belongs to which\ncolumn.\n\nOther Psycopg2 Extras\nThere are plenty more Psycopg2 extras where that came from; it's mostly up to\nyou to decide which are worth your while.\n\nFor example, another extra which might be of interest could be \npsycopg2.extras.LoggingConnection, useful for debugging connection statuses and\nerrors as you work through your program.\n\nThere's even a JSON Adaptation  extra, which provides support for leveraging\nJSON data in building queries:\n\ncur.execute(\"insert into mytable (jsondata) values (%s)\",\n    [Json({'a': 100})])\n\n\nI don't dwell too deep in Psycopg2 extras myself, but if you see any Godlike\nextras I'm missing, feel free to call them out in the COMMENTS BELOW!  (Hah!\nI've always wanted to say that).\n\nA Few More Fundamental Useful Things\nSomething worth visiting is the ability to upload CSVs into Postgres to create\ntables. We can accomplish this via the built-in method copy_expert.\n\nFrom CSV to Postgres Table\nTo save a CSV to Postgres table, we need to begin with a basic SQL query saved\nin our project as a variable:\n\nCOPY %s FROM STDIN WITH\n                    CSV\n                    HEADER\n                    DELIMITER AS ','\n\n\nAs should be familiar, %s  represents a value we can pass in later. With this\nraw query, we're only missing two more values:\n\n * The path of our CSV file to be uploaded\n * The name of the table we'd like to upload to in Postgres\n\nCheck out how we use copy_expert  here to put it all together:\n\nsql = \"COPY %s FROM STDIN WITH CSVHEADER DELIMITER AS ','\"\nfile = open('files/myfile.csv', \"r\")\ntable = 'my_postgres_table'\nwith conn.cursor() as cur:\n    cur.execute(\"truncate \" + table + \";\")\n    cur.copy_expert(sql=sql % table, file=file)\n    conn.commit()\n    cur.close()\n    conn.close()\n\n\nNotice that I opt to truncate the existing table before uploading the new data,\nas seen by cur.execute(\"truncate \" + table + \";\"). Without doing this, we would\nbe uploading the same CSV to the same table forever, creating duplicate rows\nover and over.\n\nWhat if The Table Doesn't Exist?\nUgh, of course  this would come up. The truth is (to the best of my knowledge),\nthere aren't many native things Psycopg2 has to offer to make this process easy.\n \n\nRecall that creating a table has a syntax similar to this:\n\nCREATE TABLE `recommended_reads` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `title` varchar(150) NOT NULL,\n  `content` text,\n  `url` varchar(150) NOT NULL,\n  `created` int(11) NOT NULL,\n  `unique_ID` int(11) NOT NULL,\n  `image` varchar(150) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `id` (`id`),\n  UNIQUE KEY `uniqueid` (`unique_ID`) USING BTREE\n)\n\n\nIt's not impossible to build this string yourself in Python. It just entails a\nlot of iterating over whichever dynamic data structure you have coming through,\ndetermining the correct data type per column, and then the unavoidable task of\nsetting your Primary  and Unique  keys if applicable. This is where my patience\nends and knee-jerk reaction of \"would be easier in SQLAlchemy\" kicks in. Hey,\nit's possible! I just don't feel like writing about it. :).\n\nGodspeed to You, Brave Warrior\nFor those about to Psycopg2, we salute you. That is unless the choice is\nself-inflicted. In that case, perhaps it's best we don't work together any time\nsoon.","html":"<p>Last time we met, we joyfully <a href=\"https://hackersandslackers.com/pythonic-database-management-with-sqlalchemy/\">shared a little tirade</a> about missing out on functionality provided to us by libraries such as <strong>SQLAlchemy</strong>, and the advantages of interacting with databases where ORMs are involved. I stand by that sentiment, but I’ll now directly contradict myself by sharing some tips on using vanilla <strong>Psycopg2</strong> to interact with databases. </p><p>We never know when we’ll be stranded on a desert island without access to SQLAlchemy, but a lonesome Psycopg2 washes up on shore. Either that or perhaps you’re part of a development team stuck in a certain way of doing things which doesn't include utilize SQLAlchemy. Whatever the situation may be, we’re here for you. </p><h2 id=\"the-quintessential-boilerplate\">The Quintessential Boilerplate</h2><p>No matter the type of database or the library, the boilerplate code for connecting to databases remains mostly the same. To some extent, this even holds true across programming languages. Let's look at a barebones example while ignoring the library at hand:</p><pre><code class=\"language-python\">import SomeDatabaseLibrary\n\nclass Database:\n    &quot;&quot;&quot;A Generic Database class.&quot;&quot;&quot;\n\n    def __init__(self, config):\n        self.username = config.database('USERNAME')\n        self.password = config.database('PASSWORD')\n        self.host = config.database('HOST')\n        self.port = config.database('PORT')\n        self.db = config.database('DB')\n\n    def run_query(self, query):\n            conn = None\n            records = []\n            try:\n                conn = SomeDatabaseLibrary.connect(host=self.host, \n                                                user=self.username, \n                                                password=self.password,\n                                                port=self.port, \n                                                dbname=self.db)\n                with conn.cursor() as cur:\n                    cur.execute(query)\n                    result = cur.fetchall()\n                    for row in result:\n                        records.append(row)\n                    cur.close()\n                    return records\n            except (Exception, SomeDatabaseLibrary.DatabaseError) as error:\n                print(error)\n            finally:\n                if conn is not None:\n                    conn.close()\n                    print('Database connection closed.')\n</code></pre>\n<p>In the above example, we could swap <code>SomeDatabaseLibrary</code> with either <code>Psycopg2</code> or <code>PyMySQL</code> just the same. If we compare this to <a href=\"https://hackersandslackers.com/using-pymysql/\">our example with PyMySQL</a>, it's easy to see that the basics of utilizing <strong>connections</strong>, <strong>cursors</strong>, and the methods to close them transcend libraries. If you know the basics of one, you know them all.</p><p>If you'd like to keep your connection logic separate (as I do), we can cleanly break the logic of handling connections out to a separate function. This time, we'll replace <code>SomeDatabaseLibrary</code> with <code>Psycopg2</code> to produce some working code:</p><pre><code class=\"language-python\">import psycopg2\n\nclass Database:\n    &quot;&quot;&quot;A Generic Database class.&quot;&quot;&quot;\n\n    def __init__(self, config):\n        self.username = config.database('USERNAME')\n        self.password = config.database('PASSWORD')\n        self.host = config.database('HOST')\n        self.port = config.database('PORT')\n        self.db = config.database('DB')\n        self.conn = None\n        \n    def open_connection():\n        &quot;&quot;&quot;Encapsulated connection management logic.&quot;&quot;&quot;\n        try:\n            if(self.conn is None):\n                self.conn = psycopg2.connect(host=self.host, \n                                       user=self.username, \n                                       password=self.password,\n                                       port=self.port, \n                                       dbname=self.db)\n            elif (not conn.open):\n                self.conn = psycopg2.connect(host=self.host, \n                                       user=self.username, \n                                       password=self.password,\n                                       port=self.port, \n                                       dbname=self.db)  \n        except:\n            logger.error(&quot;ERROR: Could not connect to Postgres.&quot;)\n            sys.exit()\n\n    def run_query(self, query):\n            records = []\n            try:\n                open_connection()\n                with self.conn.cursor() as cur:\n                    cur.execute(query)\n                    result = cur.fetchall()\n                    for row in result:\n                        records.append(row)\n                    cur.close()\n                    return records\n            except (Exception, psycopg2.DatabaseError) as error:\n                print(error)\n            finally:\n                if conn is not None:\n                    conn.close()\n                    print('Database connection closed.')\n</code></pre>\n<h2 id=\"psycopg2-extras\">Psycopg2 Extras</h2><p>Psycopg2 has many useful features via a library called <a href=\"http://initd.org/psycopg/docs/extras.html\">psycopg2.extras</a>. My personal favorite of these extras is the <code>DictCursor</code>, which renders the rows being returned by our query as Python <em>dictionaries</em> as opposed to <em>lists. </em></p><h3 id=\"using-dictcursor-to-return-more-useful-results\">Using DictCursor to Return More Useful Results</h3><p>When using a DictCursor, the <em>key</em> is always the column name, and the <em>value </em>is the value of that column in that particular row.</p><p>To use extras, we <code>import psycopg2.extras</code>.</p><p>Then, we turn our attention to the following line:</p><pre><code class=\"language-python\">self.conn.cursor() as cur:\n</code></pre>\n<p>Within <code>cursor</code>, we can pass an attribute named <code>cursor_factory</code>  and set it as such:</p><pre><code class=\"language-python\">conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:\n</code></pre>\n<p>While our cursor is open, all rows returned by the query will be returned as dictionaries. For example, the <strong>row</strong> in the above example will be returned as a dict. To demonstrate, here's what a query on this <em>exact post</em> you're reading now looks like when returned as a Dict:</p><pre><code class=\"language-python\">{\n    title: &quot;Psycopg2: Postgres &amp; Python the Old Fashioned Way&quot;,\n    slug: &quot;psycopg2-postgres-python-the-old-fashioned-way&quot;,\n    feature_image: &quot;https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/psycopg2.jpg&quot;,\n    status: &quot;draft&quot;,\n    created_at: &quot;2019-01-14 22:20:52&quot;,\n    custom_excerpt: &quot;Managing Postgres Database connections with Psycopg2&quot;\n}\n</code></pre>\n<p>Compare this to what we would've seen had we not used <code>DictCursor</code>:</p><pre><code class=\"language-python\">[&quot;Psycopg2: Postgres &amp; Python the Old Fashioned Way&quot;,\n&quot;psycopg2-postgres-python-the-old-fashioned-way&quot;,\n&quot;https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/psycopg2.jpg&quot;,\n&quot;draft&quot;,\n&quot;2019-01-14 22:20:52&quot;,\n&quot;Managing Postgres Database connections with Psycopg2&quot;]\n</code></pre>\n<p>Yes, it's a list, and thereby much less useful. Even from a readability standpoint, I (the human user) have no idea what these values represent unless comparing them to the table schema. Even worse would be compiling CSVs or even Pandas Dataframes this way. When building a table made of lists, you set your headers and hope that every row to come matches the number of header columns one-to-one. Otherwise, it's entirely unclear as to which value belongs to which column.</p><h3 id=\"other-psycopg2-extras\">Other Psycopg2 Extras</h3><p>There are plenty more Psycopg2 extras where that came from; it's mostly up to you to decide which are worth your while.</p><p>For example, another extra which might be of interest could be <code>psycopg2.extras.LoggingConnection</code>, useful for debugging connection statuses and errors as you work through your program.</p><p>There's even a <strong>JSON Adaptation</strong> extra, which provides support for leveraging JSON data in building queries:</p><pre><code class=\"language-python\">cur.execute(&quot;insert into mytable (jsondata) values (%s)&quot;,\n    [Json({'a': 100})])\n</code></pre>\n<p>I don't dwell too deep in Psycopg2 extras myself, but if you see any Godlike extras I'm missing, feel free to call them out in the <strong><em>COMMENTS BELOW!</em></strong> (Hah! I've always wanted to say that).</p><h2 id=\"a-few-more-fundamental-useful-things\">A Few More Fundamental Useful Things</h2><p>Something worth visiting is the ability to upload CSVs into Postgres to create tables. We can accomplish this via the built-in method <code>copy_expert</code>.</p><h3 id=\"from-csv-to-postgres-table\">From CSV to Postgres Table</h3><p>To save a CSV to Postgres table, we need to begin with a basic SQL query saved in our project as a variable:</p><pre><code class=\"language-sql\">COPY %s FROM STDIN WITH\n                    CSV\n                    HEADER\n                    DELIMITER AS ','\n</code></pre>\n<p>As should be familiar, <code>%s</code> represents a value we can pass in later. With this raw query, we're only missing two more values:</p><ul><li>The path of our CSV file to be uploaded</li><li>The name of the table we'd like to upload to in Postgres</li></ul><p>Check out how we use <code>copy_expert</code> here to put it all together:</p><pre><code class=\"language-python\">sql = &quot;COPY %s FROM STDIN WITH CSVHEADER DELIMITER AS ','&quot;\nfile = open('files/myfile.csv', &quot;r&quot;)\ntable = 'my_postgres_table'\nwith conn.cursor() as cur:\n    cur.execute(&quot;truncate &quot; + table + &quot;;&quot;)\n    cur.copy_expert(sql=sql % table, file=file)\n    conn.commit()\n    cur.close()\n    conn.close()\n</code></pre>\n<p>Notice that I opt to truncate the existing table before uploading the new data, as seen by <code>cur.execute(\"truncate \" + table + \";\")</code>. Without doing this, we would be uploading the same CSV to the same table forever, creating duplicate rows over and over.</p><h3 id=\"what-if-the-table-doesn-t-exist\">What if The Table Doesn't Exist?</h3><p>Ugh, of <em>course</em> this would come up. The truth is (to the best of my knowledge), there aren't many native things Psycopg2 has to offer to make this process easy. </p><p>Recall that creating a table has a syntax similar to this:</p><pre><code class=\"language-sql\">CREATE TABLE `recommended_reads` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `title` varchar(150) NOT NULL,\n  `content` text,\n  `url` varchar(150) NOT NULL,\n  `created` int(11) NOT NULL,\n  `unique_ID` int(11) NOT NULL,\n  `image` varchar(150) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `id` (`id`),\n  UNIQUE KEY `uniqueid` (`unique_ID`) USING BTREE\n)\n</code></pre>\n<p>It's not impossible to build this string yourself in Python. It just entails a lot of iterating over whichever dynamic data structure you have coming through, determining the correct data type per column, and then the unavoidable task of setting your <strong>Primary</strong> and <strong>Unique</strong> keys if applicable. This is where my patience ends and knee-jerk reaction of \"would be easier in SQLAlchemy\" kicks in. Hey, it's possible! I just don't feel like writing about it. :).</p><h2 id=\"godspeed-to-you-brave-warrior\">Godspeed to You, Brave Warrior</h2><p>For those about to Psycopg2, we salute you. That is unless the choice is self-inflicted. In that case, perhaps it's best we don't work together any time soon.</p>","url":"https://hackersandslackers.com/psycopg2-postgres-python-the-old-fashioned-way/","uuid":"f07736c5-c167-4fe9-b932-1b6b4d95e3ff","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c3d0b441719dc6b38ee53b6"}},{"node":{"id":"Ghost__Post__5c3409a094d3e847951adf44","title":"Pythonic Database Management with SQLAlchemy","slug":"pythonic-database-management-with-sqlalchemy","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/sqlalchemy2-1-2.jpg","excerpt":"The iconic Python library for handling any conceivable database interaction.","custom_excerpt":"The iconic Python library for handling any conceivable database interaction.","created_at_pretty":"08 January, 2019","published_at_pretty":"09 January, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-07T21:23:28.000-05:00","published_at":"2019-01-09T08:00:00.000-05:00","updated_at":"2019-03-28T11:17:45.000-04:00","meta_title":"Pythonic Database Management with SQLAlchemy | Hackers and Slackers","meta_description":"The iconic Python library for handling any conceivable database interaction.","og_description":"The iconic Python library for handling any conceivable database interaction.","og_image":"https://hackersandslackers.com/content/images/2019/03/sqlalchemy2-1-2.jpg","og_title":"Pythonic Database Management with SQLAlchemy","twitter_description":"The iconic Python library for handling any conceivable database interaction.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/sqlalchemy2-1-1.jpg","twitter_title":"Pythonic Database Management with SQLAlchemy","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"Something we've taken for granted thus far on Hackers and Slackers is a library\nmost data professionals have accepted as an undisputed standard: SQLAlchemy\n[https://www.sqlalchemy.org/].\n\nIn the past, we've covered database connection management and querying using\nlibraries such as PyMySQL [https://hackersandslackers.com/using-pymysql/]  and \nPsycopg2\n[https://hackersandslackers.com/psycopg2-postgres-python-the-old-fashioned-way/]\n, both of which do an excellent job of interacting with databases just as we'd\nexpect them to. The nature of opening/closing DB connections and working with\ncursors hasn't changed much in the past few decades (nearly the lifespan of\nrelational databases themselves). While boilerplate is boring, at least it has\nremained consistent, one might figure. That may  have been the case, but the\nphilosophical boom of MVC frameworks nearly a decade ago sparked the emergence\nof popularity for ORMs. While the world was singing praises of object-oriented\nprogramming, containing database-oriented functionality within objects must have\nbeen a wet dream.\n\nThe only thing shocking about SQLAlchemy's popularity is its flip side: the\ncontingency of those functioning without  SQLAlchemy as a part of their regular\nstack. Whether this stems from unawareness or active reluctance to change, data\nteams using Python without a proper ORM are surprisingly prevalent. It's easy to\nforget the reality of the workforce when our interactions with other\nprofessionals come mostly from blogs published by those at the top of their\nfield.\n\nI realize the \"this is how we've always done it\" attitude is a cliché with no\nshortage of commentary. Tales of adopting new (relatively speaking) practices\ndominate Silicon Valley blogs every day- it's the manner in which this is\nmanifested, however, that catches me off guard. In this case, resistance to a\nsingle Python library can shed light on a frightening mental model that has\nimplications up and down a corporation's stack.\n\nPutting The 'M' In MVC\nFrameworks which enforce a Model-View-Controller have held undisputed consensus\nfor long enough: none of us need to recap why creating apps this way is\nunequivocally correct. To understand why side-stepping an ORM is so significant,\nlet's recall what ORM stands for:\n\n> Object-Relational Mapping, commonly referred to as its abbreviation ORM, is a\ntechnique that connects the rich objects of an application to tables in a\nrelational database management system. Using ORM, the properties and\nrelationships of the objects in an application can be easily stored and\nretrieved from a database without writing SQL statements directly and with less\noverall database access code. - Active Record\n[https://guides.rubyonrails.org/active_record_basics.html]\nORMs allow us to interact with databases simply by modifying objects in code\n(such as classes) as opposed to generating SQL queries by hand for each database\ninteraction. Bouncing from application code to SQL is a major context switch,\nand the more interactions we introduce, the more out of control our app becomes.\n \n\nTo illustrate the alternative to this using models, I'll use an example offered\nby Flask-SQLAlchemy. Let's say we have a table of users which contains columns\nfor id, username,  and email. A model for such a table would look as such:\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n\n\nThe 'model' is an object representing the structure of a single entry in our\ntable. Once our model exists, this is all it takes to create an entry:\n\nnewuser = User(username='admin', email='admin@example.com')\n\n\nThat's a single readable line of code without writing a single line of SQL.\nCompare this to the alternative, which would be to use Psycopg2:\n\nquery = \"INSERT INTO users VALUES username='admin', email='admin@example.com';\"\n\ndef query_function(query):\n  \"\"\"Runs a database query.\"\"\"\n  try:\n    conn = psycopg2.connect(\n      user = config.username,\n      password = config.password,\n      host = config.host,\n      port = config.port,\n      database = config.database)\n      with conn.cursor() as cur:\n         cur.execute(query)\n           cur.close()\n           conn.close()\n  except Exception as e:\n      print(e)\n        \nquery_function(query)\n\n\nSure, query_function()  only needs to be set once, but compare the readability\nof using a model to the following:\n\nquery = \"INSERT INTO users VALUES username='admin', email='admin@example.com';\"\n\nquery_function(query)\n\n\nDespite achieving the same effect, the latter is much less readable or\nmaintainable by human beings. Building an application around raw string queries\ncan quickly become a nightmare.\n\nIntegration With Other Data Libraries\nWhen it comes to golden standards of Python libraries, there is none more\nquintessential to data analysis than Pandas. The pairing of Pandas and\nSQLAlchemy is standard to the point where Pandas has built-in integrations to\ninteract with data from SQLAlchemy. Here's what it takes to turn a database\ntable into a Pandas dataframe with SQLAlchemy as our connector:\n\ndf = pd.read_sql(session.query(Table).filter(User.id == 2).statement,session.bind)\n\n\nOnce again, a single line of Python code!\n\nWriting Queries Purely in Python\nSo far by using SQLAlchemy, we haven't needed to write a single line of SQL: how\nfar could we take this? As far as we want, in fact. SQLAlchemy contains what\nthey've dubbed as function-based query construction, which is to say we can\nconstruct nearly any conceivable SQL query purely in Python by using the methods\noffered to us. For example, here's an update query:\n\nstmt = users.update().values(fullname=\"Fullname: \" + users.c.name)\nconn.execute(stmt)\n\n\nCheck the  full reference to see what I mean\n[https://docs.sqlalchemy.org/en/latest/core/tutorial.html#inserts-and-updates].\nEvery query you've ever needed to write: it's all there. All of it.\n\nSimple Connection Management\nSeeing as how we all now agree that SQLAlchemy is beneficial to our workflow,\nlet's visit square one and see how simple it is to manage connections. The two\nkey words to remember here are engines  and sessions.\n\nThe Engine\nAn engine in SQLAlchemy is merely a bare-bones object representing our database.\nMaking SQLAlchemy aware of our database is as simple as these two lines:\n\nfrom sqlalchemy import create_engine\nengine = create_engine('sqlite:///:memory:', echo=True)\n\n\nThe Engine can interact with our database by accepting a simple URI. Once engine \n exists, we could in theory use engine exclusively via functions such as \nengine.connect()  and engine.execute().\n\nSessions\nTo interact with our database in a Pythonic manner via the ORM, we'll need to\ncreate a session  from the engine we just declared. Thus our code expands:\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine('sqlite:///:memory:', echo=True)\nSession = sessionmaker(bind=engine)\n\n\nThat's all it takes! Now just as before, we can use SQLAlchemy's ORM and\nbuilt-in functions to make simple interacts:\n\nnew_user = User(name='todd', fullname='Todd Hacker', password='toddspassword')\nsession.add(new_user)\n\n\nTakeaway Goodies\nIt's worth mentioning that SQLAlchemy works with nearly every type of database,\nand does so by leveraging the base Python library for the respective type of\ndatabase. For example, it probably seems to the outsider that we've spent some\ntime shitting on Psycopg2. On the contrary, when SQLAlchemy connects to a\nPostgres database, it is using the Psycopg2 library under the hood to manage the\nboilerplate for us. The same goes for every other type of relational database\n[https://docs.sqlalchemy.org/en/latest/core/engines.html]  along with their\nstandard libraries.\n\nThere are plenty of more reasons [https://www.sqlalchemy.org/features.html]  why\nSQLAlchemy is beneficial to the point where it is arguably critical to data\nanalysis workflows. The critical point to be made here is that leaving\nSQLAlchemy out of any data workflow only hurts the person writing the code, or\nmore importantly, all those who come after.","html":"<p>Something we've taken for granted thus far on Hackers and Slackers is a library most data professionals have accepted as an undisputed standard: <strong><a href=\"https://www.sqlalchemy.org/\">SQLAlchemy</a></strong>.</p><p>In the past, we've covered database connection management and querying using libraries such as <a href=\"https://hackersandslackers.com/using-pymysql/\"><strong>PyMySQL</strong></a> and <strong><a href=\"https://hackersandslackers.com/psycopg2-postgres-python-the-old-fashioned-way/\">Psycopg2</a></strong>, both of which do an excellent job of interacting with databases just as we'd expect them to. The nature of opening/closing DB connections and working with cursors hasn't changed much in the past few decades (nearly the lifespan of relational databases themselves). While boilerplate is boring, at least it has remained consistent, one might figure. That <strong><em>may</em></strong> have been the case, but the philosophical boom of MVC frameworks nearly a decade ago sparked the emergence of popularity for ORMs. While the world was singing praises of object-oriented programming, containing database-oriented functionality within objects must have been a wet dream.</p><p>The only thing shocking about SQLAlchemy's popularity is its flip side: the contingency of those functioning <em>without</em> SQLAlchemy as a part of their regular stack. Whether this stems from unawareness or active reluctance to change, data teams using Python without a proper ORM are surprisingly prevalent. It's easy to forget the reality of the workforce when our interactions with other professionals come mostly from blogs published by those at the top of their field.</p><p>I realize the \"this is how we've always done it\" attitude is a cliché with no shortage of commentary. Tales of adopting new (relatively speaking) practices dominate Silicon Valley blogs every day- it's the manner in which this is manifested, however, that catches me off guard. In this case, resistance to a single Python library can shed light on a frightening mental model that has implications up and down a corporation's stack.</p><h2 id=\"putting-the-m-in-mvc\">Putting The 'M' In MVC</h2><p>Frameworks which enforce a Model-View-Controller have held undisputed consensus for long enough: none of us need to recap why creating apps this way is unequivocally correct. To understand why side-stepping an ORM is so significant, let's recall what ORM stands for:</p><blockquote><em>Object-Relational Mapping, commonly referred to as its abbreviation ORM, is a technique that connects the rich objects of an application to tables in a relational database management system. Using ORM, the properties and relationships of the objects in an application can be easily stored and retrieved from a database without writing SQL statements directly and with less overall database access code. <strong>- <a href=\"https://guides.rubyonrails.org/active_record_basics.html\">Active Record</a></strong></em></blockquote><p>ORMs allow us to interact with databases simply by modifying objects in code (such as classes) as opposed to generating SQL queries by hand for each database interaction. Bouncing from application code to SQL is a <em>major context switch</em>, and the more interactions we introduce, the more out of control our app becomes. </p><p>To illustrate the alternative to this using models, I'll use an example offered by <strong>Flask-SQLAlchemy</strong>. Let's say we have a table of users which contains columns for <strong>id, username,</strong> and <strong>email. </strong>A model for such a table would look as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">class User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return '&lt;User %r&gt;' % self.username\n</code></pre>\n<!--kg-card-end: markdown--><p>The 'model' is an object representing the structure of a single entry in our table. Once our model exists, this is all it takes to create an entry:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">newuser = User(username='admin', email='admin@example.com')\n</code></pre>\n<!--kg-card-end: markdown--><p>That's a single readable line of code without writing a single line of SQL. Compare this to the alternative, which would be to use Psycopg2:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">query = &quot;INSERT INTO users VALUES username='admin', email='admin@example.com';&quot;\n\ndef query_function(query):\n  &quot;&quot;&quot;Runs a database query.&quot;&quot;&quot;\n  try:\n    conn = psycopg2.connect(\n      user = config.username,\n      password = config.password,\n      host = config.host,\n      port = config.port,\n      database = config.database)\n      with conn.cursor() as cur:\n         cur.execute(query)\n           cur.close()\n           conn.close()\n  except Exception as e:\n      print(e)\n        \nquery_function(query)\n</code></pre>\n<!--kg-card-end: markdown--><p>Sure, <code>query_function()</code> only needs to be set once, but compare the readability of using a model to the following:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">query = &quot;INSERT INTO users VALUES username='admin', email='admin@example.com';&quot;\n\nquery_function(query)\n</code></pre>\n<!--kg-card-end: markdown--><p>Despite achieving the same effect, the latter is much less readable or maintainable by human beings. Building an application around raw string queries can quickly become a nightmare.</p><h2 id=\"integration-with-other-data-libraries\">Integration With Other Data Libraries</h2><p>When it comes to golden standards of Python libraries, there is none more quintessential to data analysis than Pandas. The pairing of Pandas and SQLAlchemy is standard to the point where Pandas has built-in integrations to interact with data from SQLAlchemy. Here's what it takes to turn a database table into a Pandas dataframe with SQLAlchemy as our connector:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">df = pd.read_sql(session.query(Table).filter(User.id == 2).statement,session.bind)\n</code></pre>\n<!--kg-card-end: markdown--><p>Once again, a single line of Python code!</p><h2 id=\"writing-queries-purely-in-python\">Writing Queries Purely in Python</h2><p>So far by using SQLAlchemy, we haven't needed to write a single line of SQL: how far could we take this? As far as we want, in fact. SQLAlchemy contains what they've dubbed as <strong>function-based query construction, </strong>which is to say we can construct nearly any conceivable SQL query purely in Python by using the methods offered to us. For example, here's an update query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">stmt = users.update().values(fullname=&quot;Fullname: &quot; + users.c.name)\nconn.execute(stmt)\n</code></pre>\n<!--kg-card-end: markdown--><p>Check the<a href=\"https://docs.sqlalchemy.org/en/latest/core/tutorial.html#inserts-and-updates\"> full reference to see what I mean</a>. Every query you've ever needed to write: it's all there. All of it.</p><h2 id=\"simple-connection-management\">Simple Connection Management</h2><p>Seeing as how we all now agree that SQLAlchemy is beneficial to our workflow, let's visit square one and see how simple it is to manage connections. The two key words to remember here are <strong>engines</strong> and <strong>sessions</strong>.</p><h3 id=\"the-engine\">The Engine</h3><p>An engine in SQLAlchemy is merely a bare-bones object representing our database. Making SQLAlchemy aware of our database is as simple as these two lines:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from sqlalchemy import create_engine\nengine = create_engine('sqlite:///:memory:', echo=True)\n</code></pre>\n<!--kg-card-end: markdown--><p>The Engine can interact with our database by accepting a simple URI. Once <code>engine</code> exists, we could in theory use engine exclusively via functions such as <code>engine.connect()</code> and <code>engine.execute()</code>.</p><h3 id=\"sessions\">Sessions</h3><p>To interact with our database in a Pythonic manner via the ORM, we'll need to create a <strong>session</strong> from the <strong>engine </strong>we just declared. Thus our code expands:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine('sqlite:///:memory:', echo=True)\nSession = sessionmaker(bind=engine)\n</code></pre>\n<!--kg-card-end: markdown--><p>That's all it takes! Now just as before, we can use SQLAlchemy's ORM and built-in functions to make simple interacts:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">new_user = User(name='todd', fullname='Todd Hacker', password='toddspassword')\nsession.add(new_user)\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"takeaway-goodies\">Takeaway Goodies</h2><p>It's worth mentioning that SQLAlchemy works with nearly every type of database, and does so by leveraging the base Python library for the respective type of database. For example, it probably seems to the outsider that we've spent some time shitting on Psycopg2. On the contrary, when SQLAlchemy connects to a Postgres database, it is using the Psycopg2 library under the hood to manage the boilerplate for us. The same goes for <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html\">every other type of relational database</a> along with their standard libraries.</p><p>There are <a href=\"https://www.sqlalchemy.org/features.html\">plenty of more reasons</a> why SQLAlchemy is beneficial to the point where it is arguably critical to data analysis workflows. The critical point to be made here is that leaving SQLAlchemy out of any data workflow only hurts the person writing the code, or more importantly, all those who come after.</p>","url":"https://hackersandslackers.com/pythonic-database-management-with-sqlalchemy/","uuid":"7246d9db-39cb-44aa-9da8-cf87df00eeff","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c3409a094d3e847951adf44"}},{"node":{"id":"Ghost__Post__5c307c9493bed0776a0a3d80","title":"Using Redis to Store Information in Python Applications","slug":"using-redis-with-python","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/redis-1-2.jpg","excerpt":"A temporary data store for everything from session variables to chat queues.","custom_excerpt":"A temporary data store for everything from session variables to chat queues.","created_at_pretty":"05 January, 2019","published_at_pretty":"05 January, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-05T04:44:52.000-05:00","published_at":"2019-01-05T08:21:00.000-05:00","updated_at":"2019-03-28T05:41:12.000-04:00","meta_title":"Using Redis to Store Information in Python Apps | Hackers and Slackers","meta_description":"Take the guesswork out of storing values in memory: use Redis in your Python stack to have full control over session variables.","og_description":"Take the guesswork out of storing values in memory: use Redis in your Python stack to have full control over session variables.","og_image":"https://hackersandslackers.com/content/images/2019/03/redis-1-2.jpg","og_title":"Using Redis to Store Information in Python Applications","twitter_description":"Take the guesswork out of storing values in memory: use Redis in your Python stack to have full control over session variables.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/redis-1-1.jpg","twitter_title":"Using Redis to Store Information in Python Applications","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"}],"plaintext":"We’re hacking into the new year here at Hackers and Slackers, and in the\nprocess, we’ve received plenty of new gifts to play with. Nevermind how Santa\nmanages to fit physically non-existent SaaS products under the Christmas tree.\nWe ask for abstract enterprise software every year, and this time we happened to\nget a little red box.\n\nIf you've never personally used Redis, the name probably sounds familiar as\nyou've been bombarded with obscure technology brand names in places like the\nHeroku marketplace, or your unacceptably nerdy Twitter account (I assure you,\nmine is worse). So what is Redis, you ask? Well, it's a NoSQL datasto- wait,\nwhere are you... NO! Don't leave! It's not like THAT, I swear!\n\nWhat Redis is and When to Use It\nRedis stores information in the familiar key/value pair format, but the term\n‘NoSQL’ is more of a technicality than an indicator of use cases synonymous with\nNoSQL databases of the past. Redis looks the part for the very purpose it\nserves: a box that you fill with crap which may or may not be important down the\nline. It’s the perfect place to put a Starbucks gift card or the clothes you’ve\nalready worn which aren’t quite ready to be washed yet.\n\nAll Users go to Heaven: Cloud Storage for User Sessions\nPerhaps the most common use case is a glorified session cache. Similar to the\nway users might store temporary app information in cookies, Redis holds on to\ninformation which is fleeting. The difference is we now own this information\ninside our very own box, thus the Redis motto: “your box, your rules.”* \n\n* I made this up: it holds zero truth.Because temporary user information is in\nour hands as opposed to a fickle browser, we can decide just how  temporary our\n“cache” is, having it persist across sessions or even devices. While local\nmemory storage may as well be a place for throwaway information, and databases\nfor persistent or eternal information, Redis is somewhere in between. As users\ninteract and the information they create within our app evolves, we may choose\nat any point to promote information stored in Redis to a database, or perhaps\nhave it stick around a little while longer. They’ll be thrilled to see their\nshopping cart still filled with the stupid things they almost bought while they\nwere drunk yesterday.\n\nWhen Variables are on a Bagel, You can Have Variables Any Time \nIn other words, Redis is great for solving the need of globally accessible\nvariables throughout an entire application, on a per-user basis. Users who\naccidentally quit your app, move to a new context, or merely use your app for\nlonger than your QA team are easier to manage when their temporary information\nis in a safe and global environment. Compare this to saving a user’s Pac-Man\nscore to a global variable:  the moment an app like Pac-Man crashes or restarts,\nthat session is gone forever. Thus dies another three-letter app obscenity\nbelonging to a leaderboard.\n\nSpeaking of Leaderboards...\nRedis is great at counting in increments. This is probably made evident by the\nfact that it is a computer, and these are the things computers do. Something\nelse that’s made great by counting: queues! Cues of tasks, notifications, chats,\ndisappearing naked photos, etc: all of these things are ideally suited for our\nred box.\n\nGetting a Red Box of Your Own\nPlaying around with a cloud-hosted Redis box will cost you maybe 5 bucks\n(monthly if you forget to cancel). Redis is open source so there are plenty of\nvendors to choose from with little differentiation between them. I’ll consider\nrecommending whichever vendor offers to bribe me the most, but in the meantime\nI’ll leave the window shopping to you.\n\nSetting up Redis should feel like setting up a cloud SQL database, except\nsmaller and cuter. You’ll be able to pick adorable features for your box of\npossibly-but-not-surely-worthless stuff, such as hosted region, etc. Once you're\nset up you should have a host URL for reaching your instance:\n\nredis-1738.c62.us-east-1-4.ec2.cloud.fakeredisprovider.com:42069\n\nNow we’re cooking with gas.\n\nUsing the redis-py Python Library\nThe main Python Redis library is typed as redis, as in pip install Redis. The\neasiest way to connect in any case is via a URI connection string, like such:\n\nr = redis.Redis( url='rediss://:password@hostname:port/0')\n\n\nNote the unique structure of the URI above:\n\n * rediss://: precedes all Redis URIs; NOTE THE TRAILING COLON.\n * password  comes next, with the interesting choice to bypass usernames.\n * hostname  is the instance's URL... almost always a thinly veiled repurposed\n   EC2 instance. That's right, we're being sold simple open source software\n   hosted on AWS. Don't think about it.\n * port is your preferred port of call after pillaging British trade ships. Just\n   making sure you're still here.\n * /database brings up the rear, which is the name of your database.\n\nAs with regular databases, other connection methods exist such as via SSL\ncertificates, etc.\n\nStoring and Getting Values\nThis is your bread and butter for interacting with Redis:\n\n * .set():  Set a key/value pair by either overwriting or creating a new value\n * .get():  Retrieve a value by naming the associated key\n * hmget():  Accepts a variable number of keys, and will return values for each\n   if they exist\n * hmset():  Set multiple values to a single key.\n * hgetall():  Get all values for a key where a key has been assigned multiple\n   values.\n\nIt’s important to note that Redis by default returns bytes as opposed to\nstrings. As a result, it is important to remember the encoding/decoding of\nvalues in order to retrieve them properly. For example:\n\n# Setting a Value\nr.set('uri', str(app.config['SQLALCHEMY_DATABASE_URI']).encode('utf-8'))\n\n# Getting a Value\nr.get('uri').decode('utf-8')\n\n\nIf you happen to be remotely sane, you probably don't want to deal with encoding\nand decoding values over and again. Luckily we can ensure that responses are\nalways decoded for us by setting the decode_responses  parameter to True  when\nsetting up our Redis instance:\n\nredis.StrictRedis(host=\"localhost\", port=6379, charset=\"utf-8\", decode_responses=True)\n\n\nThe redis-py documentation [https://redis-py.readthedocs.io/en/latest/] \nactually goes wayyy deeper than the 5 methods listed above. If you ever somehow\nmanage to cover all of it, I have many questions about the type of person you\nare.\n\nMore Redis Libraries for Python\nIf the above encoding/decoding seems annoying, you aren’t the first. That’s why\nlibraries like Redisworks [https://github.com/seperman/redisworks]  exist.\nRedisworks allows for the seamless exchange of Python data types to and from\nRedis. Want to shove a Python dict down your box’s throat? Go ahead! You won’t\neven have to think about it very hard. There are plenty of similar libraries all\naimed to make sad lives easier.\n\nWant more? How about Asyncio’s very own asynchronous Redis library\n[https://asyncio-redis.readthedocs.io/en/latest/]?  Or how about the similar \naioredis [aioredis.readthedocs.org], another Asyncio Redis plug-in, which also\nincludes pure Python parsing, clustering support, and things I don’t even\nunderstand! There are truly more Python libraries for Redis\n[https://redis.io/clients#python]  than you could need.\n\nFinally, how could we ever forget Flask-Redis? We’ve already covered this\n[https://hackersandslackers.com/demystifying-flasks-application-context/], but\nis easily the first and last Redis library any Flask developer will use.\n\nYour Box, Your Treasure, Your World™\nNow that we’ve uncovered this niche between cached data and stored data, the\npossibilities are endless. The world is your oyster full of things which you may\nor may not choose to shove in your box.\n\nOk, fine. Perhaps this whole concept feels like a bit of an obscure niche hardly\nworthy of the words on this page. Just remember that feeling when the time comes\nthat you too need a little red cube, and it will be waiting with love and\ncompassion. A companion cube, if you will.","html":"<p>We’re hacking into the new year here at Hackers and Slackers, and in the process, we’ve received plenty of new gifts to play with. Nevermind how Santa manages to fit physically non-existent SaaS products under the Christmas tree. We ask for abstract enterprise software every year, and this time we happened to get a little red box.</p><p>If you've never personally used Redis, the name probably sounds familiar as you've been bombarded with obscure technology brand names in places like the Heroku marketplace, or your unacceptably nerdy Twitter account (I assure you, mine is worse). So what is Redis, you ask? Well, it's a NoSQL datasto- wait, where are you... NO! Don't leave! It's not like THAT, I swear!</p><h2 id=\"what-redis-is-and-when-to-use-it\">What Redis is and When to Use It</h2><p>Redis stores information in the familiar key/value pair format, but the term ‘NoSQL’ is more of a technicality than an indicator of use cases synonymous with NoSQL databases of the past. Redis looks the part for the very purpose it serves: a box that you fill with crap which may or may not be important down the line. It’s the perfect place to put a Starbucks gift card or the clothes you’ve already worn which aren’t quite ready to be washed yet.</p><h3 id=\"all-users-go-to-heaven-cloud-storage-for-user-sessions\">All Users go to Heaven: Cloud Storage for User Sessions</h3><p>Perhaps the most common use case is a glorified <strong>session cache</strong>. Similar to the way users might store temporary app information in cookies, Redis holds on to information which is fleeting. The difference is we now own this information inside our very own box, thus the Redis motto: “<em>your box, your rules</em>.”* </p><!--kg-card-begin: html--><span style=\"color:#9DA0A0;font-style:italic;margin-bottom:30px;display:block;text-align:right;width:100%;\">* I made this up: it holds zero truth.</span><!--kg-card-end: html--><p>Because temporary user information is in our hands as opposed to a fickle browser, we can decide just <em>how</em> temporary our “cache” is, having it persist across sessions or even devices. While local memory storage may as well be a place for throwaway information, and databases for persistent or eternal information, Redis is somewhere in between. As users interact and the information they create within our app evolves, we may choose at any point to promote information stored in Redis to a database, or perhaps have it stick around a little while longer. They’ll be thrilled to see their shopping cart still filled with the stupid things they almost bought while they were drunk yesterday.</p><h3 id=\"when-variables-are-on-a-bagel-you-can-have-variables-any-time\">When Variables are on a Bagel, You can Have Variables Any Time </h3><p>In other words, Redis is great for solving the need of globally accessible variables throughout an entire application, on a per-user basis. Users who accidentally quit your app, move to a new context, or merely use your app for longer than your QA team are easier to manage when their temporary information is in a safe and global environment. Compare this to saving a user’s Pac-Man score to a global variable:  the moment an app like Pac-Man crashes or restarts, that session is gone forever. Thus dies another three-letter app obscenity belonging to a leaderboard.</p><h3 id=\"speaking-of-leaderboards-\">Speaking of Leaderboards...</h3><p>Redis is great at counting in increments. This is probably made evident by the fact that it is a computer, and these are the things computers do. Something else that’s made great by counting: queues! Cues of tasks, notifications, chats, disappearing naked photos, etc: all of these things are ideally suited for our red box.</p><h2 id=\"getting-a-red-box-of-your-own\">Getting a Red Box of Your Own</h2><p>Playing around with a cloud-hosted Redis box will cost you maybe 5 bucks (monthly if you forget to cancel). Redis is open source so there are plenty of vendors to choose from with little differentiation between them. I’ll consider recommending whichever vendor offers to bribe me the most, but in the meantime I’ll leave the window shopping to you.</p><p>Setting up Redis should feel like setting up a cloud SQL database, except smaller and cuter. You’ll be able to pick adorable features for your box of possibly-but-not-surely-worthless stuff, such as hosted region, etc. Once you're set up you should have a host URL for reaching your instance:</p><!--kg-card-begin: code--><pre><code>redis-1738.c62.us-east-1-4.ec2.cloud.fakeredisprovider.com:42069</code></pre><!--kg-card-end: code--><p>Now we’re cooking with gas.</p><h2 id=\"using-the-redis-py-python-library\">Using the redis-py Python Library</h2><p>The main Python Redis library is typed as <code>redis</code>, as in <code>pip install Redis</code>. The easiest way to connect in any case is via a URI connection string, like such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">r = redis.Redis( url='rediss://:password@hostname:port/0')\n</code></pre>\n<!--kg-card-end: markdown--><p>Note the unique structure of the URI above:</p><ul><li><strong>rediss://: </strong>precedes all Redis URIs; <em>NOTE THE TRAILING COLON.</em></li><li><strong>password</strong> comes next, with the interesting choice to bypass usernames.</li><li><strong>hostname</strong> is the instance's URL... almost always a thinly veiled repurposed EC2 instance. That's right, we're being sold simple open source software hosted on AWS. Don't think about it.</li><li><strong>port </strong>is your preferred port of call after pillaging British trade ships. Just making sure you're still here.</li><li><strong>/database </strong>brings up the rear, which is the name of your database.</li></ul><p>As with regular databases, other connection methods exist such as via SSL certificates, etc.</p><h3 id=\"storing-and-getting-values\">Storing and Getting Values</h3><p>This is your bread and butter for interacting with Redis:</p><ul><li><strong>.set():</strong> Set a key/value pair by either overwriting or creating a new value</li><li><strong>.get():</strong> Retrieve a value by naming the associated key</li><li><strong>hmget():</strong> Accepts a variable number of keys, and will return values for each if they exist</li><li><strong>hmset():</strong> Set multiple values to a single key.</li><li><strong>hgetall():</strong> Get all values for a key where a key has been assigned multiple values.</li></ul><p>It’s important to note that Redis by default returns bytes as opposed to strings. As a result, it is important to remember the encoding/decoding of values in order to retrieve them properly. For example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># Setting a Value\nr.set('uri', str(app.config['SQLALCHEMY_DATABASE_URI']).encode('utf-8'))\n\n# Getting a Value\nr.get('uri').decode('utf-8')\n</code></pre>\n<!--kg-card-end: markdown--><p>If you happen to be remotely sane, you probably don't want to deal with encoding and decoding values over and again. Luckily we can ensure that responses are always decoded for us by setting the <code>decode_responses</code> parameter to <code>True</code> when setting up our Redis instance:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">redis.StrictRedis(host=&quot;localhost&quot;, port=6379, charset=&quot;utf-8&quot;, decode_responses=True)\n</code></pre>\n<!--kg-card-end: markdown--><p>The <a href=\"https://redis-py.readthedocs.io/en/latest/\" rel=\"noopener\"><strong>redis-py</strong> documentation</a> actually goes wayyy deeper than the 5 methods listed above. If you ever somehow manage to cover all of it, I have many questions about the type of person you are.</p><h2 id=\"more-redis-libraries-for-python\">More Redis Libraries for Python</h2><p>If the above encoding/decoding seems annoying, you aren’t the first. That’s why libraries like <a href=\"https://github.com/seperman/redisworks\" rel=\"noopener\"><strong>Redisworks</strong></a> exist. Redisworks allows for the seamless exchange of Python data types to and from Redis. Want to shove a Python dict down your box’s throat? Go ahead! You won’t even have to think about it very hard. There are plenty of similar libraries all aimed to make sad lives easier.</p><p>Want more? How about Asyncio’s very own <a href=\"https://asyncio-redis.readthedocs.io/en/latest/\">asynchronous Redis library</a>?  Or how about the similar <strong><a href=\"aioredis.readthedocs.org\">aioredis</a></strong>, another Asyncio Redis plug-in, which also includes pure Python parsing, clustering support, and things I don’t even understand! There are truly <a href=\"https://redis.io/clients#python\">more Python libraries for Redis</a> than you could need.</p><p>Finally, how could we ever forget <strong>Flask-Redis</strong>? We’ve <a href=\"https://hackersandslackers.com/demystifying-flasks-application-context/\" rel=\"noopener\">already covered this</a>, but is easily the first and last Redis library any Flask developer will use.</p><h2 id=\"your-box-your-treasure-your-world-\">Your Box, Your Treasure, Your World<strong>™</strong></h2><p>Now that we’ve uncovered this niche between cached data and stored data, the possibilities are endless. The world is your oyster full of things which you may or may not choose to shove in your box.</p><p>Ok, fine. Perhaps this whole concept feels like a bit of an obscure niche hardly worthy of the words on this page. Just remember that feeling when the time comes that you too need a little red cube, and it will be waiting with love and compassion. A companion cube, if you will.</p>","url":"https://hackersandslackers.com/using-redis-with-python/","uuid":"fcf41325-f7d3-4f3f-b43f-8609e5dc6b07","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c307c9493bed0776a0a3d80"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736c9","title":"MongoDB Stitch Serverless Functions","slug":"mongodb-stitch-serverless-functions","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/08/stitch3@2x.jpg","excerpt":"A crash course in MongoDB Stitch serverless functions: the bread and butter of MongoDB Cloud.","custom_excerpt":"A crash course in MongoDB Stitch serverless functions: the bread and butter of MongoDB Cloud.","created_at_pretty":"06 August, 2018","published_at_pretty":"26 November, 2018","updated_at_pretty":"05 April, 2019","created_at":"2018-08-06T19:35:37.000-04:00","published_at":"2018-11-26T08:00:00.000-05:00","updated_at":"2019-04-04T21:42:58.000-04:00","meta_title":"Using Serverless Functions in MongoDB Stitch  | Hackers And Slackers","meta_description":"You have a database, and you want to get data out of it. MongoDB Stitch can achieve this without building an API and can do it securely via frontend code.","og_description":"A crash course in MongoDB Stitch serverless functions: the bread and butter of MongoDB Cloud.\n","og_image":"https://hackersandslackers.com/content/images/2018/08/stitch3@2x.jpg","og_title":"MongoDB Stitch Serverless Functions","twitter_description":"A crash course in MongoDB Stitch serverless functions: the bread and butter of MongoDB Cloud.\n","twitter_image":"https://hackersandslackers.com/content/images/2018/08/stitch3@2x.jpg","twitter_title":"MongoDB Stitch Serverless Functions","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"NoSQL","slug":"nosql","description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","feature_image":null,"meta_description":"Schemaless data for gunslingers. Heavily focused on databases such as MongoDB, as well as hosting said databases as cloud instances.","meta_title":"NoSQL | Hackers and Slackers","visibility":"public"},{"name":"Frontend","slug":"frontend","description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","feature_image":null,"meta_description":"Frontend Javascript Logic typically assisted by Babel and Webpack. Primarily focused on fundamentals, as opposed to bandwagon frameworks.","meta_title":"Frontend Development | Hackers and Slackers","visibility":"public"},{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#MongoDB Cloud","slug":"mongodb-cloud","description":"All you need to know about MongoDB’s official cloud offering. Dive into MongoDB Atlas, or the architecture & microservices provided by MongoDB Stitch.","feature_image":"https://hackersandslackers.com/content/images/2019/03/mongodbcloudseries.jpg","meta_description":"All you need to know about MongoDB’s official cloud offering. Dive into MongoDB Atlas, or the architecture & microservices provided by MongoDB Stitch.","meta_title":"MongoDB Cloud","visibility":"internal"}],"plaintext":"At times, I've found my opinion of MongoDB Atlas  and MongoDB Stitch  to waver\nbetween two extremes. Sometimes I'm struck by the allure of a cloud which\nfundamentally disregards schemas (wooo no schema party!). Other times, such as\nwhen Mongo decides to upgrade to a new version and you find all your production\ninstances broken, I like the ecosystem a bit less. \n\nMy biggest qualm with MongoDB is poor documentation. The \"tutorials\" and sample\ncode seems hacked-together, unmaintained, and worst of all, inconsistent with\nitself. Reading through the docs seems to always end up with Mongo forcing\nTwilio down my throat my for some miserable reason. \n\nJust to illustrate how bad things can get, below are two totally sets of\ndocumentation for what is supposed to be the same product. Mongo's main\ndocumentation on the left frequently references the bastardized documentation on\nthe right. What is the documentation on the right? It's a collection of\nnonsense\nliving on an S3 bucket\n[https://s3.amazonaws.com/stitch-sdks/js/docs/4.0.0/index.html]  which lists the\nmethods black-boxed into Stitch, often with zero explanation on how to actually\nutilize functionality.\n\nWhich one is real? And WHY?!How frustrating is this? I've had email user\nauthentication \"working\" for weeks as far as Stitch's logs say, although not a\nsingle user has actually been registered in that time. Anyways, I digress.\n\nMaking a Serverless Function\nStitch Serverless functions are of course strictly Javascript (MongoDB abides by\nECMA2015 features). In your Stitch console, check out the \"functions\" link in\nthe left hand nav:\n\nGo ahead and create a new function.There are just a few things we need to\nspecify when creating a new function:\n\n * The name of the function (duh).\n * Whether or not the function can be accessed \"publicly\". A \"Private\" function\n   is the equivalent of a function that only accessible to the VPC it belongs to\n   (although technically MongoDB Cloud doesn't use this terminology).\n * A condition which needs to be met in order for the function to execute.\n\nHere's a screenshot of everything we just went over. Because whatever.Switch\nover to the function editor to start really F*&king Sh!t up.\n\nMongo's Serverless Function Editor\nWe can call a Serverless function in a number of ways, with one of those ways\nbeing directly from our frontend code. In this case, we're basically just taking\na Javascript function which could  live in our frontend codebase and moving it\nto the cloud, thus functions can be passed any number of arguments (just like a\nnormal function).\n\nLuckily for us, Mongo provides some commented out boilerplate code when creating\na new function, which gives us an idea of what we might want to use these\nfunctions for:\n\nexports = function(arg){\n  /*\n    Accessing application's values:\n    var x = context.values.get(\"value_name\");\n\n    Accessing a mongodb service:\n    var collection = context.services.get(\"mongodb-atlas\").db(\"dbname\").collection(\"coll_name\");\n    var doc = collection.findOne({owner_id: context.user.id});\n\n    To call other named functions:\n    var result = context.functions.execute(\"function_name\", arg1, arg2);\n\n    Try running in the console below.\n  */\n  return {arg: arg};\n};\n\n\nPay special attention to context.services  here. When using a serverless\nfunction to access MongoDB services such as our database or endpoints, we can\naccess these via context.services  along with whichever service we're trying to\nmess with.\n\nQuerying our Database Within a Function\nLet's grab a single record from a collection in our Atlas collection:\n\nexports = function(arg){\n      const mongodb = context.services.get(\"mongodb-atlas\");\n      const collection = mongodb.db(\"blog\").collection(\"authors\");\n      var result = collection.findOne({\"author\": arg});\n      return result;\n};\n\n\nWe use findOne here to return an object, whereas we'd probably use toArray  if\nwe'd be expecting multiple results. The query we're running is contained within \nfindOne({\"author\": arg}). Our function takes an argument and returns a record\nwhere the value matches the argument: this makes our functions highly reusable,\nof course.\n\nCalling Our Function via Our App\nAs a recap, you have the option of including Stitch in your app either via a\nlink to a script or by installing the appropriate NPM modules. It's preferable\nto do the latter, but for the sake of this post, my patience with dealing with\nJavascript's babel browserify webpack gulp yarn npm requires package-lock .env\npipify facepunch  ecosystem has reached its limit. \n\nFeel free to follow in my footsteps of worst practices by embedding stitch\ndirectly:\n\n<script src=\"https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js\"></script>\n\n\nAuthenticating Before Calling Functions\nBefore making queries or interacting with any serverless functions of any kind,\nwe need to authenticate a 'user' with the server; even if that user is an\nanonymous one (it's in our own best benefit to know which user crashed the\nserver, even if that 'users' is a random string of numbers). Because we allowed\nanonymous users to peruse through our data, this is easy:\n\n// Authenticates anonymous user\nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user => {\n  console.log('logged in anonymously as user')\n});\n\n\nCalling our Function\nNow that that's done, we can call our function immediately after:\n\n// Authenticates anonymous user\nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user => {\n  console.log('logged in anonymously as user')\n});\n\n// Calls function\nclient.callFunction(\"getUsers\", [\"{{author}}\"]).then(result => {\n  console.log(result)\n});\n\n\nOur function is called get users  and we're passing a single parameter of \n{{author}}. Even though one parameter is being passed, we pass parameters as\nlists as Mongo Serverless functions, as these functions are agnostic to what\nmight be coming their way.\n\nUsing Functions to Grab Stored Values\nLet's look at one more use case where calling a Stitch Serverless function might\ncome in handy.\n\nBack in the Stitch UI, check out the \"values\" tab in the left-hand nav. This is\na place where we can store constant values which should accessible through our\napplication, or even a place to retrieve secrets:\n\n2secret4uValues can only be retrieved by functions, and this would be a good\ntime to ensure those particular functions are marked \"private\" For instance, if\nyou have an API call you need to make, It would be best to create a function\nthat handles the logic of that API call, and within that function, invoke\nanother private function whose job it is simply to retrieve the key in question.\nMake sense?  Ah well, you'll figure it out.\n\nMaking a Serverless Function that Does Something\nAnyway, let's apply our knowledge of functions to actually do something. On our\nsite we currently use a third party Medium widget which fetches stories from a\nuser's Medium account. Here's how that would look in its entirety:\n\n<script src=\"https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js\"></script>\n\n<script src=\"https://medium-widget.pixelpoint.io/widget.js\"></script>\n\n<script>\nfunction createMediumCard(medium){\n  console.log('medium= ' + medium);\n  MediumWidget.Init({\n    renderTo: '#medium-widget',\n    params: {\n      \"resource\": 'https://medium.com/' + medium,\n      \"postsPerLine\": 1,\n      \"limit\": 3,\n      \"picture\": \"small\",\n      \"fields\": [\"description\", \"publishAt\"],\n      \"ratio\": \"square\"\n    }\n  })\n  $('#medium').css('display', 'block');\n}\n    \nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user => {\n  console.log('logged in anonymously as user')\n});\n    \nclient.callFunction(\"getUsers\", [\"{{author}}\"]).then(result => {\n  console.log(result)\n});\n</script>\n\n\nNormally, \"resource\": medium,  would actually read the URL of the Medium profile\nwe're trying to embed. However, when you blog on a platform like Ghost which\nonly allows your authors to have either Facebook or Twitter profiles, we need to\nessentially go out of our way to build a second, nonintrusive database to pull\ndata from to add functionality like this. Yeah - I'll have to show you what MY\n\"stack\" looks like for a single blog theme some day. It's ridiculous.\n\nAnyway, that’s all I’ve got for now. I hope these ramblings help you assess\nMongoDB Cloud for yourself. No matter the provider, Enterprise Clouds target fat\nbudgets and are designed to rake in big money. It almost makes you wonder why\nsomebody would pay out of pocket for three of them just to write a stupid blog.","html":"<p>At times, I've found my opinion of <strong>MongoDB Atlas</strong> and <strong>MongoDB Stitch</strong> to waver between two extremes. Sometimes I'm struck by the allure of a cloud which fundamentally disregards schemas (wooo no schema party!). Other times, such as when Mongo decides to upgrade to a new version and you find all your production instances broken, I like the ecosystem a bit less. </p><p><strong>My biggest qualm with MongoDB is poor documentation. </strong>The \"tutorials\" and sample code seems hacked-together, unmaintained, and worst of all, inconsistent with itself. Reading through the docs seems to always end up with Mongo forcing Twilio down my throat my for some miserable reason. </p><p>Just to illustrate how bad things can get, below are two totally sets of documentation for what is supposed to be the same product. Mongo's main documentation on the left frequently references the bastardized documentation on the right. What is the documentation on the right? It's a <a href=\"https://s3.amazonaws.com/stitch-sdks/js/docs/4.0.0/index.html\">collection of nonsense living on an S3 bucket</a> which lists the methods black-boxed into Stitch, often with zero explanation on how to actually utilize functionality.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/mongodocs.jpg\" class=\"kg-image\"><figcaption>Which one is real? And WHY?!</figcaption></figure><!--kg-card-end: image--><p>How frustrating is this? I've had email user authentication \"working\" for weeks as far as Stitch's logs say, although not a single user has actually been registered in that time. Anyways, I digress.</p><h2 id=\"making-a-serverless-function\">Making a Serverless Function</h2><p>Stitch Serverless functions are of course strictly Javascript (MongoDB abides by ECMA2015 features). In your Stitch console, check out the \"functions\" link in the left hand nav:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screen-Shot-2018-11-25-at-10.28.24-PM.png\" class=\"kg-image\"><figcaption>Go ahead and create a new function.</figcaption></figure><!--kg-card-end: image--><p>There are just a few things we need to specify when creating a new function:</p><ul><li>The name of the function (duh).</li><li>Whether or not the function can be accessed \"publicly\". A \"Private\" function is the equivalent of a function that only accessible to the VPC it belongs to (although technically MongoDB Cloud doesn't use this terminology).</li><li>A condition which needs to be met in order for the function to execute.</li></ul><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screen-Shot-2018-11-25-at-10.31.05-PM_o.png\" class=\"kg-image\"><figcaption>Here's a screenshot of everything we just went over. Because whatever.</figcaption></figure><!--kg-card-end: image--><p>Switch over to the function editor to start really F*&amp;king Sh!t up.</p><h2 id=\"mongo-s-serverless-function-editor\">Mongo's Serverless Function Editor</h2><p>We can call a Serverless function in a number of ways, with one of those ways being directly from our frontend code. In this case, we're basically just taking a Javascript function which <em>could</em> live in our frontend codebase and moving it to the cloud, thus functions can be passed any number of arguments (just like a normal function).</p><p>Luckily for us, Mongo provides some commented out boilerplate code when creating a new function, which gives us an idea of what we might want to use these functions for:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">exports = function(arg){\n  /*\n    Accessing application's values:\n    var x = context.values.get(&quot;value_name&quot;);\n\n    Accessing a mongodb service:\n    var collection = context.services.get(&quot;mongodb-atlas&quot;).db(&quot;dbname&quot;).collection(&quot;coll_name&quot;);\n    var doc = collection.findOne({owner_id: context.user.id});\n\n    To call other named functions:\n    var result = context.functions.execute(&quot;function_name&quot;, arg1, arg2);\n\n    Try running in the console below.\n  */\n  return {arg: arg};\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>Pay special attention to <code>context.services</code> here. When using a serverless function to access MongoDB services such as our database or endpoints, we can access these via <code>context.services</code> along with whichever service we're trying to mess with.</p><h3 id=\"querying-our-database-within-a-function\">Querying our Database Within a Function</h3><p>Let's grab a single record from a collection in our Atlas collection:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">exports = function(arg){\n      const mongodb = context.services.get(&quot;mongodb-atlas&quot;);\n      const collection = mongodb.db(&quot;blog&quot;).collection(&quot;authors&quot;);\n      var result = collection.findOne({&quot;author&quot;: arg});\n      return result;\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>We use <strong>findOne </strong>here to return an object, whereas we'd probably use <strong>toArray</strong> if we'd be expecting multiple results. The query we're running is contained within <code>findOne({\"author\": arg})</code>. Our function takes an argument and returns a record where the value matches the argument: this makes our functions highly reusable, of course.</p><h2 id=\"calling-our-function-via-our-app\">Calling Our Function via Our App</h2><p>As a recap, you have the option of including Stitch in your app either via a link to a script or by installing the appropriate NPM modules. It's preferable to do the latter, but for the sake of this post, my patience with dealing with Javascript's <strong>babel browserify webpack gulp yarn npm requires package-lock .env pipify facepunch</strong> ecosystem has reached its limit. </p><p>Feel free to follow in my footsteps of worst practices by embedding stitch directly:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">&lt;script src=&quot;https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"authenticating-before-calling-functions\">Authenticating Before Calling Functions</h3><p>Before making queries or interacting with any serverless functions of any kind, we need to authenticate a 'user' with the server; even if that user is an anonymous one (it's in our own best benefit to know which user crashed the server, even if that 'users' is a random string of numbers). Because we allowed anonymous users to peruse through our data, this is easy:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">// Authenticates anonymous user\nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user =&gt; {\n  console.log('logged in anonymously as user')\n});\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"calling-our-function\">Calling our Function</h3><p>Now that that's done, we can call our function immediately after:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">// Authenticates anonymous user\nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user =&gt; {\n  console.log('logged in anonymously as user')\n});\n\n// Calls function\nclient.callFunction(&quot;getUsers&quot;, [&quot;{{author}}&quot;]).then(result =&gt; {\n  console.log(result)\n});\n</code></pre>\n<!--kg-card-end: markdown--><p>Our function is called <code>get users</code> and we're passing a single parameter of <code>{{author}}</code>. Even though one parameter is being passed, we pass parameters as lists as Mongo Serverless functions, as these functions are agnostic to what might be coming their way.</p><h2 id=\"using-functions-to-grab-stored-values\">Using Functions to Grab Stored Values</h2><p>Let's look at one more use case where calling a Stitch Serverless function might come in handy.</p><p>Back in the Stitch UI, check out the \"values\" tab in the left-hand nav. This is a place where we can store constant values which should accessible through our application, or even a place to retrieve secrets:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/q_auto/v1/images/Screen-Shot-2018-11-26-at-8.04.25-AM_o.png\" class=\"kg-image\"><figcaption>2secret4u</figcaption></figure><!--kg-card-end: image--><p>Values can only be retrieved by functions, and this would be a good time to ensure those particular functions are marked \"private\" For instance, if you have an API call you need to make, It would be best to create a function that handles the logic of that API call, and within that function, invoke another private function whose job it is simply to retrieve the key in question. Make sense?  Ah well, you'll figure it out.</p><h2 id=\"making-a-serverless-function-that-does-something\">Making a Serverless Function that Does Something</h2><p>Anyway, let's apply our knowledge of functions to actually do something. On our site we currently use a third party Medium widget which fetches stories from a user's Medium account. Here's how that would look in its entirety:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">&lt;script src=&quot;https://s3.amazonaws.com/stitch-sdks/js/bundles/4.0.8/stitch.js&quot;&gt;&lt;/script&gt;\n\n&lt;script src=&quot;https://medium-widget.pixelpoint.io/widget.js&quot;&gt;&lt;/script&gt;\n\n&lt;script&gt;\nfunction createMediumCard(medium){\n  console.log('medium= ' + medium);\n  MediumWidget.Init({\n    renderTo: '#medium-widget',\n    params: {\n      &quot;resource&quot;: 'https://medium.com/' + medium,\n      &quot;postsPerLine&quot;: 1,\n      &quot;limit&quot;: 3,\n      &quot;picture&quot;: &quot;small&quot;,\n      &quot;fields&quot;: [&quot;description&quot;, &quot;publishAt&quot;],\n      &quot;ratio&quot;: &quot;square&quot;\n    }\n  })\n  $('#medium').css('display', 'block');\n}\n    \nclient.auth.loginWithCredential(new stitch.AnonymousCredential()).then(user =&gt; {\n  console.log('logged in anonymously as user')\n});\n    \nclient.callFunction(&quot;getUsers&quot;, [&quot;{{author}}&quot;]).then(result =&gt; {\n  console.log(result)\n});\n&lt;/script&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Normally, <code>\"resource\": medium,</code> would actually read the URL of the Medium profile we're trying to embed. However, when you blog on a platform like Ghost which only allows your authors to have either Facebook or Twitter profiles, we need to essentially go out of our way to build a second, nonintrusive database to pull data from to add functionality like this. Yeah - I'll have to show you what MY \"stack\" looks like for a single blog theme some day. It's ridiculous.</p><p>Anyway, that’s all I’ve got for now. I hope these ramblings help you assess MongoDB Cloud for yourself. No matter the provider, Enterprise Clouds target fat budgets and are designed to rake in big money. It almost makes you wonder why somebody would pay out of pocket for three of them just to write a stupid blog.</p>","url":"https://hackersandslackers.com/mongodb-stitch-serverless-functions/","uuid":"96e26ca1-02d4-41d6-afa8-db92b2e9c171","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b68db4904d65d1246ebd1eb"}}]}},"pageContext":{"slug":"dataengineering","limit":12,"skip":0,"numberOfPages":2,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":2,"previousPagePath":null,"nextPagePath":"/tag/dataengineering/page/2/"}}