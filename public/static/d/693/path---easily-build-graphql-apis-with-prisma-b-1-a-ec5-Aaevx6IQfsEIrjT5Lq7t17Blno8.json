{"data":{"ghostPost":{"id":"Ghost__Post__5c570ae30b20340296f57709","title":"Easily Build GraphQL APIs with Prisma","slug":"easily-build-graphql-apis-with-prisma","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","excerpt":"Jump on the GraphQL Bandwagon with a little help from Prisma.","custom_excerpt":"Jump on the GraphQL Bandwagon with a little help from Prisma.","created_at_pretty":"03 February, 2019","published_at_pretty":"03 February, 2019","updated_at_pretty":"29 March, 2019","created_at":"2019-02-03T10:38:11.000-05:00","published_at":"2019-02-03T16:33:15.000-05:00","updated_at":"2019-03-29T14:47:01.000-04:00","meta_title":"Build GraphQL APIs with Prisma | Hackers and Slackers","meta_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","og_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","og_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","og_title":"Build GraphQL APIs with Prisma","twitter_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","twitter_title":"Build GraphQL APIs with Prisma","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"SaaS Products","slug":"saas","description":"Third-party products and services we’ve discovered to be diamonds in the rough. These are products we’ve included in our stack based on price and value add.","feature_image":null,"meta_description":"Third-party products and services we’ve discovered to be diamonds in the rough. These are products we’ve included in our stack based on price and value add.","meta_title":"Our Picks: SaaS Products | Hackers and Slackers","visibility":"public"},{"name":"Architecture","slug":"architecture","description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to Lambda functions, Docker containers, Google Cloud functions,  Kubernetes, Heroku, etc.","feature_image":null,"meta_description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to cloud functions, Docker containers, Kubernetes, Heroku, etc.","meta_title":"Software Architecture | Hackers and Slackers","visibility":"public"},{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"The technology sector is reeling after an official statement was released by the\nUN's International Council of Coolness last week. The statement clearly states\nwhat status-quo developers have feared for months: if you haven't shifted from\nREST to GraphQL by now, you are officially recognized by the international\ncommunity to hold \"uncool\" status. A humanitarian crisis is already unfolding as\nrefugees of coolness are threatening to overtake borders, sparking fears of an\ninflux of Thinkpad Laptops, IntelliJ, and other Class A  uncool narcotics.\n\nHold up: is GraphQL That Dramatic of an Improvement over REST?\nIn all honesty, I've found that the only way to properly answer this question is\nto first utter \"kinda,\" then mull back and forth for a little while, and then\nfinishing with a weak statement like \"so pretty much, yeah.\"\n\nLet’s put it this way. When you’re first familiarizing yourself with a set of\ndata, what do you do? Do you read extensive documentation about the SQL table\nyou’re about to check out? Do you read the entire spec for your version\nPostgreSQL to see if it contains the functionality that might be missing for\nsome reason? I’m going to guess you do neither of these- chances are you just\nlook at the data. \n\nUsing any REST API is inherently a context-switch. No matter how many APIs\nyou’ve worked with in the past, you’ll never be able to know a new API’s\nendpoints, quirks, or the awful manner in which the creator has abandoned any\ndistinction between GET, POST, or PUT methods altogether. GraphQL is not\nnecessarily more technologically impressive than REST, but it does  provide us a\nsyntax and workflow comparable to working directly with databases with which\nwe're already familiar.\n\nRemember when us young guys justified replacing older devs when we came out of\nthe gate with NodeJS, arguing that context-switching changes everything? GraphQL\nis just that: a \"better\" technology with less mental context-switching, which\nconveniently serves a double-purpose for enterprises looking to fire anybody\nthey perceive to be dead weight over the age of 30. Good luck finding a better\nsynopsis than that.\n\nWhat’s this Prisma Nonsense? \nPrisma [https://www.prisma.io/]  is a free (FREE!) service that provides with\nthe tools to create an API client, as well as an Admin panel to manage it.\nWithout any prior knowledge of GraphQL needed, Prisma provides us with:\n\n * A CLI which’s stand up a web server which will serve as our API: either cloud\n   or self-hosted.\n * Automatic integration with your database of choice (including cloud DBs, such\n   as RDS).\n * A clever obfuscation of data models via a simple config file. No classes, no\n   code, no bullshit.\n * A \"playground\" interface which allows us to mess around in GraphQL syntax\n   against our models without breaking everything.\n * A web GUI which displays the relationships between all of these things and\n   their usage.\n\nIn short, Prisma does our jobs for us. Now that tasks associated with building\nAPIs, creating ORMs, and managing databases have all been trivialized, we can\nfinally cut some more of that dead weight we mentioned earlier- specifically\nBob, the asshole coming up on his 35th birthday sitting on his high-horse just\nbecause he has an obligation to feed 3 beautiful children. Sorry Bob, it just\nwasn't working out.\n\nPrisma does  provide the option to set up a test environment on their cloud, but\nlet's do something useful with our lives for once and build something\nproduction-ready. In this case, that means standing up a 5-dollar Digital Ocean\nDroplet.\n\nCreate a Prisma Account\nGet over to the sexually appealing Prisma Cloud landing page\n[https://www.prisma.io/cloud]  and make yourself an account. When prompted, make\nsure you select Deploy a new Prisma Service.\n\nExample services are for sissys.You should then be prompted with the following\nscreen. It will instruct you to install an NPM package, but there are a few\nthings we need to do first.\n\nWhen she says \"waiting for login,\" she means \"I'd wait a lifetime for you, my\nlove.\"Installing Prisma Dependencies on a Fresh VPS\nSSH into whichever VPS you've chosen. I'll be using a Ubuntu instance for this\ntutorial. If you happen to be using Ubuntu as well, feel free to copy + paste\nall the stuff I'm sure you've done a million times already. First, we need to\ninstall Node:\n\n$ apt update\n$ apt upgrade -y\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n$ sudo apt-get install -y nodejs\n$ sudo apt-get install gcc g++ make\n$ sudo npm install -g npm@latest\n\n\nBefore you do anything crazy like copy & paste those two lines from Prisma,\nyou're going to need to set up Docker a few steps later, so you might as well do\nthat now: \n\n1. Install Docker Dependencies\n$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n\n\n2. Add Docker Key\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n$ sudo apt-key fingerprint 0EBFCD88\n\n\n3. Get Docker Repository\n$ sudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\n\n4. Finally Install Docker\n$ sudo apt-get update\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\nGood job, you're doing great.\n\nInstall & Activate The Prisma CLI\nCool, now we can carry on with Prisma's demands. Install the Prisma CLI\nglobally, and then use said CLI to log in to Prisma.\n\n$ npm install -g prisma\n$ prisma login -k eyJhbGciGYU78tfuyLALALTHISKEYISFAKELOL69KFGs\n\n\nWait a couple of seconds after entering the login prompt, and you'll notice your\nbrowser window will have changed to indicate that you're now logged in. \n\nThe next step will create the local files which serve as the heart and soul of\nour API. Make sure you init Prisma  in whichever directory you like to keep\nthings in:\n\n$ cd /my/desired/directory/\n$ prisma init my-prisma\n\n\nInitiating the project will kickstart a quick and painless interrogation\nprocess. Keep in mind that it's recommended to use Prisma with a fresh database\ninstance; in my case, I spun up a cloud PostgreSQL instance.\n\n? Set up a new Prisma server or deploy to an existing server? Use existing database\n? What kind of database do you want to deploy to?:\n? Does your database contain existing data?:\n? Enter database host:\n? Enter database port:\n? Enter database user:\n? Enter database password: \n? Enter database name (the database includes the schema):\n? Use SSL?:\n\n\nCompleting this will result in the following structure:\n\nmy-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n\n\nWe're almost there cowboy and/or cowgirl. \n\nSet Phasers to \"Deploy\"\nPrisma is going to stand itself up on port 4466, which is closed by default on\nmost servers. Make sure you have this port open:\n\n$ ufw allow 4466\n\n\nFinally, we need to set a secret  in order to connect to Prisma cloud. Open the \ndocker-compose.yml  file and uncomment the managementApiSecret  line. Replace\nthe value with some sort of deep dark personal secret of yours.\n\n$ vim docker-compose.yml\n\n\nversion: '3'\nservices:\n  prisma:\n    image: prismagraphql/prisma:1.25\n    restart: always\n    ports:\n    - \"4466:4466\"\n    environment:\n      PRISMA_CONFIG: |\n        port: 4466\n        # uncomment the next line and provide the env var \n        managementApiSecret: my-secret\n        databases:\n          default:\n            connector: postgres\n            host: 123.45.678.90\n            database: databasename\n            user: username\n            password: password\n            rawAccess: true\n            port: '5432'\n            migrations: true\n\n\n\nFor some reason, Prisma does not automatically specify your SSL preferences in\ndocker-compose, even if you explicity answer \"yes\" to the SSL prompt. If your\ndatabase requires SSL, be sure to add ssl: true  to the end of your\ndocker-compose config. Otherwise, your deployment will fail.As per the comment\nin our yml  file, we need to export the secret we specify with \nmanagementApiSecret: my-secret  as an environment variable. Back in your Prisma\ndirectory, export your secret as such:\n\n$ export PRISMA_MANAGEMENT_API_SECRET=my-secret\n\n\nThis secret is used to generate a token to secure our endpoint. Skipping this\nstep would result in exposing your database to the world with full read/write\naccess to anybody.\n\nIt's Game Time\nIt's time to deploy, baby! Do it, push the button! DO IT NOW!\n\n$ docker-compose up -d\n$ prisma deploy\n\n\nDeploying for the first time does a few things. It'll stand up a 'playground'\ninterface on your local server (localhost:4466), as well as automatically get\nyou set up with Prisma Cloud, which is essentially an admin interface for your\ndeployment hosted on Prisma's site.\n\nCheck Out Your Workspace \nVisit [Your Server's IP]:4466 to see what you've done:\n\nA playground for children of all agesCheck it out! Along with documentation of\nthe generic data models Prisma shipped with, you can test queries or mutations\non the left side of the UI, and receive responses on the right. Sure beats\nPostman imho.\n\nDon't Look Down: You're in the Cloud\nYou can now add your server to Prisma Cloud to get the benefits of their admin\npanel. From here, you can modify information directly, review usage metrics, and\nmanage multiple instances:\n\nBreaking News: Prisma is Too Cool For School.Working With Prisma And GraphQL\nNow that we've spun up this shiny new toy, let's be sure we know how to drive\nit.\n\nOn your VPS, take a look at the datamodels.prisma  file:\n\n$ vim datamodels.prisma\n\n\nYou should see a data model called User (everybody has this model). To add or\nmodify data models, all we need to do is change the fields as we see fit, set\ntheir data type, and specify whether or not we'd like the field to be unique.\nBelow I've added a couple of new 'fields.'\n\ntype User {\n  id: ID! @unique\n  name: String!\n  email: String! @unique\n  gravatar: String!\n}\n\n\nDeploying Prisma again with these changes will modify our database's table\nstructure to match the new model:\n\n$ prisma deploy\n\n\nThere you have it: one more buzzword to put your resum\u001d\u001de. In fact, feel free to\ncompletely falsify the existence of a GraphQL certification and throw that on\nthere, too. If you're the kind of person who enjoys reading technical posts like\nthis in your free time, chances are you're already qualified for the job. Unless\nyou're Bob.","html":"<p>The technology sector is reeling after an official statement was released by the UN's International Council of Coolness last week. The statement clearly states what status-quo developers have feared for months: if you haven't shifted from REST to GraphQL by now, you are officially recognized by the international community to hold \"uncool\" status. A humanitarian crisis is already unfolding as refugees of coolness are threatening to overtake borders, sparking fears of an influx of Thinkpad Laptops, IntelliJ, and other <em>Class A</em> uncool narcotics.</p><h3 id=\"hold-up-is-graphql-that-dramatic-of-an-improvement-over-rest\">Hold up: is GraphQL That Dramatic of an Improvement over REST?</h3><p>In all honesty, I've found that the only way to properly answer this question is to first utter \"kinda,\" then mull back and forth for a little while, and then finishing with a weak statement like \"so pretty much, yeah.\"</p><p>Let’s put it this way. When you’re first familiarizing yourself with a set of data, what do you do? Do you read extensive documentation about the SQL table you’re about to check out? Do you read the entire spec for your version PostgreSQL to see if it contains the functionality that might be missing for some reason? I’m going to guess you do neither of these- chances are you <em>just look at the data. </em></p><p>Using any REST API is inherently a context-switch. No matter how many APIs you’ve worked with in the past, you’ll never be able to know a new API’s endpoints, quirks, or the awful manner in which the creator has abandoned any distinction between GET, POST, or PUT methods altogether. GraphQL is not necessarily more technologically impressive than REST, but it <em>does</em> provide us a syntax and workflow comparable to working directly with databases with which we're already familiar.</p><p>Remember when us young guys justified replacing older devs when we came out of the gate with NodeJS, arguing that context-switching <em>changes everything</em>? GraphQL is just that: a \"better\" technology with less mental context-switching, which conveniently serves a double-purpose for enterprises looking to fire anybody they perceive to be dead weight over the age of 30. Good luck finding a better synopsis than that.</p><h2 id=\"what-s-this-prisma-nonsense\">What’s this Prisma Nonsense? </h2><p><a href=\"https://www.prisma.io/\">Prisma</a> is a free (FREE!) service that provides with the tools to create an API client, as well as an Admin panel to manage it. Without any prior knowledge of GraphQL needed, Prisma provides us with:</p><ul><li>A CLI which’s stand up a web server which will serve as our API: either cloud or self-hosted.</li><li>Automatic integration with your database of choice (including cloud DBs, such as RDS).</li><li>A clever obfuscation of data models via a simple config file. No classes, no code, no bullshit.</li><li>A \"playground\" interface which allows us to mess around in GraphQL syntax against our models without breaking everything.</li><li>A web GUI which displays the relationships between all of these things and their usage.</li></ul><p>In short, Prisma does our jobs for us. Now that tasks associated with building APIs, creating ORMs, and managing databases have all been trivialized, we can finally cut some more of that dead weight we mentioned earlier- specifically Bob, the asshole coming up on his 35th birthday sitting on his high-horse just because he has an obligation to feed 3 beautiful children. Sorry Bob, it just wasn't working out.</p><p>Prisma <em>does</em> provide the option to set up a test environment on their cloud, but let's do something useful with our lives for once and build something production-ready. In this case, that means standing up a 5-dollar Digital Ocean Droplet.</p><h3 id=\"create-a-prisma-account\">Create a Prisma Account</h3><p>Get over to the sexually appealing <a href=\"https://www.prisma.io/cloud\">Prisma Cloud landing page</a> and make yourself an account. When prompted, make sure you select <strong>Deploy a new Prisma Service</strong>.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prisma-step1.png\" class=\"kg-image\"><figcaption>Example services are for sissys.</figcaption></figure><!--kg-card-end: image--><p>You should then be prompted with the following screen. It will instruct you to install an NPM package, but there are a few things we need to do first.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prisma-step2.png\" class=\"kg-image\"><figcaption>When she says \"waiting for login,\" she means \"I'd wait a lifetime for you, my love.\"</figcaption></figure><!--kg-card-end: image--><h2 id=\"installing-prisma-dependencies-on-a-fresh-vps\">Installing Prisma Dependencies on a Fresh VPS</h2><p>SSH into whichever VPS you've chosen. I'll be using a Ubuntu instance for this tutorial. If you happen to be using Ubuntu as well, feel free to copy + paste all the stuff I'm sure you've done a million times already. First, we need to install Node:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ apt update\n$ apt upgrade -y\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n$ sudo apt-get install -y nodejs\n$ sudo apt-get install gcc g++ make\n$ sudo npm install -g npm@latest\n</code></pre>\n<!--kg-card-end: markdown--><p>Before you do anything crazy like copy &amp; paste those two lines from Prisma, you're going to need to set up Docker a few steps later, so you might as well do that now: </p><h3 id=\"1-install-docker-dependencies\">1. Install Docker Dependencies</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"2-add-docker-key\">2. Add Docker Key</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n$ sudo apt-key fingerprint 0EBFCD88\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"3-get-docker-repository\">3. Get Docker Repository</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"4-finally-install-docker\">4. Finally Install Docker</h3><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ sudo apt-get update\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n</code></pre>\n<!--kg-card-end: markdown--><p>Good job, you're doing great.</p><h2 id=\"install-activate-the-prisma-cli\">Install &amp; Activate The Prisma CLI</h2><p>Cool, now we can carry on with Prisma's demands. Install the Prisma CLI globally, and then use said CLI to log in to Prisma.  </p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ npm install -g prisma\n$ prisma login -k eyJhbGciGYU78tfuyLALALTHISKEYISFAKELOL69KFGs\n</code></pre>\n<!--kg-card-end: markdown--><p>Wait a couple of seconds after entering the login prompt, and you'll notice your browser window will have changed to indicate that you're now logged in. </p><p>The next step will create the local files which serve as the heart and soul of our API. Make sure you init <code>Prisma</code> in whichever directory you like to keep things in:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ cd /my/desired/directory/\n$ prisma init my-prisma\n</code></pre>\n<!--kg-card-end: markdown--><p>Initiating the project will kickstart a quick and painless interrogation process. Keep in mind that it's recommended to use Prisma with a fresh database instance; in my case, I spun up a cloud PostgreSQL instance.</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">? Set up a new Prisma server or deploy to an existing server? Use existing database\n? What kind of database do you want to deploy to?:\n? Does your database contain existing data?:\n? Enter database host:\n? Enter database port:\n? Enter database user:\n? Enter database password: \n? Enter database name (the database includes the schema):\n? Use SSL?:\n</code></pre>\n<!--kg-card-end: markdown--><p>Completing this will result in the following structure:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">my-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n</code></pre>\n<!--kg-card-end: markdown--><p>We're almost there cowboy and/or cowgirl. </p><h2 id=\"set-phasers-to-deploy\">Set Phasers to \"Deploy\"</h2><p>Prisma is going to stand itself up on port <strong>4466</strong>, which is closed by default on most servers. Make sure you have this port open:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ ufw allow 4466\n</code></pre>\n<!--kg-card-end: markdown--><p>Finally, we need to set a <em>secret</em> in order to connect to Prisma cloud. Open the <code>docker-compose.yml</code> file and uncomment the <code>managementApiSecret</code> line. Replace the value with some sort of deep dark personal secret of yours.</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ vim docker-compose.yml\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">version: '3'\nservices:\n  prisma:\n    image: prismagraphql/prisma:1.25\n    restart: always\n    ports:\n    - &quot;4466:4466&quot;\n    environment:\n      PRISMA_CONFIG: |\n        port: 4466\n        # uncomment the next line and provide the env var \n        managementApiSecret: my-secret\n        databases:\n          default:\n            connector: postgres\n            host: 123.45.678.90\n            database: databasename\n            user: username\n            password: password\n            rawAccess: true\n            port: '5432'\n            migrations: true\n\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: html--><div class=\"proptip\">\nFor some reason, Prisma does not automatically specify your SSL preferences in docker-compose, even if you explicity answer \"yes\" to the SSL prompt. If your database requires SSL, be sure to add <code>ssl: true</code> to the end of your docker-compose config. Otherwise, your deployment will fail. \n</div><!--kg-card-end: html--><p>As per the comment in our <code>yml</code> file, we need to export the secret we specify with <code>managementApiSecret: my-secret</code> as an environment variable. Back in your Prisma directory, export your secret as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ export PRISMA_MANAGEMENT_API_SECRET=my-secret\n</code></pre>\n<!--kg-card-end: markdown--><p>This secret is used to generate a token to secure our endpoint. Skipping this step would result in exposing your database to the world with full read/write access to anybody.</p><h2 id=\"it-s-game-time\">It's Game Time</h2><p>It's time to deploy, baby! Do it, push the button! DO IT NOW!</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ docker-compose up -d\n$ prisma deploy\n</code></pre>\n<!--kg-card-end: markdown--><p>Deploying for the first time does a few things. It'll stand up a 'playground' interface on your local server (localhost:4466), as well as automatically get you set up with Prisma Cloud, which is essentially an admin interface for your deployment hosted on Prisma's site.</p><h3 id=\"check-out-your-workspace\">Check Out Your Workspace </h3><p>Visit [Your Server's IP]:4466 to see what you've done:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/playground.png\" class=\"kg-image\"><figcaption>A playground for children of all ages</figcaption></figure><!--kg-card-end: image--><p>Check it out! Along with documentation of the generic data models Prisma shipped with, you can test queries or mutations on the left side of the UI, and receive responses on the right. Sure beats Postman imho.</p><h3 id=\"don-t-look-down-you-re-in-the-cloud\">Don't Look Down: You're in the Cloud</h3><p>You can now add your server to Prisma Cloud to get the benefits of their admin panel. From here, you can modify information directly, review usage metrics, and manage multiple instances:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prismacloud.gif\" class=\"kg-image\"><figcaption>Breaking News: Prisma is Too Cool For School.</figcaption></figure><!--kg-card-end: image--><h2 id=\"working-with-prisma-and-graphql\">Working With Prisma And GraphQL</h2><p>Now that we've spun up this shiny new toy, let's be sure we know how to drive it.</p><p>On your VPS, take a look at the <code>datamodels.prisma</code> file:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ vim datamodels.prisma\n</code></pre>\n<!--kg-card-end: markdown--><p>You should see a data model called User (everybody has this model). To add or modify data models, all we need to do is change the fields as we see fit, set their data type, and specify whether or not we'd like the field to be unique. Below I've added a couple of new 'fields.'</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">type User {\n  id: ID! @unique\n  name: String!\n  email: String! @unique\n  gravatar: String!\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Deploying Prisma again with these changes will modify our database's table structure to match the new model:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ prisma deploy\n</code></pre>\n<!--kg-card-end: markdown--><p>There you have it: one more buzzword to put your resum\u001d\u001de. In fact, feel free to completely falsify the existence of a GraphQL certification and throw that on there, too. If you're the kind of person who enjoys reading technical posts like this in your free time, chances are you're already qualified for the job. Unless you're Bob.</p>","url":"https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/","uuid":"86286c72-478c-4108-8bef-89ca01caf043","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c570ae30b20340296f57709"}},"pageContext":{"slug":"easily-build-graphql-apis-with-prisma"}}