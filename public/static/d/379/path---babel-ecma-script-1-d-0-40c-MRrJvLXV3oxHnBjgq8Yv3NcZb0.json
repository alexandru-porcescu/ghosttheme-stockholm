{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb867371a","title":"Compile Frontend JavaScript with Babel and Gulp","slug":"babel-ecma-script","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/10/babel-1@2x.jpg","excerpt":"Using ECMAScript functions on the frontend the quick and dirty way.","custom_excerpt":"Using ECMAScript functions on the frontend the quick and dirty way.","created_at_pretty":"04 October, 2018","published_at_pretty":"06 October, 2018","updated_at_pretty":"02 February, 2019","created_at":"2018-10-03T23:05:08.000-04:00","published_at":"2018-10-06T06:20:00.000-04:00","updated_at":"2019-02-02T04:55:50.000-05:00","meta_title":"Frontend JavaScript with Babel | Hackers and Slackers","meta_description":"Babel looks at new ECMA syntax (like require,  const or promise) and compiles code which is logic-equivalent to these features using vanilla Javascript.","og_description":"Babel looks at new ECMA syntax (like require,  const or promise) and compiles code which is logic-equivalent to these features using vanilla Javascript.","og_image":"https://hackersandslackers.com/content/images/2018/10/babel-1@2x.jpg","og_title":"Compile Frontend JavaScript with Babel and Gulp","twitter_description":"Babel looks at new ECMA syntax (like require,  const or promise) and compiles code which is logic-equivalent to these features using vanilla Javascript.","twitter_image":"https://hackersandslackers.com/content/images/2018/10/babel-1@2x.jpg","twitter_title":"Compile Frontend JavaScript with Babel and Gulp","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"},"tags":[{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"},{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"}],"plaintext":"NOTE: This post has not aged particularly well. This is made evident by the\npresence of the word \"Gulp\" present throughout the post.\n\n\n--------------------------------------------------------------------------------\n\nAs you may have already deduced from the occasional glaring holes in my\nprogramming knowledge, I haven’t spent as much of my life programming than,\nwell, anybody who haphazardly threw away an 8-year product management career.\nApparently, a lot can happen in 8 years... especially when it comes to\nJavaScript.\nPutting aside that whole server-side  NodeJS thing or whatever it’s called,\nthere’s years worth of mindfucks for those of us who fairly recently returned to\ndev. In our absence, the world has been Grunting, Gulping, Yarning and even\nNPMing. Let’s assume we’ve gotten past all of that... phew. Oh wait, I forgot to\nmention the monstrosity of “hey by way there’s this mess of a hardly-explained\n(protocol? organization? Fancy Github Repo?) called Babel that we all depend on\nto do meaningful shit in the browser these days.”\n\nIf you’re here because you’re trying to figure what the hell all these ‘const’\nand ‘import’ keywords are doing in modern-day browser JavaScript, consider this\nhalf focus-group and half getting-started tutorial. For the rest of you\nexperienced JS devs out there, perhaps you should stay. No, by all means, I’d\nlike you to sit here and think about the kind of ecosystem you’ve decided to\npatch together. Do it; otherwise, I might just give Kik a call to see what other\ntiny NPM modules they’d like to arbitrarily demand the removal of... remember\nthat? Exactly. Now think about what you’ve done.\n\nECMAScript and the Backwards-Compatible Web\nAny Actionscript veterans in the house? No? Just me? Great. Anyway, There’s\nsomething that ActionScript, JavaScript, and a bunch of Whatever-scripts have in\ncommon: they’re all implementations of ECMAScript: the ancestral equivalent of\ncomparing Latin to Spanish or French, but just one added detail: ECMAScript is\nstill a living language, and constantly improving. If some nation of cool cats\nstill spoke Latin as an active language and were constantly coming up with sick\nnew slang terms, those speaking French or Spanish would be powerless to come up\nwith phrases nearly as cool as “lit” or \"fam\"  (or whatever those Latin\nequivalents would be).\n\nThe problem is web browsers are inherently backward-compatible monstrosities.\nMost revenue-generating companies look at their >5% user base using Internet\nExplorer three and a half, and think “oh my god, that’s five percent of our\npotential revenue” (it isn’t, but whatever). That’s where we stand.\n\nNew features? For the INTERNET?\nI remember one particular weekend I rented a hotel room for the sole purpose of\nwrapping up an app based on MongoDB Stitch at the time. I was pretty confident I\nhad it all figured out, but found, something about Mongo’s quick start guides\nfelt off (I mean, more off than the rest of their nearly unreadable docs). Why\ndid Mongo insist on inline JavaScript? Haven’t we evolved past the days where\nPHP, HTML, CSS, and JS all lived on the same page?\n\nAs everybody-who-wasn’t-me at time already knows, JavaScript has been reaping\nthe benefits of new evolutions in ECMAScript over the years, but there’s a\ncatch: only the most modern browsers know what the hell to do with these new\nfeatures (duh), and they only do so with the dreaded  blocks thrown on HTML\npages. Attempting to use modern ECMA features in a linked JS file which hasn’t\nbeen pre-compiled is like dividing by zero. Seriously, you might die.\n\nBabel to the Rescue\nMore research only lead to more questions. Who is this Browserify wizard\n[http://browserify.org/]  and why is he dead? What is Webpack doing to fund all\ntheir highly produced branding, and why would anybody purchase a Webpack T-shirt\n[https://webpack.threadless.com/]? Finally, the biggest question of all: who the\nhell is this Babel guy who gives off as an electric explosion in your face on\nhard drugs?\n\nI can't even the difference between a compiler and a Marvel franchise anymore.I\nthink it was at this point in my journey of catching up on the last decade where\nI went truly mad and began pacing around my room, verbally assaulting inanimate\nobjects, and eventually even found myself washed up in a Wendys down the street,\nshivering and crying to myself. \n\nNow that I've been released from the psyche ward and are free to wander the\nstreets again, I've managed to piece together a bare-minimum understanding of\nwhat the hell is going on.\n\nWhat the Hell is Going On\nBecause Javascript as a language is destined to be backwards compatible to a\nyear when OJ Simpson was on trial and Windows 95 was considered cutting-edge\ntechnology, Babel  aims to \"improve\" browser Javascript. Because we can't\nactually improve or change the underlying technology, Babel looks at new-fangled\nECMA syntax (containing words like require,const  or promise) and compiles logic\nequivalent to these features with vanilla Javascript. If that sounds similar to\nhow Gulp  takes CSS preprocessors (like LESS  or SASS) and turns those files\ninto interpretable browser code, well, that's exactly what happens. \n\nGulp  is not be the only way to utilize new ECMAScript features. Babel syntax\ncan be compiled a number of ways, such as Babel's CLI\n[https://babeljs.io/docs/en/babel-cli], or from Server-side JS, or Webpack  if\nyou're Mister-Fancy-Pants. In fact, the trend across the board is that compiling\nyour site with modules via Webpack is winning dramatically. For all we know,\nthis could be the last Babel Gulp tutorial ever written.\n\nRight now we're focusing on the ability to use ECMAScript features on the\nfrontend; a common use-case for things like... well... theming the presentation\nlayer for a blog. If we can pull it off with Gulp, you probably won't struggle\nmuch with future methods.\n\nBabel NPM Packages\nAlright, so Babel isn't just a single NPM package. It's a lot. Let's see what's\nthere in a basic package.json:\n\n{\n  \"name\": \"example\",\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n  \"presets\": [\n    \"env\"\n  ],\n  \"engines\": {\n    \"node\": \"8.12.0\"\n  },\n  \"dependencies\": {\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/runtime\": \"^7.1.2\",\n    \"@babel/runtime-corejs2\": \"^7.1.2\",\n    \"babel-runtime\": \"^6.26.0\",\n    \"gulp-resolve-dependencies\": \"^2.2.0\",\n    \"gulp-sourcemaps\": \"^2.6.4\",\n    \"gulp-uglify-es\": \"^1.0.4\",\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.1.2\",\n    \"@babel/core\": \"^7.1.2\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/preset-env\": \"^7.1.0\",\n  }\n}\n\nLet's not go through all these in detail- in fact, let's take a look at our \ngulpfile.js:\n\n'use strict';\n\nvar gulp = require('gulp'),\n  concat = require('gulp-concat'),\n  autoprefixer = require('gulp-autoprefixer'),\n  sourcemaps = require('gulp-sourcemaps'),\n  babel = require('gulp-babel'),\n  resolveDependencies = require('gulp-resolve-dependencies'),\n\n\nvar paths = {\n  scripts: {\n    src: 'src/js/*.js',\n    dest: 'assets/js'\n  }\n};\n\nfunction scripts() {\n  return gulp.src(paths.scripts.src)\n    .pipe(babel({\n          presets: ['@babel/env'],\n          plugins: ['@babel/transform-runtime', '@babel/plugin-syntax-dynamic-import']\n    }))\n    .on('error', console.error.bind(console))\n    .pipe(resolveDependencies({\n            pattern: /\\* @requires [\\s-]*(.*\\.js)/g\n        }))\n    .pipe(concat('main.min.js'))\n    .pipe(gulp.dest(paths.scripts.dest));\n}\n\nNote that I've gone ahead and removed anything from the file that has nothing to\ndo with Babel - everything seen here is strictly relevant to building a\n'scripts' task. The gist is this:\n\nbabel  accepts two arrays:\n\n * Presets  refers to the version of ECMAScript we're targeting, and what we\n   have implies the latest.\n * Plugins  allow us to pass any plugins Babel supports; in this case, we're\n   rendering stuff at runtime. Let's not get into it too far.\n\nThe rest of the function is simple: we catch errors if any arise, we resolve\nrequired dependencies, and then we finally bunch everything into a single file\nand shove it in our destination folder.\n\nJust to be Clear\nWhen it comes to the best  way of achieving ECMAScript 2015 or 2016 etc in the\nbrowser,  I'm no expert. As previously mentioned, the understanding I've passed\non to you is a sort of bare minimum to start doing great things. \n\nAs far as what others are doing, I'd be willing to bet that the vast majority of\ndevs utilizing newer ECMAScript functions are running frameworks like React,\nwhile the rest have reached a consensus that Webpack is king and Gulp lame.\nThese things may be true.\n\nNo matter, this new found power of ours opens a lot of doors. Just wait until\nyou see what we do with MongoDB Stitch.","html":"<p><strong>NOTE</strong>: This post has not aged particularly well. This is made evident by the presence of the word \"Gulp\" present throughout the post.</p><hr><p>As you may have already deduced from the occasional glaring holes in my programming knowledge, I haven’t spent as much of my life programming than, well, anybody who haphazardly threw away an 8-year product management career. Apparently, a lot can happen in 8 years... especially when it comes to JavaScript.<br>Putting aside that whole server-side  NodeJS thing or whatever it’s called, there’s years worth of mindfucks for those of us who fairly recently returned to dev. In our absence, the world has been Grunting, Gulping, Yarning and even NPMing. Let’s assume we’ve gotten past all of that... phew. Oh wait, I forgot to mention the monstrosity of “hey by way there’s this mess of a hardly-explained (protocol? organization? Fancy Github Repo?) called Babel that we all depend on to do meaningful shit in the browser these days.”</p><p>If you’re here because you’re trying to figure what the hell all these ‘const’ and ‘import’ keywords are doing in modern-day browser JavaScript, consider this half focus-group and half getting-started tutorial. For the rest of you experienced JS devs out there, perhaps you should stay. No, by all means, I’d like you to sit here and think about the kind of ecosystem you’ve decided to patch together. Do it; otherwise, I might just give Kik a call to see what other tiny NPM modules they’d like to arbitrarily demand the removal of... remember that? Exactly. Now think about what you’ve done.</p><h2 id=\"ecmascript-and-the-backwards-compatible-web\">ECMAScript and the Backwards-Compatible Web</h2><p>Any Actionscript veterans in the house? No? Just me? Great. Anyway, There’s something that ActionScript, JavaScript, and a bunch of Whatever-scripts have in common: they’re all implementations of ECMAScript: the ancestral equivalent of comparing Latin to Spanish or French, but just one added detail: ECMAScript is still a living language, and constantly improving. If some nation of cool cats still spoke Latin as an active language and were constantly coming up with sick new slang terms, those speaking French or Spanish would be powerless to come up with phrases nearly as cool as “lit” or \"fam\"  (or whatever those Latin equivalents would be).</p><p>The problem is web browsers are inherently backward-compatible monstrosities. Most revenue-generating companies look at their &gt;5% user base using Internet Explorer three and a half, and think “oh my god, that’s five percent of our potential revenue” (it isn’t, but whatever). That’s where we stand.</p><h2 id=\"new-features-for-the-internet\">New features? For the INTERNET?</h2><p>I remember one particular weekend I rented a hotel room for the sole purpose of wrapping up an app based on MongoDB Stitch at the time. I was pretty confident I had it all figured out, but found, something about Mongo’s quick start guides felt off (I mean, more off than the rest of their nearly unreadable docs). Why did Mongo insist on inline JavaScript? Haven’t we evolved past the days where PHP, HTML, CSS, and JS all lived on the same page?</p><p>As everybody-who-wasn’t-me at time already knows, JavaScript has been reaping the benefits of new evolutions in ECMAScript over the years, but there’s a catch: only the most modern browsers know what the hell to do with these new features (duh), and they only do so with the dreaded  blocks thrown on HTML pages. Attempting to use modern ECMA features in a linked JS file which hasn’t been pre-compiled is like dividing by zero. Seriously, you might die.</p><h2 id=\"babel-to-the-rescue\">Babel to the Rescue</h2><p>More research only lead to more questions. Who is this <a href=\"http://browserify.org/\">Browserify wizard</a> and why is he dead? What is Webpack doing to fund all their highly produced branding, and why would anybody purchase a <a href=\"https://webpack.threadless.com/\">Webpack T-shirt</a>? Finally, the biggest question of all: who the hell is this Babel guy who gives off as an electric explosion in your face on hard drugs?</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/babel2-1.jpg\" class=\"kg-image\"><figcaption><em>I can't even the difference between a compiler and a Marvel franchise anymore.&nbsp;</em></figcaption></figure><p>I think it was at this point in my journey of catching up on the last decade where I went truly mad and began pacing around my room, verbally assaulting inanimate objects, and eventually even found myself washed up in a Wendys down the street, shivering and crying to myself. </p><p>Now that I've been released from the psyche ward and are free to wander the streets again, I've managed to piece together a bare-minimum understanding of what the hell is going on.</p><h3 id=\"what-the-hell-is-going-on\">What the Hell is Going On</h3><p>Because Javascript as a language is destined to be backwards compatible to a year when OJ Simpson was on trial and Windows 95 was considered cutting-edge technology, <strong>Babel</strong> aims to \"improve\" browser Javascript. Because we can't actually improve or change the underlying technology, Babel looks at new-fangled ECMA syntax (containing words like <code>require</code>,  <code>const</code> or <code>promise</code>) and compiles logic equivalent to these features with vanilla Javascript. If that sounds similar to how <strong>Gulp</strong> takes CSS preprocessors (like <em>LESS</em> or <em>SASS</em>) and turns those files into interpretable browser code, well, that's exactly what happens. </p><p><strong>Gulp</strong> is not be the only way to utilize new ECMAScript features. Babel syntax can be compiled a number of ways, such as <a href=\"https://babeljs.io/docs/en/babel-cli\">Babel's CLI</a>, or from Server-side JS, or <strong>Webpack</strong> if you're Mister-Fancy-Pants. In fact, the trend across the board is that compiling your site with modules via Webpack is winning dramatically. For all we know, this could be the last Babel Gulp tutorial ever written.</p><p>Right now we're focusing on the ability to use ECMAScript features on the frontend; a common use-case for things like... well... theming the presentation layer for a blog. If we can pull it off with Gulp, you probably won't struggle much with future methods.</p><h2 id=\"babel-npm-packages\">Babel NPM Packages</h2><p>Alright, so Babel isn't just a single NPM package. It's a lot. Let's see what's there in a basic <code>package.json</code>:</p><pre><code>{\n  \"name\": \"example\",\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n  \"presets\": [\n    \"env\"\n  ],\n  \"engines\": {\n    \"node\": \"8.12.0\"\n  },\n  \"dependencies\": {\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/runtime\": \"^7.1.2\",\n    \"@babel/runtime-corejs2\": \"^7.1.2\",\n    \"babel-runtime\": \"^6.26.0\",\n    \"gulp-resolve-dependencies\": \"^2.2.0\",\n    \"gulp-sourcemaps\": \"^2.6.4\",\n    \"gulp-uglify-es\": \"^1.0.4\",\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.1.2\",\n    \"@babel/core\": \"^7.1.2\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/preset-env\": \"^7.1.0\",\n  }\n}</code></pre><p>Let's not go through all these in detail- in fact, let's take a look at our <strong>gulpfile.js</strong>:</p><pre><code>'use strict';\n\nvar gulp = require('gulp'),\n  concat = require('gulp-concat'),\n  autoprefixer = require('gulp-autoprefixer'),\n  sourcemaps = require('gulp-sourcemaps'),\n  babel = require('gulp-babel'),\n  resolveDependencies = require('gulp-resolve-dependencies'),\n\n\nvar paths = {\n  scripts: {\n    src: 'src/js/*.js',\n    dest: 'assets/js'\n  }\n};\n\nfunction scripts() {\n  return gulp.src(paths.scripts.src)\n    .pipe(babel({\n          presets: ['@babel/env'],\n          plugins: ['@babel/transform-runtime', '@babel/plugin-syntax-dynamic-import']\n    }))\n    .on('error', console.error.bind(console))\n    .pipe(resolveDependencies({\n            pattern: /\\* @requires [\\s-]*(.*\\.js)/g\n        }))\n    .pipe(concat('main.min.js'))\n    .pipe(gulp.dest(paths.scripts.dest));\n}</code></pre><p>Note that I've gone ahead and removed anything from the file that has nothing to do with Babel - everything seen here is strictly relevant to building a 'scripts' task. The gist is this:</p><p><strong>babel</strong> accepts two arrays:</p><ul><li><em>Presets</em> refers to the version of ECMAScript we're targeting, and what we have implies the latest.</li><li><em>Plugins</em> allow us to pass any plugins Babel supports; in this case, we're rendering stuff at runtime. Let's not get into it too far.</li></ul><p>The rest of the function is simple: we catch errors if any arise, we resolve required dependencies, and then we finally bunch everything into a single file and shove it in our destination folder.</p><h2 id=\"just-to-be-clear\">Just to be Clear</h2><p>When it comes to the <em>best</em> way of achieving ECMAScript 2015 or 2016 etc in the browser,  I'm no expert. As previously mentioned, the understanding I've passed on to you is a sort of bare minimum to start doing great things. </p><p>As far as what others are doing, I'd be willing to bet that the vast majority of devs utilizing newer ECMAScript functions are running frameworks like React, while the rest have reached a consensus that Webpack is king and Gulp lame. These things may be true.</p><p>No matter, this new found power of ours opens a lot of doors. Just wait until you see what we do with <strong>MongoDB Stitch</strong>.</p><p></p><p></p>","url":"https://hackersandslackers.com/babel-ecma-script/","uuid":"04fe6342-9462-4d3c-9e6d-bc000e17824a","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5bb583642361b479aa119366"}},"pageContext":{"slug":"babel-ecma-script"}}