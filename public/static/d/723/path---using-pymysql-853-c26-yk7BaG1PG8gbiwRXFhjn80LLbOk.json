{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673678","title":"Using PyMySQL: Python's MySQL Library","slug":"using-pymysql","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/04/pymysql-1.jpg","excerpt":"The lightweight Python library for interacting with MySQL.","custom_excerpt":"The lightweight Python library for interacting with MySQL.","created_at_pretty":"15 June, 2018","published_at_pretty":"15 June, 2018","updated_at_pretty":"10 April, 2019","created_at":"2018-06-14T20:32:21.000-04:00","published_at":"2018-06-15T16:48:12.000-04:00","updated_at":"2019-04-10T00:43:08.000-04:00","meta_title":"Using PyMySQL: Python's MySQL Library | Hackers and Slackers","meta_description":"Learn to work with PyMySQL: the lightweight Python library for interacting with MySQL.","og_description":"Learn to work with PyMySQL: the lightweight Python library for interacting with MySQL.","og_image":"https://hackersandslackers.com/content/images/2019/04/pymysql-1-2.jpg","og_title":"Using PyMySQL: Python's MySQL Library","twitter_description":"Learn to work with PyMySQL: the lightweight Python library for interacting with MySQL.","twitter_image":"https://hackersandslackers.com/content/images/2019/04/pymysql-1-1.jpg","twitter_title":"Using PyMySQL: Python's MySQL Library","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"MySQL","slug":"mysql","description":"Database configuration, building queries, and cloud hosting options for MySQL.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/mysqlrevamp_o.jpg","meta_description":"Database configuration, building queries, and cloud hosting options for MySQL.","meta_title":"Working with MySQL | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#Working with MySQL","slug":"working-with-mysql","description":"Learn about MySQL database configuration, the query language, and cloud hosted instances.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/mysql1_o-1.jpg","meta_description":"Learn about MySQL database configuration, the query language, and cloud hosted instances.","meta_title":"Working with MySQL","visibility":"internal"}],"plaintext":"It's almost Friday night, and the squad at H+S is ready to get cooking. Dim down\nthe lights and slip into something more comfortable as we take you on this 100%\norganic flavor extravaganza. Tonight's menu? A Python MySQL library: PyMySQL\n[https://github.com/PyMySQL/PyMySQL].\n\nPyMySQL is lightweight and perfect for fulfilling MySQL queries. If you want\nbells and whistles, you're probably barking up the wrong tree (and you probably\nshould’ve used a DB other than MySQL in the first place).\n\nWhy write tutorials for technologies we openly trash talk? Out of necessity, of\ncourse! There's nothing wrong with MySQL, most enterprises are married to it in\nsome way. Thus, A great use case for PyMySQL is for usage in AWS lambda when\nworking with large enterprise systems. We'll get to that, but for now let's cook\nup something good.\n\nHeat up the Stove\nTurn on the gas and prep the table to set with your favorite collection of\nplates! That's right, we're talking boilerplate. We knew this was coming; it\nseems like every time you want to do something tangibly cool, we need to get\ninto the business of managing connections and whatnot.\n\nTo ease the pain, I'll share with you a preferred method of handling opening\nconnections with PyMySQL. Here we set a function to separate basic connection\nlogic and error messaging from our app:\n\nimport sys\nimport pymysql\nimport logger\n\nconn = None\n\ndef openConnection():\n    global conn\n    try:\n        if(conn is None):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=5)\n        elif (not conn.open):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=5)    \n    except:\n        logger.error(\"ERROR: Unexpected error: Could not connect to MySql instance.\")\n        sys.exit()\n\n\n\nNothing fancy here: we set a global variable conn  to serve as our connection,\nand have some basic logic on how to interact with our database. Running \nopenConnection  will attempt to connect to a MySQL db with supplied credentials,\nor throw an error if something goes horribly wrong.\n\nNow we can keep this separate from the rest of our code. Out of sight, out of\nmind.\n\nMeat and Potatoes\nWith the boring stuff out of the way, let's dig into some goodness. We'll start\noff with a basic use case: selecting all rows from a table:\n\ndef getRecords():\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = \"SELECT * FROM table\"\n            cur.execute(sql)\n            result = cur.fetchall()\n            print(result)\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n        \ngetRecords() \n\n\nWe split our function into your standard try/except/finally  breakdown. What\nwe're trying is opening a connection using the function we created earlier, and\nrunning queries against it.\n\nThe preferred syntax in PyMySQL is to keep our query in a single string, as seen\nin our variable sql. With our query ready, we need to execute  the query, fetch \nthe resulting records and print the result. We're sure to close the connection\nonce we're done with executing queries... this is critical to ensure db\nconnections don't stay active.\n\nSimple so far, but we're about to kick it up a notch.\n\nSelecting rows\nYou may have noticed we used .fetchall()  to select all records. This is\nimportant to differentiate from .fetchone(), which simply selects the first\nrecord.\n\nWe can iterate over the rows resulting from .fetchall()  with a simple loop, as\nshown in the example below. Beware: attempting to print the result of \n.fetchall()  will simply result in a single integer, which represents the number\nof rows fetched. If there are instances where we know only one record should be\nreturned, .fetchone()  should be used instead.\n\ndef getRecords(table):\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = \"SELECT * FROM %s\"\n            cur.execute(sql, table)\n            result = cur.fetchall()\n            for row in result:\n                record = {\n                        'id': row[0],\n                        'name': row[1],\n                        'email': row[2],\n                        'phone': row[3],\n\n                    }\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n        \ngetRecords('table_name')       \n\n\nWhoa, what's with the %s? This is how we pass arguments into queries in PyMySQL.\nThe PyMySQL guys were kind enough to realize how obnoxious it is to constantly\nbreak strings to pass in variables - in the case of SQL queries, this beyond\nobnoxious and borderline unworkable. Remember that MySQL requires explicit\nquotations around passing string values, so queries such as these become a\nnonsensical jumble of escaped characters.\n\nPyMySQL supports backquotes: the distant cousin of the single quotation mark,\nAKA the diagonal quote thing above the tilde ~ button on your keyboard. You\nknow: `. If there comes a time to set a string within your query use this\nelusive quotation as such: sql = \"SELECT * FROM %s WHERE column_name =\n`somevalue`\"Updating Rows of Data\nArguments can be passed as anything inside a query: they simply appear in the\norder in which they are passed. In the below example, we pass table as an\nargument, as well values we want updated, and the identifier for target rows:\n\ndef getRecords(table, data):\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = \"UPDATE %s SET date=%s, numsent=%s WHERE email = %s\"\n            cur.execute(sql, (table, data['date_sent'], data['status'], data['email']))\n            conn.commit()\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n\ndata = {\n    'date_sent': '12/01/2018'\n    'email': 'fakeemail@example.com'\n    'status': 'Confirmed'\n}\ngetRecords('table_name', data)       \n\n\nHeads up:  Note the line conn.commit(). Don't forget that - this is what\nactually commits the update to the database. Forgetting this line and wasting\nhours debugging is somewhat of a rite of passage, but let's just skip all that.\n\nFor Dessert: Usage in AWS Lambda\nIt is my treat to share with you my world famous copy & paste recipe for AWS\nLambda. Here we store all of our db credentials in a separate file called \nrdsconfig.py. We also enable logging to take us through what is happening each\nstep of the way:\n\nimport sys\nimport logging\nimport rds_config\nimport pymysql\n\n#rds settings\nrds_host  = \"rdsName.dfsd834mire.us-west-3.rds.amazonaws.com\"\nname = rds_config.db_username\npassword = rds_config.db_password\ndb_name = rds_config.db_name\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nconn = None\n\ndef openConnection():\n    global conn\n    try:\n        if(conn is None):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=10)\n        elif (not conn.open):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=10)\n    except:\n        logger.error(\"ERROR: Could not connect to MySql instance.\")\n        sys.exit()\n\n\nlogger.info(\"SUCCESS: Connection to RDS mysql instance succeeded\")\n\n\nWe thank you all for joining us in this adventure of tantalizing treats. May\nyour data be clean and your stomachs full.\n\nBon appétit.","html":"<p>It's almost Friday night, and the squad at H+S is ready to get cooking. Dim down the lights and slip into something more comfortable as we take you on this 100% organic flavor extravaganza. Tonight's menu? A Python MySQL library: <a href=\"https://github.com/PyMySQL/PyMySQL\">PyMySQL</a>.</p><p>PyMySQL is lightweight and perfect for fulfilling MySQL queries. If you want bells and whistles, you're probably barking up the wrong tree (and you probably should’ve used a DB other than MySQL in the first place).</p><p>Why write tutorials for technologies we openly trash talk? Out of necessity, of course! There's nothing wrong with MySQL, most enterprises are married to it in some way. Thus, A great use case for PyMySQL is for usage in AWS lambda when working with large enterprise systems. We'll get to that, but for now let's cook up something good.</p><h2 id=\"heat-up-the-stove\">Heat up the Stove</h2><p>Turn on the gas and prep the table to set with your favorite collection of plates! That's right, we're talking boilerplate. We knew this was coming; it seems like every time you want to do something tangibly cool, we need to get into the business of managing connections and whatnot.</p><p>To ease the pain, I'll share with you a preferred method of handling opening connections with PyMySQL. Here we set a function to separate basic connection logic and error messaging from our app:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import sys\nimport pymysql\nimport logger\n\nconn = None\n\ndef openConnection():\n    global conn\n    try:\n        if(conn is None):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=5)\n        elif (not conn.open):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=5)    \n    except:\n        logger.error(&quot;ERROR: Unexpected error: Could not connect to MySql instance.&quot;)\n        sys.exit()\n\n</code></pre>\n<!--kg-card-end: markdown--><p>Nothing fancy here: we set a global variable <em>conn</em> to serve as our connection, and have some basic logic on how to interact with our database. Running <em>openConnection</em> will attempt to connect to a MySQL db with supplied credentials, or throw an error if something goes horribly wrong.</p><p>Now we can keep this separate from the rest of our code. Out of sight, out of mind.</p><h2 id=\"meat-and-potatoes\">Meat and Potatoes</h2><p>With the boring stuff out of the way, let's dig into some goodness. We'll start off with a basic use case: selecting all rows from a table:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">def getRecords():\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = &quot;SELECT * FROM table&quot;\n            cur.execute(sql)\n            result = cur.fetchall()\n            print(result)\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n        \ngetRecords() \n</code></pre>\n<!--kg-card-end: markdown--><p>We split our function into your standard <em>try/except/finally</em> breakdown. What we're trying is opening a connection using the function we created earlier, and running queries against it.</p><p>The preferred syntax in PyMySQL is to keep our query in a single string, as seen in our variable <em>sql</em>. With our query ready, we need to <em>execute</em> the query, <em>fetch</em> the resulting records and print the result. We're sure to close the connection once we're done with executing queries... this is critical to ensure db connections don't stay active.</p><p>Simple so far, but we're about to kick it up a notch.</p><h3 id=\"selecting-rows\">Selecting rows</h3><p>You may have noticed we used <em>.fetchall()</em> to select all records. This is important to differentiate from <em>.fetchone()</em>, which simply selects the first record.</p><p>We can iterate over the rows resulting from <em>.fetchall()</em> with a simple loop, as shown in the example below. Beware: attempting to print the result of <em>.fetchall()</em> will simply result in a single integer, which represents the number of rows fetched. If there are instances where we know only one record should be returned, <em>.fetchone()</em> should be used instead.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">def getRecords(table):\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = &quot;SELECT * FROM %s&quot;\n            cur.execute(sql, table)\n            result = cur.fetchall()\n            for row in result:\n                record = {\n                        'id': row[0],\n                        'name': row[1],\n                        'email': row[2],\n                        'phone': row[3],\n\n                    }\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n        \ngetRecords('table_name')       \n</code></pre>\n<!--kg-card-end: markdown--><p>Whoa, what's with the <em><strong>%s</strong></em>? This is how we pass arguments into queries in PyMySQL. The PyMySQL guys were kind enough to realize how obnoxious it is to constantly break strings to pass in variables - in the case of SQL queries, this beyond obnoxious and borderline unworkable. Remember that MySQL requires explicit quotations around passing string values, so queries such as these become a nonsensical jumble of escaped characters.</p><!--kg-card-begin: html--><div class=\"protip\">\nPyMySQL supports backquotes: the distant cousin of the single quotation mark, AKA the diagonal quote thing above the tilde ~ button on your keyboard. You know: `. If there comes a time to set a string within your query use this elusive quotation as such: <code>sql = \"SELECT * FROM %s WHERE column_name = `somevalue`\"</code>\n</div><!--kg-card-end: html--><h3 id=\"updating-rows-of-data\">Updating Rows of Data</h3><p>Arguments can be passed as anything inside a query: they simply appear in the order in which they are passed. In the below example, we pass table as an argument, as well values we want updated, and the identifier for target rows:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">def getRecords(table, data):\n    try:\n        openConnection()\n        with conn.cursor() as cur:\n            sql = &quot;UPDATE %s SET date=%s, numsent=%s WHERE email = %s&quot;\n            cur.execute(sql, (table, data['date_sent'], data['status'], data['email']))\n            conn.commit()\n            cur.close()\n            conn.close()\n    except Exception as e:\n        print(e)\n    finally:\n        print('Query Successful')\n\ndata = {\n    'date_sent': '12/01/2018'\n    'email': 'fakeemail@example.com'\n    'status': 'Confirmed'\n}\ngetRecords('table_name', data)       \n</code></pre>\n<!--kg-card-end: markdown--><p><strong>Heads up:</strong> Note the line <em>conn.commit()</em>. Don't forget that - this is what actually commits the update to the database. Forgetting this line and wasting hours debugging is somewhat of a rite of passage, but let's just skip all that.</p><h2 id=\"for-dessert-usage-in-aws-lambda\">For Dessert: Usage in AWS Lambda</h2><p>It is my treat to share with you my world famous copy &amp; paste recipe for AWS Lambda. Here we store all of our db credentials in a separate file called <em>rdsconfig.py</em>. We also enable logging to take us through what is happening each step of the way:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import sys\nimport logging\nimport rds_config\nimport pymysql\n\n#rds settings\nrds_host  = &quot;rdsName.dfsd834mire.us-west-3.rds.amazonaws.com&quot;\nname = rds_config.db_username\npassword = rds_config.db_password\ndb_name = rds_config.db_name\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nconn = None\n\ndef openConnection():\n    global conn\n    try:\n        if(conn is None):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=10)\n        elif (not conn.open):\n            conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=10)\n    except:\n        logger.error(&quot;ERROR: Could not connect to MySql instance.&quot;)\n        sys.exit()\n\n\nlogger.info(&quot;SUCCESS: Connection to RDS mysql instance succeeded&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>We thank you all for joining us in this adventure of tantalizing treats. May your data be clean and your stomachs full.</p><p>Bon appétit.</p>","url":"https://hackersandslackers.com/using-pymysql/","uuid":"cd6baf62-981c-4034-ba29-b67d257acbeb","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b230915f37f772d33bc1eb1"}},"pageContext":{"slug":"using-pymysql"}}