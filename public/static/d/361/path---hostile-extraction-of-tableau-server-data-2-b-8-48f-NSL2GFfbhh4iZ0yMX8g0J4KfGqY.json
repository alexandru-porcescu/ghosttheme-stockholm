{"data":{"ghostPost":{"id":"Ghost__Post__5c3fc99b89c81d4ccc3f64b1","title":"The Hostile Extraction of Tableau Server Data","slug":"hostile-extraction-of-tableau-server-data","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-2.jpg","excerpt":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","custom_excerpt":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","created_at_pretty":"17 January, 2019","published_at_pretty":"17 January, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-01-16T19:17:31.000-05:00","published_at":"2019-01-17T07:43:00.000-05:00","updated_at":"2019-03-28T11:06:50.000-04:00","meta_title":"The Hostile Extraction of Tableau Server Data | Hackers and Slackers","meta_description":"How to create a Python application to take back your Tableau data. Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","og_description":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","og_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-2.jpg","og_title":"The Hostile Extraction of Tableau Server Data","twitter_description":"Say no to proprietary software constraints. Say no to vendor lock. Say yes to freedom.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/tableauextraction-1-1.jpg","twitter_title":"The Hostile Extraction of Tableau Server Data","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"},{"name":"#Hacking Tableau Server","slug":"hacking-tableau-server","description":"Break free from the constraints of the TSM CLI to bend Tableau Server to your will. Uncover Superadmin privileges, or even rewire Tableau to handle ETL.","feature_image":"https://hackersandslackers.com/content/images/2019/03/tableauseries-2.jpg","meta_description":"Break free from the constraints of the TSM CLI to bend Tableau Server to your will. Uncover Superadmin privileges, or even rewire Tableau to handle ETL.","meta_title":"Hacking Tableau Server","visibility":"internal"},{"name":"BI","slug":"business-intelligence","description":"Business Intelligence, otherwise known as \"making nice reports for executives to ignore.\"","feature_image":null,"meta_description":null,"meta_title":"Business Intelligence Tools | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"}],"plaintext":"I try my best not to hate on Tableau. It was the software’s combination of power\nand ease-of-use that drove me to purchase a license in the first place. Ever\nsince then, I’m finding new and exciting ways Tableau intentionally locks users\nout of their data. \n\nI gave the Tableau Server Client Python library\n[https://tableau.github.io/server-client-python/docs/]  a spin recently in hopes\nof finding something useful. I decided to (sigh, once more) allow Tableau the\nbenefit of the doubt: after pushing four updates in a single month, maybe things\nhad changed. On the contrary, the Tableau business strategy stands strong: to be\na raging, flaming turd pile. A perfect example of this is the View  object\nTableau allows you to interact with on your server. Those familiar know that \nviews  are slang for sheets  of workbooks  stored on Tableau server. \n\nConnecting to your Tableau instance via Python to retrieve your view objects is\na piece of cake:\n\nimport tableauserverclient as TSC\ntableau_auth = TSC.TableauAuth('username', 'password')\nserver = TSC.Server('http://servername')\n\nwith server.auth.sign_in(tableau_auth):\n  all_views, pagination_item = server.views.get()\n  print([view.name for view in all_views])\n\n\nThis simple snippet lists every view object on your server. Wow! Think of what\nwe can do with all that tabular data we worked so hard to transform, rig- WRONG.\nLook at what Tableau's Python 'View Object' actually contains:\n\n * id  The identifier of the view item.\n * name  The name of the view.\n * owner_id  The id for the owner of the view.\n * preview_image  The thumbnail image for the view.\n * total_views  The usage statistics for the view. Indicates the total number of\n   times the view has been accessed.\n * workbook_id  The id of the workbook associated with the view.\n\nHOLY MOSES STOP THE PRESSES, we can get a thumbnail image  of our data?! THANK\nYOU GENEROUS TABLEAU OVERLORDS!\n\nNotice how there's no mention of, you know, the actual data.\n\nWe're going to play a game. In the wake of my time has been wasted, I feel that\nwarm tickling feeling which seems to say \"Viciously dismantle the ambitions of\nan establishment!\"  May I remind you, we're talking about the kind of\nestablishment that bills customer licenses based on the number of CPUs being\nutilized by their server infrastructure.  This is effectively recognizing the\nhorrifying and inefficient codebase behind Tableau server, and leveraging this\nflaw for monetization. Yes, you're paying more money to incentivize worst\npractices.\n\nLet's Make a Flask App. An Angry One.\nIn our last post I shared a little script to help you get started stealing data\n[https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/] \n off your own Tableau Server. That doesn't quite scratch my itch anymore. I'm\ngoing to build an interface. I want to make it easy as possible for anybody to\nsystemically rob Tableau Server of every penny its got. That's a lot of pennies\nwhen we consider the equation: data = oil + new.\n\nBefore I bore you, here's a quick demo of the MVP we're building:\n\nEach table is a view being pulled from Tableau Server.This POC demonstrates that\nit is very  possible to automate the extraction of Tableau views from Tableau\nServer. The success  message is signaling that we've successfully taken a\nTableau view and created a corresponding table in an external database. Any data\nwe manipulate in Tableau is now truly ours: we can now leverage the transforms\nwe've applied in workbooks, use this data in other applications, and utilize an\nextract scheduler to keep the data coming. We've turned a BI tool into an ETL\ntool. In other words, you can kindly take those thumbnail previews and shove it.\n\nI'll be open sourcing all of this, as is my civic duty. Let us be clear to\nenterprises: withholding freedom to one's own data is an act of war. Pricing\nmodels which reward poor craftsmanship are an insult to our intellect. For every\narrogant atrocity committed against consumers, the war will wage twice as hard.\nI should probably mention these opinions are my own.\n\nThe Proletariat Strikes Back\nGet a feel for where we're heading with the obligatory project-file-structure\ntree:\n\ntableau-exporter\n├── application\n│   ├── __init__.py\n│   ├── database.py\n│   ├── tableau.py\n│   ├── routes.py\n│   ├── static\n│   │   ├── data\n│   │   │   └── view.csv\n│   │   ├── dist\n│   │   │   ├── all.css\n│   │   │   ├── packed.js\n│   │   ├── img\n│   │   │   └── tableaugithub.jpg\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── scss\n│   │       └── main.scss\n│   └── templates\n│       ├── export.html\n│       ├── index.html\n│       ├── layout.html\n│       └── view.html\n├── config.ini\n├── config.py\n├── app.yaml\n├── start.sh\n├── wsgi.py\n├── Pipfile\n├── README.md\n└── requirements.txt\n\n\nAs usual, we're using a classic Flask application factory  set up here.\n\nWeapons Of Choice\nLet's have a look at our core arsenal:\n\n * requests: We're achieving our goal by exploiting some loopholes exposed in\n   the Tableau REST API.\n * pandas: Will handle everything from extracting comma-separated data into a\n   CSV, render HTML tables, and output SQL.\n * flask_sqlalchemy: Used in tandem with pandas  to handle shipping our data off\n   elsewhere.\n * flask_redis: To handle session variables.\n\nInitiating our Application\nHere's how we construct our app:\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_redis import FlaskRedis\n\n# Set global entities\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    \"\"\"Construct the core application.\"\"\"\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Initiate globals\n        db.init_app(app)\n        r.init_app(app, charset=\"utf-8\", decode_responses=True)\n\n        # Set global contexts\n        r.set('uri', app.config['SQLALCHEMY_DATABASE_URI'])\n        r.set('baseurl',  app.config['BASE_URL'])\n        r.set('username',  app.config['USERNAME'])\n        r.set('password', app.config['PASSWORD'])\n\n        # Import our modules\n        from . import routes\n        from . import tableau\n        app.register_blueprint(routes.home_blueprint)\n\n        return app\n\n\nThis should all feel like business-as-usual. The core of our application is\nsplit between routes.py, which handles views, and tableau.py, which handles the\nanti-establishment logic. Let's begin with the latter.\n\nLife, Liberty, and The Pursuit of Sick Data Pipelines\nOur good friend tableau.py  might look familiar to those who joined us last time\n[https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/]\n. tableau.py  has been busy hitting the gym since then and is looking sharp for\nprimetime:\n\nimport requests\nimport xml.etree.ElementTree as ET\nfrom . import r\nimport pandas as pd\nimport io\n\n\nclass ExtractTableauView:\n    \"\"\"Class for working in a Tableau instance.\"\"\"\n\n    __baseurl = r.get('baseurl')\n    __username = r.get('username')\n    __password = r.get('password')\n    __database = r.get('uri')\n    __contenturl = r.get('contenturl')\n\n    @classmethod\n    def get_view(cls, site, xml, view, token):\n        \"\"\"Extract contents of a single view.\"\"\"\n        headers = {'X-Tableau-Auth': token,\n                   'Content-Type': 'text/csv'\n                   }\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + str(site) +'/views/' + str(view) + '/data', headers=headers, stream=True)\n        csv_text = req.text\n        view_df = pd.read_csv(io.StringIO(csv_text), header=0)\n        return view_df\n\n    @classmethod\n    def list_views(cls, site, xml, token):\n        \"\"\"List all views belonging to a Tableau Site.\"\"\"\n        headers = {'X-Tableau-Auth': token}\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + site + '/views', auth=(cls.__username, cls.__password), headers=headers)\n        root = ET.fromstring(req.content)\n        views_arr = []\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}views':\n                for view in child:\n                    view_dict = {\n                        'name': view.attrib.get('name'),\n                        'id': view.attrib.get('id'),\n                        'url': cls.__baseurl + '/' + view.attrib.get('contentUrl'),\n                        'created': view.attrib.get('createdAt'),\n                        'updated': view.attrib.get('updatedAt')\n                    }\n                    views_arr.append(view_dict)\n        return views_arr\n\n    @classmethod\n    def get_token(cls, xml):\n        \"\"\"Receive Auth token to perform API requests.\"\"\"\n        for child in xml.iter('*'):\n            if child.tag == '{http://tableau.com/api}credentials':\n                token = child.attrib.get('token')\n                return token\n\n    @classmethod\n    def get_site(cls, xml):\n        \"\"\"Retrieve ID of Tableau 'site' instance.\"\"\"\n        root = xml\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}site':\n                site = child.attrib.get('id')\n                return site\n\n    @classmethod\n    def initialize_tableau_request(cls):\n        \"\"\"Retrieve core XML for interacting with Tableau.\"\"\"\n        headers = {'Content-Type': 'application/xml'}\n        body = '<tsRequest><credentials name=\"' + cls.__username + '\" password=\"' + cls.__password + '\" ><site contentUrl=\"' + cls.__contenturl + '\" /></credentials></tsRequest>'\n        req = requests.post(cls.__baseurl + '/api/3.2/auth/signin', auth=(cls.__username, cls.__password), headers=headers, data=body)\n        root = ET.fromstring(req.content)\n        return root\n\n\nI wish I could take full credit for what a shit show this class appears to be at\nfirst glance, but I assure you we've been left with no choice. For example: have\nI mentioned that Tableau's REST API returns XML so malformed that it breaks XML\nparsers? I can't tell incompetence from malicious intent at this point.\n\nHere's a method breakdown of our class:\n\n * initialize_tableau_request(): Handles initial auth and returns valuable\n   information such as site ID and API Token to be used thereafter.\n * get_site(): Extracts the site ID from XML returned by the above.\n * get_token(): Similarly extracts our token.\n * list_views(): Compiles a list of all views within a Tableau site, giving us a\n   chance to select ones for extraction.\n * get_view(): Takes a view of our choice and creates a DataFrame, which is to\n   be shipped off to a foreign database.\n\nOur Routing Logic\nMoving on we have routes.py  building the views and associated logic for our\napp:\n\nfrom flask import current_app as app\nfrom flask import render_template, Blueprint, request, Markup\nfrom flask_assets import Bundle, Environment\nfrom . import tableau\nfrom . import database\nimport pandas as pd\n\nhome_blueprint = Blueprint('home', __name__, template_folder='templates', static_folder='static')\n\nassets = Environment(app)\njs = Bundle('js/*.js', filters='jsmin', output='dist/packed.js')\nscss = Bundle('scss/*.scss', filters='libsass', output='dist/all.css')\nassets.register('scss_all', scss)\nassets.register('js_all', js)\nscss.build()\njs.build()\n\n\n@home_blueprint.route('/', methods=['GET', 'POST'])\ndef entry():\n    \"\"\"Homepage which lists all available views.\"\"\"\n    tableau_view_extractor = tableau.ExtractTableauView()\n    xml = tableau_view_extractor.initialize_tableau_request()\n    token = tableau_view_extractor.get_token(xml)\n    site = tableau_view_extractor.get_site(xml)\n    views = tableau_view_extractor.list_views(site, xml, token)\n    return render_template(\n        'index.html',\n        title=\"Here are your views.\",\n        template=\"home-template\",\n        views=views,\n        token=token,\n        xml=xml,\n        site=site\n    )\n\n\n@home_blueprint.route('/view', methods=['GET', 'POST'])\ndef view():\n    \"\"\"Displays a preview of a selected view.\"\"\"\n    site = request.args.get('site')\n    xml = request.args.get('xml')\n    view = request.args.get('view')\n    token = request.args.get('token')\n    tableau_view_extractor = tableau.ExtractTableauView()\n    view_df = tableau_view_extractor.get_view(site, xml, view, token)\n    view_df.to_csv('application/static/data/view.csv')\n    return render_template(\n        'view.html',\n        title='Your View',\n        template=\"home-template\",\n        view=view,\n        token=token,\n        xml=xml,\n        site=site,\n        view_df=Markup(view_df.to_html(index=False))\n    )\n\n\n@home_blueprint.route('/export', methods=['GET', 'POST'])\ndef export():\n    \"\"\"Exports view to external database.\"\"\"\n    view_df = pd.read_csv('application/static/data/view.csv')\n    view_df.to_sql(name='temp', con=database.engine, if_exists='replace', chunksize=50, index=True)\n    return render_template(\n        'export.html',\n        title='Success!',\n        template=\"success-template\",\n    )\n\n\nWe only have 3 pages to our application. They include our list of views, a\npreview of a single view, and a success page for when said view is exported.\nThis is all core Flask logic.\n\nPutting it On Display\nWe build our pages dynamically based on the values we pass our Jinja templates.\nThe homepage utilizes some nested loops to list the views we returned from \ntableau.py, and also makes use of query strings to pass values on to other\ntemplates.\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n<div class=\"extended-container {{template}}\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col s12\">\n        <h1>{{title}}</h1>\n      </div>\n      <div class=\"col s12 flex-container\">\n        {% for view in views %}\n        <div class=\"download\">\n          <a href=\"{{ url_for('home.view') }}?token={{token}}&site={{site}}&view={{view.id}}&xml={{xml}}\">\n            <ul>\n              {% for key, value in view.items() %}\n              <li><span class=\"key {{key}}\">{{key}}</span> {{ value }}</li>\n              {% endfor %}\n            </ul>\n          </a>\n        </div>\n        {% endfor %}\n      </div>\n    </div>\n  </div>\n  {% endblock %}\n\n\nMoving on: our humble view.html  page has two purposes: display the selected\nview, and export it in the name of justice.\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n<div class=\"extended-container {{template}}\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col s12\">\n        <h1>{{title}}</h1>\n        <a href=\"{{ url_for('home.export') }}\" class=\"export\"><i class=\"far fa-file-export\"></i></a>\n        {{view_df}}\n      </div>\n    </div>\n  </div>\n  {% endblock %}\n\n\nThe War is Not Over\nThis repository is open to the public and can be found here\n[https://github.com/toddbirchard/tableau-extraction]. There are still crusades\nleft ahead of us: for instance, building out this interface to accept\ncredentials via login as opposed to a config file, and the scheduling of view\nexports, as opposed to on-demand.\n\nWhere we go from here depends on what we the people decide. For all I know, I\ncould be shouting to an empty room here (I'm almost positive anybody who pays\nfor enterprise software prefers the blind eye of denial). If the opposite holds\ntrue, I dare say the revolution is only getting started.","html":"<p>I try my best not to hate on Tableau. It was the software’s combination of power and ease-of-use that drove me to purchase a license in the first place. Ever since then, I’m finding new and exciting ways Tableau intentionally locks users out of their data. </p><p>I gave the <a href=\"https://tableau.github.io/server-client-python/docs/\"><strong>Tableau Server Client</strong> Python library</a> a spin recently in hopes of finding something useful. I decided to (sigh, <em>once more</em>) allow Tableau the benefit of the doubt: after pushing <strong>four updates in a single month</strong>, maybe things had changed. On the contrary, the Tableau business strategy stands strong: to be a raging, flaming turd pile. A perfect example of this is the <strong>View</strong> object Tableau allows you to interact with on your server. Those familiar know that <strong>views</strong> are slang for <em>sheets</em> of <em>workbooks</em> stored on Tableau server. </p><p>Connecting to your Tableau instance via Python to retrieve your view objects is a piece of cake:</p><pre><code class=\"language-python\">import tableauserverclient as TSC\ntableau_auth = TSC.TableauAuth('username', 'password')\nserver = TSC.Server('http://servername')\n\nwith server.auth.sign_in(tableau_auth):\n  all_views, pagination_item = server.views.get()\n  print([view.name for view in all_views])\n</code></pre>\n<p>This simple snippet lists every view object on your server. Wow! Think of what we can do with all that tabular data we worked so hard to transform, rig- <strong>WRONG</strong>. Look at what Tableau's Python 'View Object' actually contains:</p><ul><li><code>id</code> The identifier of the view item.</li><li><code>name</code> The name of the view.</li><li><code>owner_id</code> The id for the owner of the view.</li><li><code>preview_image</code> The thumbnail image for the view.</li><li><code>total_views</code> The usage statistics for the view. Indicates the total number of times the view has been accessed.</li><li><code>workbook_id</code> The id of the workbook associated with the view.</li></ul><p>HOLY MOSES STOP THE PRESSES, we can get a <strong><em>thumbnail image</em></strong> of our data?! THANK YOU GENEROUS TABLEAU OVERLORDS!</p><p>Notice how there's no mention of, you know, the <em>actual data</em>.</p><p>We're going to play a game. In the wake of my time has been wasted, I feel that warm tickling feeling which seems to say <em>\"Viciously dismantle the ambitions of an establishment!\"</em> May I remind you, we're talking about the kind of establishment that bills customer licenses based on the <strong><em>number of CPUs being utilized by their server infrastructure.</em></strong> This is effectively recognizing the horrifying and inefficient codebase behind Tableau server, and leveraging this flaw for monetization. Yes, you're paying more money to incentivize worst practices.</p><h2 id=\"let-s-make-a-flask-app-an-angry-one-\">Let's Make a Flask App. An Angry One.</h2><p>In our last post I shared <a href=\"https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/\">a little script to help you get started stealing data</a> off your own Tableau Server. That doesn't quite scratch my itch anymore. I'm going to build an interface. I want to make it easy as possible for anybody to systemically rob Tableau Server of every penny its got. That's a lot of pennies when we consider the equation: <strong>data = oil + new</strong>.</p><p>Before I bore you, here's a quick demo of the MVP we're building:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/tableau.gif\" class=\"kg-image\"><figcaption>Each table is a view being pulled from Tableau Server.</figcaption></figure><p>This POC demonstrates that it is <em>very</em> possible to automate the extraction of Tableau views from Tableau Server. The <em>success</em> message is signaling that we've successfully taken a Tableau view and <strong>created a corresponding table in an external database</strong>. Any data we manipulate in Tableau is now truly ours: we can now leverage the transforms we've applied in workbooks, use this data in other applications, and utilize an extract scheduler to keep the data coming. We've turned a BI tool into an ETL tool. In other words, you can kindly take those thumbnail previews and shove it.</p><p>I'll be open sourcing all of this, as is my civic duty. Let us be clear to enterprises: withholding freedom to one's own data is an act of war. Pricing models which reward poor craftsmanship are an insult to our intellect. For every arrogant atrocity committed against consumers, the war will wage twice as hard. I should probably mention these opinions are my own.</p><h2 id=\"the-proletariat-strikes-back\">The Proletariat Strikes Back</h2><p>Get a feel for where we're heading with the obligatory project-file-structure tree:</p><pre><code class=\"language-bash\">tableau-exporter\n├── application\n│   ├── __init__.py\n│   ├── database.py\n│   ├── tableau.py\n│   ├── routes.py\n│   ├── static\n│   │   ├── data\n│   │   │   └── view.csv\n│   │   ├── dist\n│   │   │   ├── all.css\n│   │   │   ├── packed.js\n│   │   ├── img\n│   │   │   └── tableaugithub.jpg\n│   │   ├── js\n│   │   │   └── main.js\n│   │   └── scss\n│   │       └── main.scss\n│   └── templates\n│       ├── export.html\n│       ├── index.html\n│       ├── layout.html\n│       └── view.html\n├── config.ini\n├── config.py\n├── app.yaml\n├── start.sh\n├── wsgi.py\n├── Pipfile\n├── README.md\n└── requirements.txt\n</code></pre>\n<p>As usual, we're using a classic Flask <em>application factory</em> set up here.</p><h3 id=\"weapons-of-choice\">Weapons Of Choice</h3><p>Let's have a look at our core arsenal:</p><ul><li><code>requests</code>: We're achieving our goal by exploiting some loopholes exposed in the Tableau REST API.</li><li><code>pandas</code>: Will handle everything from extracting comma-separated data into a CSV, render HTML tables, and output SQL.</li><li><code>flask_sqlalchemy</code>: Used in tandem with <em>pandas</em> to handle shipping our data off elsewhere.</li><li><code>flask_redis</code>: To handle session variables.</li></ul><h3 id=\"initiating-our-application\">Initiating our Application</h3><p>Here's how we construct our app:</p><pre><code class=\"language-python\">from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_redis import FlaskRedis\n\n# Set global entities\ndb = SQLAlchemy()\nr = FlaskRedis()\n\n\ndef create_app():\n    &quot;&quot;&quot;Construct the core application.&quot;&quot;&quot;\n    app = Flask(__name__, instance_relative_config=False)\n    app.config.from_object('config.Config')\n\n    with app.app_context():\n        # Initiate globals\n        db.init_app(app)\n        r.init_app(app, charset=&quot;utf-8&quot;, decode_responses=True)\n\n        # Set global contexts\n        r.set('uri', app.config['SQLALCHEMY_DATABASE_URI'])\n        r.set('baseurl',  app.config['BASE_URL'])\n        r.set('username',  app.config['USERNAME'])\n        r.set('password', app.config['PASSWORD'])\n\n        # Import our modules\n        from . import routes\n        from . import tableau\n        app.register_blueprint(routes.home_blueprint)\n\n        return app\n</code></pre>\n<p>This should all feel like business-as-usual. The core of our application is split between <code>routes.py</code>, which handles views, and <code>tableau.py</code>, which handles the anti-establishment logic. Let's begin with the latter.</p><h2 id=\"life-liberty-and-the-pursuit-of-sick-data-pipelines\">Life, Liberty, and The Pursuit of Sick Data Pipelines</h2><p>Our good friend <code>tableau.py</code> might look familiar to those who joined us <a href=\"https://hackersandslackers.com/tableaus-rest-api-turning-tableau-into-an-etl-pipeline-gui/\">last time</a>. <code>tableau.py</code> has been busy hitting the gym since then and is looking sharp for primetime:</p><pre><code class=\"language-python\">import requests\nimport xml.etree.ElementTree as ET\nfrom . import r\nimport pandas as pd\nimport io\n\n\nclass ExtractTableauView:\n    &quot;&quot;&quot;Class for working in a Tableau instance.&quot;&quot;&quot;\n\n    __baseurl = r.get('baseurl')\n    __username = r.get('username')\n    __password = r.get('password')\n    __database = r.get('uri')\n    __contenturl = r.get('contenturl')\n\n    @classmethod\n    def get_view(cls, site, xml, view, token):\n        &quot;&quot;&quot;Extract contents of a single view.&quot;&quot;&quot;\n        headers = {'X-Tableau-Auth': token,\n                   'Content-Type': 'text/csv'\n                   }\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + str(site) +'/views/' + str(view) + '/data', headers=headers, stream=True)\n        csv_text = req.text\n        view_df = pd.read_csv(io.StringIO(csv_text), header=0)\n        return view_df\n\n    @classmethod\n    def list_views(cls, site, xml, token):\n        &quot;&quot;&quot;List all views belonging to a Tableau Site.&quot;&quot;&quot;\n        headers = {'X-Tableau-Auth': token}\n        req = requests.get(cls.__baseurl + '/api/3.2/sites/' + site + '/views', auth=(cls.__username, cls.__password), headers=headers)\n        root = ET.fromstring(req.content)\n        views_arr = []\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}views':\n                for view in child:\n                    view_dict = {\n                        'name': view.attrib.get('name'),\n                        'id': view.attrib.get('id'),\n                        'url': cls.__baseurl + '/' + view.attrib.get('contentUrl'),\n                        'created': view.attrib.get('createdAt'),\n                        'updated': view.attrib.get('updatedAt')\n                    }\n                    views_arr.append(view_dict)\n        return views_arr\n\n    @classmethod\n    def get_token(cls, xml):\n        &quot;&quot;&quot;Receive Auth token to perform API requests.&quot;&quot;&quot;\n        for child in xml.iter('*'):\n            if child.tag == '{http://tableau.com/api}credentials':\n                token = child.attrib.get('token')\n                return token\n\n    @classmethod\n    def get_site(cls, xml):\n        &quot;&quot;&quot;Retrieve ID of Tableau 'site' instance.&quot;&quot;&quot;\n        root = xml\n        for child in root.iter('*'):\n            if child.tag == '{http://tableau.com/api}site':\n                site = child.attrib.get('id')\n                return site\n\n    @classmethod\n    def initialize_tableau_request(cls):\n        &quot;&quot;&quot;Retrieve core XML for interacting with Tableau.&quot;&quot;&quot;\n        headers = {'Content-Type': 'application/xml'}\n        body = '&lt;tsRequest&gt;&lt;credentials name=&quot;' + cls.__username + '&quot; password=&quot;' + cls.__password + '&quot; &gt;&lt;site contentUrl=&quot;' + cls.__contenturl + '&quot; /&gt;&lt;/credentials&gt;&lt;/tsRequest&gt;'\n        req = requests.post(cls.__baseurl + '/api/3.2/auth/signin', auth=(cls.__username, cls.__password), headers=headers, data=body)\n        root = ET.fromstring(req.content)\n        return root\n</code></pre>\n<p>I wish I could take full credit for what a shit show this class appears to be at first glance, but I assure you we've been left with no choice. For example: have I mentioned that Tableau's REST API returns XML so malformed that it breaks XML parsers? I can't tell incompetence from malicious intent at this point.</p><p>Here's a method breakdown of our class:</p><ul><li><code>initialize_tableau_request()</code>: Handles initial auth and returns valuable information such as site ID and API Token to be used thereafter.</li><li><code>get_site()</code>: Extracts the site ID from XML returned by the above.</li><li><code>get_token()</code>: Similarly extracts our token.</li><li><code>list_views()</code>: Compiles a list of all views within a Tableau site, giving us a chance to select ones for extraction.</li><li><code>get_view()</code>: Takes a view of our choice and creates a DataFrame, which is to be shipped off to a foreign database.</li></ul><h2 id=\"our-routing-logic\">Our Routing Logic</h2><p>Moving on we have <code>routes.py</code> building the views and associated logic for our app:</p><pre><code class=\"language-python\">from flask import current_app as app\nfrom flask import render_template, Blueprint, request, Markup\nfrom flask_assets import Bundle, Environment\nfrom . import tableau\nfrom . import database\nimport pandas as pd\n\nhome_blueprint = Blueprint('home', __name__, template_folder='templates', static_folder='static')\n\nassets = Environment(app)\njs = Bundle('js/*.js', filters='jsmin', output='dist/packed.js')\nscss = Bundle('scss/*.scss', filters='libsass', output='dist/all.css')\nassets.register('scss_all', scss)\nassets.register('js_all', js)\nscss.build()\njs.build()\n\n\n@home_blueprint.route('/', methods=['GET', 'POST'])\ndef entry():\n    &quot;&quot;&quot;Homepage which lists all available views.&quot;&quot;&quot;\n    tableau_view_extractor = tableau.ExtractTableauView()\n    xml = tableau_view_extractor.initialize_tableau_request()\n    token = tableau_view_extractor.get_token(xml)\n    site = tableau_view_extractor.get_site(xml)\n    views = tableau_view_extractor.list_views(site, xml, token)\n    return render_template(\n        'index.html',\n        title=&quot;Here are your views.&quot;,\n        template=&quot;home-template&quot;,\n        views=views,\n        token=token,\n        xml=xml,\n        site=site\n    )\n\n\n@home_blueprint.route('/view', methods=['GET', 'POST'])\ndef view():\n    &quot;&quot;&quot;Displays a preview of a selected view.&quot;&quot;&quot;\n    site = request.args.get('site')\n    xml = request.args.get('xml')\n    view = request.args.get('view')\n    token = request.args.get('token')\n    tableau_view_extractor = tableau.ExtractTableauView()\n    view_df = tableau_view_extractor.get_view(site, xml, view, token)\n    view_df.to_csv('application/static/data/view.csv')\n    return render_template(\n        'view.html',\n        title='Your View',\n        template=&quot;home-template&quot;,\n        view=view,\n        token=token,\n        xml=xml,\n        site=site,\n        view_df=Markup(view_df.to_html(index=False))\n    )\n\n\n@home_blueprint.route('/export', methods=['GET', 'POST'])\ndef export():\n    &quot;&quot;&quot;Exports view to external database.&quot;&quot;&quot;\n    view_df = pd.read_csv('application/static/data/view.csv')\n    view_df.to_sql(name='temp', con=database.engine, if_exists='replace', chunksize=50, index=True)\n    return render_template(\n        'export.html',\n        title='Success!',\n        template=&quot;success-template&quot;,\n    )\n</code></pre>\n<p>We only have 3 pages to our application. They include our list of views, a preview of a single view, and a success page for when said view is exported. This is all core Flask logic.</p><h2 id=\"putting-it-on-display\">Putting it On Display</h2><p>We build our pages dynamically based on the values we pass our Jinja templates. The homepage utilizes some nested loops to list the views we returned from <code>tableau.py</code>, and also makes use of query strings to pass values on to other templates.</p><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block content %}\n&lt;div class=&quot;extended-container {{template}}&quot;&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col s12&quot;&gt;\n        &lt;h1&gt;{{title}}&lt;/h1&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;col s12 flex-container&quot;&gt;\n        {% for view in views %}\n        &lt;div class=&quot;download&quot;&gt;\n          &lt;a href=&quot;{{ url_for('home.view') }}?token={{token}}&amp;site={{site}}&amp;view={{view.id}}&amp;xml={{xml}}&quot;&gt;\n            &lt;ul&gt;\n              {% for key, value in view.items() %}\n              &lt;li&gt;&lt;span class=&quot;key {{key}}&quot;&gt;{{key}}&lt;/span&gt; {{ value }}&lt;/li&gt;\n              {% endfor %}\n            &lt;/ul&gt;\n          &lt;/a&gt;\n        &lt;/div&gt;\n        {% endfor %}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  {% endblock %}\n</code></pre>\n<p>Moving on: our humble <code>view.html</code> page has two purposes: display the selected view, and export it in the name of justice.</p><pre><code class=\"language-html\">{% extends &quot;layout.html&quot; %}\n\n{% block content %}\n&lt;div class=&quot;extended-container {{template}}&quot;&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col s12&quot;&gt;\n        &lt;h1&gt;{{title}}&lt;/h1&gt;\n        &lt;a href=&quot;{{ url_for('home.export') }}&quot; class=&quot;export&quot;&gt;&lt;i class=&quot;far fa-file-export&quot;&gt;&lt;/i&gt;&lt;/a&gt;\n        {{view_df}}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  {% endblock %}\n</code></pre>\n<h2 id=\"the-war-is-not-over\">The War is Not Over</h2><p>This repository is open to the public and can be found <a href=\"https://github.com/toddbirchard/tableau-extraction\">here</a>. There are still crusades left ahead of us: for instance, building out this interface to accept credentials via login as opposed to a config file, and the scheduling of view exports, as opposed to on-demand.</p><p>Where we go from here depends on what we the people decide. For all I know, I could be shouting to an empty room here (I'm almost positive anybody who pays for enterprise software prefers the blind eye of denial). If the opposite holds true, I dare say the revolution is only getting started.</p>","url":"https://hackersandslackers.com/hostile-extraction-of-tableau-server-data/","uuid":"23914fde-b90e-4496-9a7d-56d6ae3765d9","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c3fc99b89c81d4ccc3f64b1"}},"pageContext":{"slug":"hostile-extraction-of-tableau-server-data"}}