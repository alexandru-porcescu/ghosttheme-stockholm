{"data":{"ghostTag":{"slug":"flask","name":"Flask","visibility":"public","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications."},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5c5822200a214230dae40906","title":"Powerful Page Templates in Flask With Jinja","slug":"powerful-page-templates-in-flask-with-jinja","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","excerpt":"Work with markup that writes itself using Flask's built-in Jinja library.","custom_excerpt":"Work with markup that writes itself using Flask's built-in Jinja library.","created_at_pretty":"04 February, 2019","published_at_pretty":"20 July, 2018","updated_at_pretty":"28 March, 2019","created_at":"2019-02-04T06:29:36.000-05:00","published_at":"2018-07-20T06:30:00.000-04:00","updated_at":"2019-03-28T05:18:50.000-04:00","meta_title":"Powerful Page Templates in Flask With Jinja | Hackers and Slackers","meta_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","og_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","og_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","og_title":"Powerful Page Templates in Flask With Jinja","twitter_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","twitter_title":"Powerful Page Templates in Flask With Jinja","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"}],"plaintext":"So you want to build a web application in Python, eh? Hasn't anybody told you...\nPython is SLOW! Python is subject to CONTEXT SWITCHING! Oh, the HORROR!\n\nChances are most of these people aren't well-versed in Python at all. I enjoy\ncreating web applications in Flask more-so than I do in Node. Even if we were to\nput aside somehow the thousands of potentially malicious Javascript libraries\nneeded to stand up a simple app, or the decades of legacy knowledge needed to\ntolerate the JavaScript ecosystem without going insane: the simplicity of Flask\npaired and its libraries get the job done faster in most cases. Oh yeah, and you\ncan write backend logic in a language intended to do  so at the drop of a dime.\n\nOne of Flask's early surprises hits you when working with Jinja2. Jinja is\nFlask's default templating system, which processes templates into HTML markup to\nbe served to users at runtime. In addition to the inheritance and partial\ninclusion we've come to expect from templating systems, Jinja is particularly\nwell-equipped build pages out of raw data. You'll see what I mean.\n\nLayouts, Pages, and Partials\nLet's add three pages to our templates  folder, which is a directory typically\nreserved for template files. We'll add 3 files: layout.html, index.html, and \nnav.html.  Each of these templates represents one of three common template\n\"types\" when building in Jinja. \n\nOh, and disregard the fact that these files retain an HTML file extension- they\nare oh, so much more than that.\n\nmyproject\n├─ /templates\n│  ├─ layout.html\n│  ├─ index.html\n│  └─ nav.html\n└─ app.py\n\n\nCreate a Simple Route to Get Started\nWe'll make a brief stop in app.py  to set up the most basic logic an app can\nhave: serving up a homepage:\n\nfrom flask import Flask, render_template\n\napp = Flask(__name__, template_folder=\"templates\")\n\n@app.route('/')\ndef home():\n    \"\"\"Landing page.\"\"\"\n    return render_template('/index.html', title=\"Lame Site\")\n\n\nNote how we specify template_folder=\"templates\"  when instantiating our app\nobject; this is critical to let Flask know where templates are going to be\nstored in the project directory. Be aware that this directory is almost always\nexplicitly set as /templates. If you store your templates anywhere else, you\nhave a mental health problem.\n\nThe Bread and Butter of Template Inheritance\nLayout.html  is going to be our base template. In other words, this barebones\nfile will represent elements which should be common to all  of our app's pages,\nsuch as metadata, analytics, etc. It is the 'page we load other pages into.'  \n\nIf you're familiar with Handlebars\n[https://hackersandslackers.com/handlebars-templating-in-expressjs/], Jinja's\ntemplating concepts are the same deal with slightly different syntax. Here's a\ndecent layout.html  example:\n\n<!-- layout.html -->\n<!doctype html>\n<html>\n<head>\n  <title>{{title}}</title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\">\n    <!-- Google Analytics -->\n    <script>\n    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;\n    ga('create', 'UA-XXXXX-Y', 'auto');\n    ga('send', 'pageview');\n    </script>\n    <script async src='https://www.google-analytics.com/analytics.js'></script>\n    <!-- End Google Analytics -->\n</head>\n<body>\n  {% include 'nav.html' %}\n  {% block content %}{% endblock %}\n  {% include 'footer.html' %}\n</body>\n</html>\n\n\nNote the bracketed values in our otherwise-HTML! Each of these represents a\nreservation of \"stuff to come.\" That \"stuff\" could come in the form of a\nvariable, a partial, or code from another template. \n\nWe've just utilized three templating concepts in the above example:\n\n * The double-bracket {{title}}  is reserved to be replaced with a variable\n   named 'title' when we serve this view in Flask. We pass variables to\n   templates when we render them in the 'routes' part of our app.\n * Includes such as {% include 'nav.html' %}  are saying \"load the entirety of a\n   separate HTML file named nav.html  into this spot right here.\" This is called\n   a partial. Partials are encapsulated, standalone components intended to be\n   frequently reused throughout our app.\n * Things get real interesting with blocks, as seen in {% block content %}{%\n   endblock %}. This statement is reserving a chunk  of our template to receive\n   a corresponding chunk  of another template when such a template is loaded\n   into layout.hml. Remember: layouts are just barebones commonalities between\n   pages. To build meaningful pages, we must combine the parts of unique pages\n   (such as index.html) with layouts to create full pages. \n\nLet's look at index.html:  the file we're about to shove into layout.html:\n\n<!-- index.html -->\n{% extends 'layout.html' %}\n\n{% block content %}\n<div class=\"container\">\n<h1>My Lame site</h1>\n    <p>Hello, and welcome to my lame site! I'm so glad you're here. I'm so lonely.</p>\n</div>\n{% endblock %}\n\n\nRemember in the route we created in app.py:  our function states \"load\nindex.html when users visit /.\" We never mention layout.html  at all. That is\nbecause by including {% extends 'layout.html' %}  in  index.html, we're  stating\nthat index.html  should extend  layout.html. index.html  is our unique snowflake\nof a page, and layout  is our boring skeleton.\n\nBack to talking about blocks:  templates can contain multiple \"blocks\" of code.\nEach named block (such as  {% block content %}) in a page such as index.html \nshould correspond to an empty block we reserved in layout.html. When we serve\nthe final page, it's like we're plugging plugs into their respective sockets. We\ncan reserve as many \"blocks\" in our layout as we want, and thus serve multiple\nblocks within the same template. \n\nTo help illustrate this, let's say you're building a horrible clickbait site\nwhere your requirements dictate that horrible, invasive ads should appear\nbetween pieces of content of every page of your site. If we keep that page\nstructure to layout.html, then we can retrofit our layout to have multiple slots\nfor incoming content from index.html:  both before  and after  the horrible\nmonstrosity of an idea I already regret imagining. If index.html  contained both\n {% block content1 %}...{% endblock %}  and {% block content2 %}...{% endblock\n%}, those blocks are now independent entities which can be loaded to their\nrespective slots.\n\nPassing Data to Templates\nWhen we passed title=\"Lame Site\"  to index.html in our route, we were passing a\nsimple variable to replace {{title}}. Check out this example of what we can do\nwhen we pass JSON objects to templates:\n\n<form action=\"/submitted\" method=post>\n  {% if error %}\n   <p class=error><strong>Error:</strong> {{ error }}</p>\n  {% endif %}\n  {% for field in request.fields.requestTypeFields %}\n     {% if field.name in ('Category', 'Product', 'Dashboard Name') %}\n          <select id=\"{{request.name}} {{field.name}}\" \n                  name=\"{{field.name}}\" \n                  label=\"{{field.name}}\" \n                  class=\"input-field\">\n           <option value=\"Choose your option\" \n                   disabled \n                   selected>\n               {{field.description}}\n            </option>\n            {% for option in field.validValues %}\n                <option value=\"{{option.value}}\">\n                    {{option.label}}\n                </option>\n                {% endfor %}\n            </select>\n            <label>{{field.name}}</label>\n       {% elif field.name == 'Description' %}\n            <label for=\"{{request.name}} {{field.name}}\">\n                {{field.name}}\n            </label>\n            <textarea id=\"{{field.name}}\" \n                      class=\"materialize-textarea input-field\" \n                      placeholder=\"{{field.description}}\" \n                      name=\"{{field.name}}\">\n             </textarea>\n         {% else %}\n         <label for=\"{{request.name}} {{field.name}}\">\n             {{field.name}}\n         </label>\n         <input placeholder=\"{{field.description}}\" \n                id=\"{{request.name}} {{field.name}}\" \n                type=\"text\" \n                class=\"input-field validate\" \n                name=\"{{field.name}}\">\n         {% endif %}\n    {% endfor %}\n    <input type=\"submit\" value=\"Submit\" class=\"btn cyan formsubmit\">\n</form>\n\n\nThose are for  loops and if  statements all working against a single JSON\nobject. This specific example demonstrates building a form based on a JSON\nobject; one we've happened to fetch from JIRA. Just by passing this JSON to a\nJinja template, we can recreate an entire enterprise system's form logic in a\nsimple template block.\n\nHere's another example. This one returns feedback to a user who presumably\nfilled out a form incorrectly, thus must be chastised with popup error messages:\n\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n\n\nSmall But Powerful\nTemplates are one small part of Flask, but they demonstrate a greater philosophy\ngenerally consistent throughout the framework: small libraries can do big\nthings. Sometimes it may take some courage to maneuver with the tools at hand\ncleverly, but the power of the Triforce is with you. You are Hyrule's last hope,\ngreat warrior... now you must make haste in your duties to build little apps. Or\nwhatever.","html":"<p>So you want to build a web application in Python, eh? Hasn't anybody told you... Python is <em>SLOW</em>! Python is subject to <em>CONTEXT SWITCHING</em>! Oh, the <em>HORROR</em>!</p><p>Chances are most of these people aren't well-versed in Python at all. I enjoy creating web applications in Flask more-so than I do in Node. Even if we were to put aside somehow the thousands of potentially malicious Javascript libraries needed to stand up a simple app, or the decades of legacy knowledge needed to tolerate the JavaScript ecosystem without going insane: the simplicity of Flask paired and its libraries get the job done faster in most cases. Oh yeah, and you can write backend logic in a language <em>intended to do</em> so at the drop of a dime.</p><p>One of Flask's early surprises hits you when working with <strong>Jinja2</strong>. Jinja is Flask's default templating system, which processes templates into HTML markup to be served to users at runtime. In addition to the inheritance and partial inclusion we've come to expect from templating systems, Jinja is particularly well-equipped build pages out of raw data. You'll see what I mean.</p><h2 id=\"layouts-pages-and-partials\">Layouts, Pages, and Partials</h2><p>Let's add three pages to our <em>templates</em> folder, which is a directory typically reserved for template files. We'll add 3 files: <strong>layout.html, index.html, </strong>and <strong>nav.html.</strong> Each of these templates represents one of three common template \"types\" when building in Jinja. </p><p>Oh, and disregard the fact that these files retain an HTML file extension- they are oh, so much more than that.</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">myproject\n├─ /templates\n│  ├─ layout.html\n│  ├─ index.html\n│  └─ nav.html\n└─ app.py\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"create-a-simple-route-to-get-started\">Create a Simple Route to Get Started</h2><p>We'll make a brief stop in <strong>app.py</strong> to set up the most basic logic an app can have: serving up a homepage:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, render_template\n\napp = Flask(__name__, template_folder=&quot;templates&quot;)\n\n@app.route('/')\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    return render_template('/index.html', title=&quot;Lame Site&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Note how we specify <code>template_folder=\"templates\"</code> when instantiating our app object; this is critical to let Flask know where templates are going to be stored in the project directory. Be aware that this directory is almost always explicitly set as /<em>templates. </em>If you store your templates anywhere else, you have a mental health problem.</p><h2 id=\"the-bread-and-butter-of-template-inheritance\">The Bread and Butter of Template Inheritance</h2><p><strong>Layout.html</strong> is going to be our base template. In other words, this barebones file will represent elements which should be common to <em>all</em> of our app's pages, such as metadata, analytics, etc. It is the '<em>page we load other pages into.'</em> </p><p>If you're familiar with <a href=\"https://hackersandslackers.com/handlebars-templating-in-expressjs/\">Handlebars</a>, Jinja's templating concepts are the same deal with slightly different syntax. Here's a decent <strong>layout.html</strong> example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;!-- layout.html --&gt;\n&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;{{title}}&lt;/title&gt;\n  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;\n    &lt;!-- Google Analytics --&gt;\n    &lt;script&gt;\n    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;\n    ga('create', 'UA-XXXXX-Y', 'auto');\n    ga('send', 'pageview');\n    &lt;/script&gt;\n    &lt;script async src='https://www.google-analytics.com/analytics.js'&gt;&lt;/script&gt;\n    &lt;!-- End Google Analytics --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  {% include 'nav.html' %}\n  {% block content %}{% endblock %}\n  {% include 'footer.html' %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Note the bracketed values in our otherwise-HTML! Each of these represents a reservation of \"stuff to come.\" That \"stuff\" could come in the form of a variable, a partial, or code from another template. </p><p>We've just utilized three templating concepts in the above example:</p><ul><li>The double-bracket <code>{{title}}</code> is reserved to be replaced with a variable named 'title' when we serve this view in Flask. We pass variables to templates when we render them in the 'routes' part of our app.</li><li>Includes such as <code>{% include 'nav.html' %}</code> are saying \"load the entirety of a separate HTML file named <strong>nav.html</strong> into this spot right here.\" This is called a <em>partial</em>. Partials are encapsulated, standalone components intended to be frequently reused throughout our app.</li><li>Things get real interesting with <em>blocks</em>, as seen in <code>{% block content %}{% endblock %}</code>. This statement is reserving a <em>chunk</em> of our template to receive a <em>corresponding chunk</em> of another template when such a template is loaded into <strong>layout.hml</strong>. Remember: layouts are just barebones commonalities between pages. To build meaningful pages, we must combine the parts of unique pages (such as <strong>index.html</strong>) with layouts to create full pages. </li></ul><p>Let's look at <strong>index.html:</strong> the file we're about to shove into <strong>layout.html:</strong></p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;!-- index.html --&gt;\n{% extends 'layout.html' %}\n\n{% block content %}\n&lt;div class=&quot;container&quot;&gt;\n&lt;h1&gt;My Lame site&lt;/h1&gt;\n    &lt;p&gt;Hello, and welcome to my lame site! I'm so glad you're here. I'm so lonely.&lt;/p&gt;\n&lt;/div&gt;\n{% endblock %}\n</code></pre>\n<!--kg-card-end: markdown--><p>Remember in the route we created in <strong>app.py:</strong> our function states <em>\"load index.html when users visit /.\" </em>We never mention <strong>layout.html</strong> at all. That is because by including <code>{% extends 'layout.html' %}</code><strong> </strong>in<strong> index.html, </strong>we're<strong> </strong>stating that <strong>index.html</strong> should <em>extend</em> <strong>layout.html. index.html</strong> is our unique snowflake of a page, and <strong>layout</strong> is our boring skeleton.</p><p>Back to talking about blocks:  templates can contain multiple \"blocks\" of code. Each named block (such as<strong> </strong><code>{% block content %}</code>) in a page such as <strong>index.html</strong> should correspond to an empty block we reserved in <strong>layout.html</strong>. When we serve the final page, it's like we're plugging plugs into their respective sockets. We can reserve as many \"blocks\" in our layout as we want, and thus serve multiple blocks within the same template. </p><p>To help illustrate this, let's say you're building a horrible clickbait site where your requirements dictate that horrible, invasive ads should appear between pieces of content of every page of your site. If we keep that page structure to <strong>layout.html</strong>, then we can retrofit our layout to have multiple slots for incoming content from <strong>index.html:</strong> both <em>before</em> and <em>after</em> the horrible monstrosity of an idea I already regret imagining. If <strong>index.html</strong> contained both <code>{% block content1 %}...{% endblock %}</code> and <code>{% block content2 %}...{% endblock %}</code>, those blocks are now independent entities which can be loaded to their respective slots.</p><h2 id=\"passing-data-to-templates\">Passing Data to Templates</h2><p>When we passed <code>title=\"Lame Site\"</code> to <strong>index.html </strong>in our route, we were passing a simple variable to replace <code>{{title}}</code>. Check out this example of what we can do when we pass JSON objects to templates:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;form action=&quot;/submitted&quot; method=post&gt;\n  {% if error %}\n   &lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt; {{ error }}&lt;/p&gt;\n  {% endif %}\n  {% for field in request.fields.requestTypeFields %}\n     {% if field.name in ('Category', 'Product', 'Dashboard Name') %}\n          &lt;select id=&quot;{{request.name}} {{field.name}}&quot; \n                  name=&quot;{{field.name}}&quot; \n                  label=&quot;{{field.name}}&quot; \n                  class=&quot;input-field&quot;&gt;\n           &lt;option value=&quot;Choose your option&quot; \n                   disabled \n                   selected&gt;\n               {{field.description}}\n            &lt;/option&gt;\n            {% for option in field.validValues %}\n                &lt;option value=&quot;{{option.value}}&quot;&gt;\n                    {{option.label}}\n                &lt;/option&gt;\n                {% endfor %}\n            &lt;/select&gt;\n            &lt;label&gt;{{field.name}}&lt;/label&gt;\n       {% elif field.name == 'Description' %}\n            &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;\n                {{field.name}}\n            &lt;/label&gt;\n            &lt;textarea id=&quot;{{field.name}}&quot; \n                      class=&quot;materialize-textarea input-field&quot; \n                      placeholder=&quot;{{field.description}}&quot; \n                      name=&quot;{{field.name}}&quot;&gt;\n             &lt;/textarea&gt;\n         {% else %}\n         &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;\n             {{field.name}}\n         &lt;/label&gt;\n         &lt;input placeholder=&quot;{{field.description}}&quot; \n                id=&quot;{{request.name}} {{field.name}}&quot; \n                type=&quot;text&quot; \n                class=&quot;input-field validate&quot; \n                name=&quot;{{field.name}}&quot;&gt;\n         {% endif %}\n    {% endfor %}\n    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; class=&quot;btn cyan formsubmit&quot;&gt;\n&lt;/form&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Those are <code>for</code> loops and <code>if</code> statements all working against a single JSON object. This specific example demonstrates building a form based on a JSON object; one we've happened to fetch from JIRA. Just by passing this JSON to a Jinja template, we can recreate an entire enterprise system's form logic in a simple template block.</p><p>Here's another example. This one returns feedback to a user who presumably filled out a form incorrectly, thus must be chastised with popup error messages:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    &lt;ul class=flashes&gt;\n    {% for message in messages %}\n      &lt;li&gt;{{ message }}&lt;/li&gt;\n    {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n{% endwith %}\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"small-but-powerful\">Small But Powerful</h3><p>Templates are one small part of Flask, but they demonstrate a greater philosophy generally consistent throughout the framework: small libraries can do big things. Sometimes it may take some courage to maneuver with the tools at hand cleverly, but the power of the Triforce is with you. You are Hyrule's last hope, great warrior... now you must make haste in your duties to build little apps. Or whatever.</p>","url":"https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/","uuid":"055ba6eb-f177-4b9d-b85e-2c7730850bf1","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c5822200a214230dae40906"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb867369f","title":"Creating Your First Flask Application","slug":"creating-your-first-flask-application","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/07/flask-gettingstarted@2x.jpg","excerpt":"After achieving market dominance, Flask is a Python framework impossible to avoid.","custom_excerpt":"After achieving market dominance, Flask is a Python framework impossible to avoid.","created_at_pretty":"08 July, 2018","published_at_pretty":"08 July, 2018","updated_at_pretty":"21 February, 2019","created_at":"2018-07-08T16:06:24.000-04:00","published_at":"2018-07-08T17:51:42.000-04:00","updated_at":"2019-02-21T17:05:15.000-05:00","meta_title":"Creating Your First Flask Application | Hackers and Slackers","meta_description":"After achieving market dominance, Flask is a Python framework impossible to avoid. Learn the basics of creating a Flask web app or API.","og_description":"After achieving market dominance, Flask is a Python framework impossible to avoid. Learn the basics of creating a Flask web app or API.","og_image":"https://hackersandslackers.com/content/images/2018/07/flask-gettingstarted@2x.jpg","og_title":"Creating Your First Flask Application","twitter_description":"After achieving market dominance, Flask is a Python framework impossible to avoid. Learn the basics of creating a Flask web app or API.","twitter_image":"https://hackersandslackers.com/content/images/2018/07/flask-gettingstarted@2x.jpg","twitter_title":"Creating Your First Flask Application","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Architecture","slug":"architecture","description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to Lambda functions, Docker containers, Google Cloud functions,  Kubernetes, Heroku, etc.","feature_image":null,"meta_description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to cloud functions, Docker containers, Kubernetes, Heroku, etc.","meta_title":"Software Architecture | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"Evidence of Flask’s rise to power has been all around us for a couple of years\nnow. Anybody paying close attention to the technology stacks chosen by startups\nhas undoubtedly noticed a flip: at some point, the industry standard flipped\naway from Django entirely. \n\nHuge bets are being placed on Flask across the industry. Plotly’s  famous Dash \nproduct is an extension of Flask which has seen significant success. Even major\ncloud providers, namely Google Cloud, are choosing to default to Flask for\nPython implementations of serverless apps. Google Cloud Functions and Google App\nEngine both ship with Flask running at their core. JetBrains finally put an\nofficial number to this trend with their 2018 Python survey\n[https://www.jetbrains.com/research/python-developers-survey-2018/]: 47%  of\ndevs report using Flask to Django’s 45%. Game: Blouses.\n\nFlask wins market dominence in 2018.Put down the pitchforks: this isn’t a Flask\nvs. Django post, nor are we implying that one framework is superior to the\nother. Both frameworks have their place, with that “place” being in the realm of\npreference.\n\nWhy Flask?\nDeveloping apps in Flask has a much different narrative than when developing in\nmore traditional MVC Frameworks. In the past, the setup of a framework would\neasily take hours: with the assumption that our app needed all the bells and\nwhistles, it was impossible to get a “Hello world!” off the ground without a\nfull understanding of database configurations, static assets, templates, and\nother things our app may not even need. This is especially a concern for the\nPython ecosystem. Few people turn to Python for the sole purpose of building a\nweb app: the vast majority of Python developers are in the field of data\nanalysis without a traditional background in application development. Asking\ndata analysts (who have mostly become accustomed to Jupyter notebooks) to pick\nup all the fundamentals of web development before even getting started is just\nunrealistic.\n\nFlask's setup is merely a copy+paste of the following five lines:\n\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\n\nThose five lines create a live Flask application. Without any other knowledge\nabout the framework, we can immediately plug in any Python logic we already have\nto change “Hello world!” to match any output imaginable. While it's possible to\ncreate an entire Flask application as a single tiny file, Flask can be as\nextended to be just as powerful and complex as its predecessors. When the author\nof a Flask application deems it necessary, various Flask plugins can be pulled\nin to give us robust application logic. Examples include:\n\n * Flask-SQLAlchemy  for database interaction.\n * Flask-Sessions  for user session management.\n * Flask-Login  to manage user logins.\n * Literally hundreds [https://github.com/humiaozuzu/awesome-flask]  of other\n   libraries.\n\nThis plug-and-play structure makes Flask projects feel more expressive while\nsimultaneously providing simplicity to developers starting from 0. Not only\nthat, but reading somebody else’s source suddenly becomes simple: I know this\napp must do XYZ, because this person has imported XYZ.\n\nDissecting Flask’s “Hello World!”\nLet's go back to our 5-line application to pick apart the specifics:\n\nfrom flask import Flask \napp = Flask(__name__)\n\n\nThe most important part of the Flask Python library is Flask  with a capital “F”\n(as in: from flask import Flask).  This five-letter word creates an object which\nrefers to the entirety of the app itself: when we state app = Flask(__name__),\nwe are creating the variable app  which represents our application. Therefore,\nwhen we configure the variable app,  we’re configuring the way our entire\napplication works. For example, setting app = Flask()  can accept a few\nattributes:\n\nfrom flask import Flask\n\napp = Flask(__name__,\n            instance_relative_config=False,\n            template_folder=\"templates\",\n            static_folder=\"static\"\n            )\n\n\nThis is an example of creating a Flask app with a few specifics: the location of\nour config file, the folder in which we'll store pages templates, and the folder\nin which we'll store frontend assets (JS, CSS, images, etc.).\n\nA Basic Flask Route\nThe primary function of our app is called hello(), which is importantly wrapped\nby Flask's most important decorator: .route(). If you aren't familiar with \ndecorators  in Python, a decorator is a function for us to wrap other functions\nwith. It isn't critically important to know all the details, other than that\nFlask comes with a route decorator which allows us to serve up functions based\non which page of the app the user is loading. By setting @app.route(\"/\"), we are\nspecifying that the function hello()  should fire whenever somebody uses our\napp.\n\nOf course, we can return any value besides \"Hello world!\" if we wanted. Let's\nsay you've already a script which returns the square of a number, plus 9. We\ncould save that logic in a function called squareOfNumberPlusNine(), in a file\ncalled logic.py. Now, our script can look like this:\n\nfrom flask import Flask\nfrom logic import squareOfNumberPlusNine\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    value = squareOfNumberPlusNine(5)\n    return value\n\n\nThis would return 34  as opposed to \"Hello world!\". Without any prior knowledge\nof Python web development, we can already use Flask to plug into logic we've\nwritten and serve up a result.\n\nOther Parts of Flask's Core Library\nWe can import other things from flask  besides Flask. Here are some examples:\n\nServing Raw HTML\nMarkup  allows us to return an HTML page by rendering a string as HTML:\n\nfrom flask import Flask, Markup\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return Markup(\"<h1>Hello World!</h1>\")\n\n\nServing an HTML Page Template\nreturn_template  will return an HTML page by finding the page in our /templates \nfolder:\n\nfrom flask import Flask, render_template\napp = Flask(__name__, template_folder=\"templates\")\n\n@app.route(\"/\")\ndef hello():\n    return render_template(\"index.html\")\n\n\nServing a JSON Response \nmake_response  is suitable if our application is an API and we'd like to return\na response object:\n\nfrom flask import Flask, make_response\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    headers = {\"Content-Type\": \"application/json\"}\n    return make_response('it worked!', 200, headers=headers)\n\n\nOn the topic of creating APIs with Flask, we can also specify whether the route\nat hand is a POST, GET, or some other method. This is handled easily within the\nroute decorator:\n\nfrom flask import Flask, make_response, request\napp = Flask(__name__)\n\n@app.route(\"/\", methods=['GET'])\ndef hello():\n    if request.method != 'GET':\n        return make_response('Malformed request', 400)\n    headers = {\"Content-Type\": \"application/json\"}\n    return make_response('it worked!', 200, headers=headers)\n\n\nThe above function checks to make sure the user is accessing the endpoint with\nthe correct method first. If they've used the incorrect method, we return an\nerror.\n\nSuccumb to Flask\nEven if you chose to stick to your large Frameworks, it's easy to see why Flask\nis useful as a drop-in solution for many tasks. There are undoubtedly plenty of\nuseful Python scripts which go wasted because the final step of making them\neasily consumable by other people was never completed. Flask is an excellent way\nto achieve this last step, and the best part is: you already know how to use it.","html":"<p>Evidence of Flask’s rise to power has been all around us for a couple of years now. Anybody paying close attention to the technology stacks chosen by startups has undoubtedly noticed a flip: at some point, the industry standard flipped away from Django entirely. </p><p>Huge bets are being placed on Flask across the industry. <strong>Plotly’s</strong> famous <strong>Dash</strong> product is an extension of Flask which has seen significant success. Even major cloud providers, namely <strong>Google Cloud</strong>, are choosing to default to Flask for Python implementations of serverless apps. Google Cloud Functions and Google App Engine both ship with Flask running at their core. JetBrains finally put an official number to this trend with their <a href=\"https://www.jetbrains.com/research/python-developers-survey-2018/\">2018 Python survey</a>: <strong>47%</strong> of devs report using Flask to Django’s <strong>45%</strong>. Game: Blouses.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/Screen-Shot-2019-02-13-at-4.36.00-PM.png\" class=\"kg-image\"><figcaption>Flask wins market dominence in 2018.</figcaption></figure><p>Put down the pitchforks: this isn’t a Flask vs. Django post, nor are we implying that one framework is superior to the other. Both frameworks have their place, with that “place” being in the realm of preference.</p><h2 id=\"why-flask\">Why Flask?</h2><p>Developing apps in Flask has a much different narrative than when developing in more traditional MVC Frameworks. In the past, the setup of a framework would easily take hours: with the assumption that our app needed all the bells and whistles, it was impossible to get a “Hello world!” off the ground without a full understanding of database configurations, static assets, templates, and other things our app may not even need. This is especially a concern for the Python ecosystem. Few people turn to Python for the sole purpose of building a web app: the vast majority of Python developers are in the field of data analysis without a traditional background in application development. Asking data analysts (who have mostly become accustomed to Jupyter notebooks) to pick up all the fundamentals of web development before even getting started is just unrealistic.</p><p>Flask's setup is merely a copy+paste of the following five lines:</p><pre><code class=\"language-python\">from flask import Flask\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    return &quot;Hello World!&quot;\n</code></pre>\n<p>Those five lines create a live Flask application. Without any other knowledge about the framework, we can immediately plug in any Python logic we already have to change “Hello world!” to match any output imaginable. While it's possible to create an entire Flask application as a single tiny file, Flask can be as extended to be just as powerful and complex as its predecessors. When the author of a Flask application deems it necessary, various Flask plugins can be pulled in to give us robust application logic. Examples include:</p><ul><li><strong>Flask-SQLAlchemy</strong> for database interaction.</li><li><strong>Flask-Sessions</strong> for user session management.</li><li><strong>Flask-Login</strong> to manage user logins.</li><li>Literally <a href=\"https://github.com/humiaozuzu/awesome-flask\">hundreds</a> of other libraries.</li></ul><p>This plug-and-play structure makes Flask projects feel more expressive while simultaneously providing simplicity to developers starting from 0. Not only that, but reading somebody else’s source suddenly becomes simple: I know this app must do XYZ, because this person has imported XYZ.</p><h2 id=\"dissecting-flask-s-hello-world-\">Dissecting Flask’s “Hello World!”</h2><p>Let's go back to our 5-line application to pick apart the specifics:</p><pre><code class=\"language-python\">from flask import Flask \napp = Flask(__name__)\n</code></pre>\n<p>The most important part of the Flask Python library is <strong>Flask</strong> with a capital “F” (as in: <code>from flask import Flask</code>).  This five-letter word creates an object which refers to the entirety of the app itself: when we state <code>app = Flask(__name__)</code>, we are creating the variable <strong>app</strong> which represents our application. Therefore, when we configure the variable <strong>app,</strong> we’re configuring the way our entire application works. For example, setting <code>app = Flask()</code> can accept a few attributes:</p><pre><code class=\"language-python\">from flask import Flask\n\napp = Flask(__name__,\n            instance_relative_config=False,\n            template_folder=&quot;templates&quot;,\n            static_folder=&quot;static&quot;\n            )\n</code></pre>\n<p>This is an example of creating a Flask app with a few specifics: the location of our config file, the folder in which we'll store pages templates, and the folder in which we'll store frontend assets (JS, CSS, images, etc.).</p><h3 id=\"a-basic-flask-route\">A Basic Flask Route</h3><p>The primary function of our app is called <code>hello()</code>, which is importantly wrapped by Flask's most important decorator: <code>.route()</code>. If you aren't familiar with <strong>decorators</strong> in Python, a decorator is a function for us to wrap other functions with. It isn't critically important to know all the details, other than that Flask comes with a route decorator which allows us to serve up functions based on which page of the app the user is loading. By setting <code>@app.route(\"/\")</code>, we are specifying that the function <code>hello()</code> should fire whenever somebody uses our app.</p><p>Of course, we can return any value besides \"Hello world!\" if we wanted. Let's say you've already a script which returns the square of a number, plus 9. We could save that logic in a function called <code>squareOfNumberPlusNine()</code>, in a file called <code>logic.py</code>. Now, our script can look like this:</p><pre><code class=\"language-python\">from flask import Flask\nfrom logic import squareOfNumberPlusNine\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    value = squareOfNumberPlusNine(5)\n    return value\n</code></pre>\n<p>This would return <strong>34</strong> as opposed to \"<strong>Hello world!\"</strong>. Without any prior knowledge of Python web development, we can already use Flask to plug into logic we've written and serve up a result.</p><h2 id=\"other-parts-of-flask-s-core-library\">Other Parts of Flask's Core Library</h2><p>We can import other things <code>from flask</code> besides <code>Flask</code>. Here are some examples:</p><h3 id=\"serving-raw-html\">Serving Raw HTML</h3><p><code>Markup</code> allows us to return an HTML page by rendering a string as HTML:</p><pre><code class=\"language-python\">from flask import Flask, Markup\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    return Markup(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;)\n</code></pre>\n<h3 id=\"serving-an-html-page-template\">Serving an HTML Page Template</h3><p><code>return_template</code> will return an HTML page by finding the page in our <code>/templates</code> folder:</p><pre><code class=\"language-python\">from flask import Flask, render_template\napp = Flask(__name__, template_folder=&quot;templates&quot;)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    return render_template(&quot;index.html&quot;)\n</code></pre>\n<h3 id=\"serving-a-json-response\">Serving a JSON Response </h3><p><code>make_response</code> is suitable if our application is an API and we'd like to return a response object:</p><pre><code class=\"language-python\">from flask import Flask, make_response\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}\n    return make_response('it worked!', 200, headers=headers)\n</code></pre>\n<p>On the topic of creating APIs with Flask, we can also specify whether the route at hand is a POST, GET, or some other method. This is handled easily within the route decorator:</p><pre><code class=\"language-python\">from flask import Flask, make_response, request\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;, methods=['GET'])\ndef hello():\n    if request.method != 'GET':\n        return make_response('Malformed request', 400)\n    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}\n    return make_response('it worked!', 200, headers=headers)\n</code></pre>\n<p>The above function checks to make sure the user is accessing the endpoint with the correct method first. If they've used the incorrect method, we return an error.</p><h2 id=\"succumb-to-flask\">Succumb to Flask</h2><p>Even if you chose to stick to your large Frameworks, it's easy to see why Flask is useful as a drop-in solution for many tasks. There are undoubtedly plenty of useful Python scripts which go wasted because the final step of making them easily consumable by other people was never completed. Flask is an excellent way to achieve this last step, and the best part is: you already know how to use it.</p>","url":"https://hackersandslackers.com/creating-your-first-flask-application/","uuid":"dac63aa8-2a5d-4d3e-a6b1-cccc5785764c","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b426ec02d99b9040e300f74"}},{"node":{"id":"Ghost__Post__5c64981a7c8ecc6ee30c6870","title":"Starting a Python Web App with Heroku","slug":"starting-a-python-web-app-with-heroku","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/flask2@2x.jpg","excerpt":"Pairing Flask with zero-effort container deployments is a deadly path to addiction.","custom_excerpt":"Pairing Flask with zero-effort container deployments is a deadly path to addiction.","created_at_pretty":"13 February, 2019","published_at_pretty":"13 February, 2018","updated_at_pretty":"13 February, 2019","created_at":"2019-02-13T17:20:10.000-05:00","published_at":"2018-02-13T17:20:00.000-05:00","updated_at":"2019-02-13T17:57:20.000-05:00","meta_title":"Starting a Python Application with Heroku | Hackers and Slackers","meta_description":"Flask is a gift to developers who value the act of development. Pairing Python with zero-effort container deployments is a deadly path to addiction.","og_description":"Flask is a gift to developers who value the act of development. Pairing Python with zero-effort container deployments is a deadly path to addiction.","og_image":"https://hackersandslackers.com/content/images/2019/02/flask2@2x.jpg","og_title":"Starting a Python Application with Heroku | Hackers and Slackers","twitter_description":"Flask is a gift to developers who value the act of development. Pairing Python with zero-effort container deployments is a deadly path to addiction.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/flask2@2x.jpg","twitter_title":"Starting a Python Application with Heroku | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Architecture","slug":"architecture","description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to Lambda functions, Docker containers, Google Cloud functions,  Kubernetes, Heroku, etc.","feature_image":null,"meta_description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to cloud functions, Docker containers, Kubernetes, Heroku, etc.","meta_title":"Software Architecture | Hackers and Slackers","visibility":"public"}],"plaintext":"It's difficult to cover every cloud solution on the market without at least\nmentioning Heroku. Heroku contrasts nearly every cloud hosting solution by\noffering a clear purpose: make deploying apps of any kind as easy as possible.\nDeploying to a VPS requires knowledge of web servers and configurations.\nDeploying to containers requires knowledge of Docker or Kubernetes. Deploying to\nHeroku requires nearly no prior knowledge of anything.\n\nHeroku is great for getting MVPs out the door, or for devs who want to jump into\ndeveloping web applications with knowledge of a specific language. Even\ndevelopers with advanced knowledge of how to deploy production applications may\nwant to use Heroku for fast internal deployments, or as a platform for\n\"sketching out\" a quick prototype.\n\nIn this exploration, we'll be using Heroku to deploy a Python application using\nthe Flask framework.\n\nWhy Heroku?\nWe're on the topic of simplicity, so let's keep that theme going. Heroku's\ninfrastructure offering is unique in that Heroku obfuscates the DevOps aspect of\nweb development completely. That means that configuring web servers, managing\nLinux packages, and supplying SSL certs are entirely taken care of by Heroku. \n\nLet's consider Heroku's ease-of-use services to be luxuries which save us time.\nThey are NOT  a replacement for grasping these concepts.\n\nPipelines\nAside from VPS upkeep, Heroku obfuscates the process of moving an app through\ndevelopment and production environments by defining pipelines. That's right,\nCI/CD is built directly into Heroku's interface.\n\nAdd-ons\nThe most addictive aspect of Heroku is probably the Elements marketplace. This\nis a place to window-shop for set-it-and-forget-it plugins for your app, most of\nwhich are very easy to integrate with. \n\nMost add-ons fall under a few major categories: database resellers, analytics,\nand Redis, to name a few (interestingly enough, using the base Redis add-on in\nHeroku is free, while the equivalent instance would cost you 5 dollars from the\nsame provider had you used them directly. Add-ons are \"deployed\" after a single\nclick, and the ensuing configuration process varies from vendor-to-vendor after\nthat.\n\nSpeaking of single-click, they handle single-click deployments of popular build\npacks, too. You, the thing that made DigitalOcean a big deal way back. You get\nthe idea.\n\nCreating your Project\nLog in to the Heroku UI and create an app on a fresh Dyno. A Dyno is merely a\nfancy, overly branded word for \"container.\" Next, you'll be prompted to download\nthe Heroku CLI locally on your OS of choice, which is quick and painless. Now\nwe're cooking with gas.\n\nCreate an empty local directory and type the following command to be prompted\nfor your Heroku account credentials:\n\n$ heroku login\nEnter your Heroku credentials.\nEmail: python@example.com\nPassword:\n\n\nAt this point, Heroku has already magically created a git repository for your\napplication from which you'll be doing development from.\n\n$ git clone https://github.com/heroku/example-flask-project.git\n$ cd example-flask-project\n\n$ heroku create\nCreating example-flask-project in organization heroku... done, stack is cedar-14\nhttp://example-flask-project.herokuapp.com/ | https://git.heroku.com/example-flask-project.git\nGit remote heroku added\n\n\nWow, that sure looks a lot like we're working with Github huh? That's actually\nthe point: if you so chose, you can configure the Heroku CLI to recognize your\nGithub username with a simple heroku config:get GITHUB_USERNAME=yourname. With\nthis configured, Heroku will actually allow you to simply deploy to your\npersonal Github repo and mimic the changes on your Dyno. Now let's configure\nthis thing.\n\nA Project For Ants\nWe're going to get started by building you obligatory \"hello world\" app. The\nresulting file structure is going to end up looking like this:\n\nexample-flask-project\n├── app.py\n├── Procfile\n├── Pipfile\n├── Pipfile.lock\n├── runtime.txt\n├── requirements.txt\n├── Pipfile.lock\n└── setup.py\n\n\nNote the existence of two files you may not have seen before if you're new to\nHeroku: the Procfile  (no file extension) and requirements.txt. These are tiny\nfiles which specify which language we're using and how to start our app, but\nwe'll get to that in a moment.\n\nManaging Your Python Packages \nHeroku impressively supports Pipenv out-of-the-box for handling and installing\ndependencies. Every time you deploy your application, Heroku will install the\npackage version specified in Pipfile.lock to build your app from scratch. If\nyou're new to using Pipenv consider quickly picking up the basics from this\nquick tutorial\n[https://hackersandslackers.com/pipenv-etc-tracking-your-projects-dependancies/]\n. If you're still using virtualenv, you should consider switching to Pipenv\nregardless.\n\nCreate a local folder for your project. In that folder, start a Pipenv shell:\n\n$ pip install pipenv\npipenv shell\n\n\nWith the shell activated, we can now install dependencies specific to our\nenvironment. At a bare minimum, we need to install two packages: Flask  as our\nframework, and Gunicorn  to run our app process.\n\n(my-project)$ pip3 install flask gunicorn\n\n\nGood job; now let's build out the files in our tree one-by-one.\n\nProcfile\nThe Procfile (no file extension) is a unique file to Heroku which is essentially\na build command. This will be a one-liner to tell Gunicorn  to startup our\napplication from our base app.py  file.\n\nweb: gunicorn app:app\n\nA quick breakdown here: web  is our process 'type'. other types exists, such as \nworker, urgentworker, and clock, but that's not important for now.\n\napp:app  signifies looking for the 'app' module in our app.py  file. If you'd\nlike to move app.py to . a different folder down the line, this can be adjusted\nas such:\n\nweb: gunicorn differentfolder app:app\n\nRuntime\nThe runtime.txt  file notifies Heroku of the language it's dealing with as well\nas the proper version. Heroku only supports up to a particular version of Python\nat any given moment (which is currently Python-3.7.1), but specifying a higher\nversion will default to the latest version Heroku supports.\n\nPython-3.7.1\n\nRequirements.txt\nEven though Heroku uses your Pipfile to build dependencies, it's still best\npractice to keep a requirements.txt  present for numerous reasons. For example,\nif you remove dependencies from your Pipfile without uninstalling them, \nrequirements.txt  is a useful way of identifying old packages in your\nenvironment that can be uninstalled.\n\n(my-project)$ pip freeze > requirements.txt\n\n\nAs I'm sure you know, pip freeze  will print all packages and their versions\ninto the designated file as such:\n\nasn1crypto==0.24.0\nbcrypt==3.1.4\nbeautifulsoup4==4.6.0\nblinker==1.4\ncffi==1.11.5\nclick==6.7\ncryptography==2.2.2\nFlask==1.0.2\nFlask-Assets==0.12\nFlask-Login==0.4.1\nFlask-Mail==0.9.1\nflask-mongoengine==0.9.5\nFlask-SQLAlchemy==2.3.2\nFlask-Static-Compress==1.0.2\nFlask-User==1.0.1.5\nFlask-WTF==0.14.2\ngunicorn==19.9.0\nidna==2.7\nitsdangerous==0.24\njac==0.17.1\nJinja2==2.10\nMarkupSafe==1.0\nmongoengine==0.15.0\nordereddict==1.1\npasslib==1.7.1\npycparser==2.18\npymongo==3.7.0\nrjsmin==1.0.12\nsix==1.11.0\nSQLAlchemy==1.2.9\nwebassets==0.12.1\nWerkzeug==0.14.1\nWTForms==2.2.1\n\n\nPipfile\nOur Pipfile is automatically generated by Pipenv by default, but be sure to call\nout packages which are essential to the build our app as. Packages which are\nrequired for your app to work belong under the [packages]  section.\n\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\ngunicorn = \"*\"\nflask = \"*\"\nrequests = \"*\"\nwtforms = \"*\"\nflask_assets = \"*\"\nflask_static_compress = \"*\"\n\n[dev-packages]\n\n[requires]\npython_version = \"3.7.1\"\n\n\nPipfile.lock\nHeroku looks at Pipfile.lock  every time our app builds to know which packages\nto install on the server side. Changing dependencies locally without updating\nthe Pipfile.lock  will not carry the changes over to your Dyno. Thus, be sure to\ngenerate this file when needed:\n\n(my-project)$ pipenv lock\n\n\nBetter yet, running the following will check your Pipfile for packages which can\nbe updated, will update those packages, and then  generate a lock file:\n\n(my-project)$ pipenv update\n\n\nSetup.py\nTechnically this file isn't required, but is a general best practice when\ncreating projects. Most of Setup.py's purpose comes in to play if you plan on\nsubmitting your project as a standalone package,\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='my-project',\n    version='1.0',\n    long_description=__doc__,\n    packages=find_packages(),\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=['Flask'],\n)\n\n\n.env\nOkay, okay, just one last thing. Heroku will be upset unless there's a .env \nfile in its root directory at run time. .env  is where we would store sensitive\ninformation (such as secrets), but feel free to leave this empty for now. \n\nHeroku allows you to manage environment variables via their web UI as well.\nThese can then be conveniently saved to your local environment to run your app\nlocally, but let's stay focused on the task at hand: saying \"hello\" to the\nworld.\n\nDeployment\nRunning your app locally is as simple as two words: heroku local. This spins up\nan instance of your app on your machine at 0.0.0.0:5000.\n\nDeploying to your Heroku Dyno is much like deploying to Github (they can in fact\nbe the exact same if you configure it as such). Here's how deployment via the\nHeroku CLI looks:\n\ngit add .\ngit commit -am 'initial commit'\ngit push heroku master\n\n\nIf all went well, your app should be live at the URL Heroku generated for you\nwhen you created your project. Go ahead and checkout the Heroku UI to see how\nthings went. \n\nI highly suggest checking out the logs on the Heroku UI after each deploy. Often\ntimes issues which don't appear on your local environment will pop up on the\nserver:\n\nHeroku's logging system is surprisingly both helpful and aesthetically pleasing.\nWhat Do We Make Of This?\nThere are two general takeaways I suppose I'm getting at:\n\n * Heroku is easy and fun to use.\n * Flask is awesome. \n\nAs much as #1 is true, I think it's important to distinguish Heroku's place in a\ncrowded cloud market. Heroku is a platform best suited for dumping MVPs and side\nprojects... NOT production applications. While you certainly can host large apps\non Heroku, I consider it to highly unprofessional. Remember: Heroku is basically\na reseller. They host their containers on AWS, and sell add-ons from other\nvendors. If you depend too heavily on Heroku, you are essentially just adding a\nmiddle man to your billing cycle.\n\nOn the Flask side: Flask's development may not be as vast as the npm  packages\noffered by Node, there's more or less a package for anything you possibly need.\nI'd recommend checking out Flask's official list of packages\n[http://flask.pocoo.org/extensions/].\n\nWhile we may have set up our first Flask application, as it stands we've only\nbuilt something useless so far. Consider this to be the beginning of many, many\nFlask tips to come.","html":"<p>It's difficult to cover every cloud solution on the market without at least mentioning Heroku. Heroku contrasts nearly every cloud hosting solution by offering a clear purpose: make deploying apps of any kind as easy as possible. Deploying to a VPS requires knowledge of web servers and configurations. Deploying to containers requires knowledge of Docker or Kubernetes. Deploying to Heroku requires nearly no prior knowledge of anything.</p><p>Heroku is great for getting MVPs out the door, or for devs who want to jump into developing web applications with knowledge of a specific language. Even developers with advanced knowledge of how to deploy production applications may want to use Heroku for fast internal deployments, or as a platform for \"sketching out\" a quick prototype.</p><p>In this exploration, we'll be using Heroku to deploy a Python application using the Flask framework.</p><h2 id=\"why-heroku\">Why Heroku?</h2><p>We're on the topic of simplicity, so let's keep that theme going. Heroku's infrastructure offering is unique in that Heroku obfuscates the DevOps aspect of web development completely. That means that configuring web servers, managing Linux packages, and supplying SSL certs are entirely taken care of by Heroku. </p><p>Let's consider Heroku's ease-of-use services to be luxuries which save us time. They are <strong>NOT</strong> a replacement for grasping these concepts.</p><h3 id=\"pipelines\">Pipelines</h3><p>Aside from VPS upkeep, Heroku obfuscates the process of moving an app through development and production environments by defining <em>pipelines. </em>That's right, CI/CD is built directly into Heroku's interface.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screen-Shot-2018-07-10-at-10.19.41-AM.png\" class=\"kg-image\"></figure><h3 id=\"add-ons\">Add-ons</h3><p>The most addictive aspect of Heroku is probably the Elements marketplace. This is a place to window-shop for set-it-and-forget-it plugins for your app, most of which are very easy to integrate with. </p><p>Most add-ons fall under a few major categories: database resellers, analytics, and Redis, to name a few (interestingly enough, using the base Redis add-on in Heroku is free, while the equivalent instance would cost you 5 dollars from the same provider had you used them directly. Add-ons are \"deployed\" after a single click, and the ensuing configuration process varies from vendor-to-vendor after that.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screenshot-2018-07-08-17.30.07.png\" class=\"kg-image\"></figure><p>Speaking of single-click, they handle single-click deployments of popular build packs, too. You, the thing that made DigitalOcean a big deal way back. You get the idea.</p><h2 id=\"creating-your-project\">Creating your Project</h2><p>Log in to the Heroku UI and create an app on a fresh Dyno. A Dyno is merely a fancy, overly branded word for \"container.\" Next, you'll be prompted to download the Heroku CLI locally on your OS of choice, which is quick and painless. Now we're cooking with gas.</p><p>Create an empty local directory and type the following command to be prompted for your Heroku account credentials:</p><pre><code class=\"language-bash\">$ heroku login\nEnter your Heroku credentials.\nEmail: python@example.com\nPassword:\n</code></pre>\n<p>At this point, Heroku has already magically created a git repository for your application from which you'll be doing development from.</p><pre><code class=\"language-bash\">$ git clone https://github.com/heroku/example-flask-project.git\n$ cd example-flask-project\n\n$ heroku create\nCreating example-flask-project in organization heroku... done, stack is cedar-14\nhttp://example-flask-project.herokuapp.com/ | https://git.heroku.com/example-flask-project.git\nGit remote heroku added\n</code></pre>\n<p>Wow, that sure looks a lot like we're working with Github huh? That's actually the point: if you so chose, you can configure the Heroku CLI to recognize your Github username with a simple <code>heroku config:get GITHUB_USERNAME=yourname</code>. With this configured, Heroku will actually allow you to simply deploy to your personal Github repo and mimic the changes on your Dyno. Now let's configure this thing.</p><h2 id=\"a-project-for-ants\">A Project For Ants</h2><p>We're going to get started by building you obligatory \"hello world\" app. The resulting file structure is going to end up looking like this:</p><pre><code class=\"language-bash\">example-flask-project\n├── app.py\n├── Procfile\n├── Pipfile\n├── Pipfile.lock\n├── runtime.txt\n├── requirements.txt\n├── Pipfile.lock\n└── setup.py\n</code></pre>\n<p>Note the existence of two files you may not have seen before if you're new to Heroku: the <strong>Procfile</strong> (no file extension) and <strong>requirements.txt</strong>. These are tiny files which specify which language we're using and how to start our app, but we'll get to that in a moment.</p><h3 id=\"managing-your-python-packages\">Managing Your Python Packages </h3><p>Heroku impressively supports Pipenv out-of-the-box for handling and installing dependencies. Every time you deploy your application, Heroku will install the package version specified in Pipfile.lock to build your app from scratch. If you're new to using Pipenv consider quickly picking up the basics from <a href=\"https://hackersandslackers.com/pipenv-etc-tracking-your-projects-dependancies/\">this quick tutorial</a>. If you're still using virtualenv, you should consider switching to Pipenv regardless.</p><p>Create a local folder for your project. In that folder, start a Pipenv shell:</p><pre><code class=\"language-bash\">$ pip install pipenv\npipenv shell\n</code></pre>\n<p>With the shell activated, we can now install dependencies specific to our environment. At a bare minimum, we need to install two packages: <strong>Flask</strong> as our framework, and <strong>Gunicorn</strong> to run our app process.</p><pre><code class=\"language-bash\">(my-project)$ pip3 install flask gunicorn\n</code></pre>\n<p>Good job; now let's build out the files in our tree one-by-one.</p><h3 id=\"procfile\">Procfile</h3><p>The Procfile (no file extension) is a unique file to Heroku which is essentially a build command. This will be a one-liner to tell <strong>Gunicorn</strong> to startup our application from our base <code>app.py</code> file.</p><pre><code>web: gunicorn app:app</code></pre><p>A quick breakdown here: <code>web</code> is our process 'type'. other types exists, such as <code>worker</code>, <code>urgentworker</code>, and <code>clock</code>, but that's not important for now.</p><p><code>app:app</code> signifies looking for the 'app' module in our <em>app.py</em> file. If you'd like to move app.py to . a different folder down the line, this can be adjusted as such:</p><pre><code>web: gunicorn differentfolder app:app</code></pre><h3 id=\"runtime\">Runtime</h3><p>The runtime.txt  file notifies Heroku of the language it's dealing with as well as the proper version. Heroku only supports up to a particular version of Python at any given moment (which is currently <em>Python-3.7.1</em>), but specifying a higher version will default to the latest version Heroku supports.</p><pre><code>Python-3.7.1</code></pre><h3 id=\"requirements-txt\">Requirements.txt</h3><p>Even though Heroku uses your Pipfile to build dependencies, it's still best practice to keep a <code>requirements.txt</code> present for numerous reasons. For example, if you remove dependencies from your Pipfile without uninstalling them, <code>requirements.txt</code> is a useful way of identifying old packages in your environment that can be uninstalled.</p><pre><code class=\"language-bash\">(my-project)$ pip freeze &gt; requirements.txt\n</code></pre>\n<p>As I'm sure you know, <code>pip freeze</code> will print all packages and their versions into the designated file as such:</p><pre><code class=\"language-bash\">asn1crypto==0.24.0\nbcrypt==3.1.4\nbeautifulsoup4==4.6.0\nblinker==1.4\ncffi==1.11.5\nclick==6.7\ncryptography==2.2.2\nFlask==1.0.2\nFlask-Assets==0.12\nFlask-Login==0.4.1\nFlask-Mail==0.9.1\nflask-mongoengine==0.9.5\nFlask-SQLAlchemy==2.3.2\nFlask-Static-Compress==1.0.2\nFlask-User==1.0.1.5\nFlask-WTF==0.14.2\ngunicorn==19.9.0\nidna==2.7\nitsdangerous==0.24\njac==0.17.1\nJinja2==2.10\nMarkupSafe==1.0\nmongoengine==0.15.0\nordereddict==1.1\npasslib==1.7.1\npycparser==2.18\npymongo==3.7.0\nrjsmin==1.0.12\nsix==1.11.0\nSQLAlchemy==1.2.9\nwebassets==0.12.1\nWerkzeug==0.14.1\nWTForms==2.2.1\n</code></pre>\n<h3 id=\"pipfile\">Pipfile</h3><p>Our Pipfile is automatically generated by Pipenv by default, but be sure to call out packages which are essential to the build our app as. Packages which are required for your app to work belong under the <code>[packages]</code> section.</p><pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\ngunicorn = \"*\"\nflask = \"*\"\nrequests = \"*\"\nwtforms = \"*\"\nflask_assets = \"*\"\nflask_static_compress = \"*\"\n\n[dev-packages]\n\n[requires]\npython_version = \"3.7.1\"\n</code></pre><h3 id=\"pipfile-lock\">Pipfile.lock</h3><p>Heroku looks at <code>Pipfile.lock</code><em> </em>every time our app builds to know which packages to install on the server side. Changing dependencies locally without updating the <code>Pipfile.lock</code> will not carry the changes over to your Dyno. Thus, be sure to generate this file when needed:</p><pre><code class=\"language-bash\">(my-project)$ pipenv lock\n</code></pre>\n<p>Better yet, running the following will check your Pipfile for packages which can be updated, will update those packages, and <em>then</em> generate a lock file:</p><pre><code class=\"language-bash\">(my-project)$ pipenv update\n</code></pre>\n<h3 id=\"setup-py\">Setup.py</h3><p>Technically this file isn't required, but is a general best practice when creating projects. Most of <code>Setup.py</code>'s purpose comes in to play if you plan on submitting your project as a standalone package,</p><pre><code class=\"language-python\">from setuptools import setup, find_packages\n\nsetup(\n    name='my-project',\n    version='1.0',\n    long_description=__doc__,\n    packages=find_packages(),\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=['Flask'],\n)\n</code></pre>\n<h2 id=\"-env\">.env</h2><p>Okay, okay, just one last thing. Heroku will be upset unless there's a <code>.env</code> file in its root directory at run time. <code>.env</code> is where we would store sensitive information (such as secrets), but feel free to leave this empty for now. </p><p>Heroku allows you to manage environment variables via their web UI as well. These can then be conveniently saved to your local environment to run your app locally, but let's stay focused on the task at hand: saying \"hello\" to the world.</p><h2 id=\"deployment\">Deployment</h2><p>Running your app locally is as simple as two words: <code>heroku local</code>. This spins up an instance of your app on your machine at <code>0.0.0.0:5000</code>.</p><p>Deploying to your Heroku Dyno is much like deploying to Github (they can in fact be the exact same if you configure it as such). Here's how deployment via the Heroku CLI looks:</p><pre><code class=\"language-bash\">git add .\ngit commit -am 'initial commit'\ngit push heroku master\n</code></pre>\n<p>If all went well, your app should be live at the URL Heroku generated for you when you created your project. Go ahead and checkout the Heroku UI to see how things went. </p><p>I highly suggest checking out the logs on the Heroku UI after each deploy. Often times issues which don't appear on your local environment will pop up on the server:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-4.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/Screenshot-2018-07-08-17.16.33.png\" class=\"kg-image\"><figcaption>Heroku's logging system is surprisingly both helpful and aesthetically pleasing.</figcaption></figure><h2 id=\"what-do-we-make-of-this\">What Do We Make Of This?</h2><p>There are two general takeaways I suppose I'm getting at:</p><ul><li>Heroku is easy and fun to use.</li><li>Flask is awesome. </li></ul><p>As much as #1 is true, I think it's important to distinguish Heroku's place in a crowded cloud market. Heroku is a platform best suited for dumping MVPs and side projects... NOT production applications. While you certainly can host large apps on Heroku, I consider it to highly unprofessional. Remember: Heroku is basically a reseller. They host their containers on AWS, and sell add-ons from other vendors. If you depend too heavily on Heroku, you are essentially just adding a middle man to your billing cycle.</p><p>On the Flask side: Flask's development may not be as vast as the <code>npm</code> packages offered by Node, there's more or less a package for anything you possibly need. I'd recommend checking out Flask's official list of <a href=\"http://flask.pocoo.org/extensions/\">packages</a>.</p><p>While we may have set up our first Flask application, as it stands we've only built something useless so far. Consider this to be the beginning of many, many Flask tips to come.</p>","url":"https://hackersandslackers.com/starting-a-python-web-app-with-heroku/","uuid":"c426aeae-5f78-405e-8452-57e8fc110b12","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c64981a7c8ecc6ee30c6870"}}]}},"pageContext":{"slug":"flask","limit":12,"skip":12,"numberOfPages":2,"humanPageNumber":2,"prevPageNumber":1,"nextPageNumber":null,"previousPagePath":"/tag/flask/","nextPagePath":null}}