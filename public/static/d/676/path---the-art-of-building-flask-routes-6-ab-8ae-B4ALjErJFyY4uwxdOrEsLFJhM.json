{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb8673701","title":"Flask Routing & Sessions: A Subtle Symphony","slug":"the-art-of-building-flask-routes","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","excerpt":"With great flexibility comes great responsibility .","custom_excerpt":"With great flexibility comes great responsibility .","created_at_pretty":"17 September, 2018","published_at_pretty":"19 September, 2018","updated_at_pretty":"17 November, 2018","created_at":"2018-09-17T05:05:03.000-04:00","published_at":"2018-09-19T08:58:00.000-04:00","updated_at":"2018-11-16T20:57:42.000-05:00","meta_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","meta_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","og_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","og_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","og_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","twitter_description":"There's nothing wrong with being a worker drone repeating worthless projects and contributing nothing to humanity. I'd personally prefer using Flask.","twitter_image":"https://hackersandslackers.com/content/images/2018/09/flaskroutes@2x.jpg","twitter_title":"Flask Routing & Sessions: A Subtle Symphony | Hackers and Slackers","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"}],"plaintext":"It isn't often you find somebody sad or miserable enough to detail the inner\nworkings of web framework features, such as sessions or routing. This is\nunderstandably so; we use frameworks because presumably hate dealing with these\nthings from scratch. This is especially so when it comes to Flask, which only\nreleased version 1.0 a few months ago, introducing breaking changes rendering\nprevious documentation more-or-less worthless. \n\nGoogling some of Flask's critical features mostly returns one-liners from the\napp's authors (half of which are useless, as they are for older versions of\nFlask). Stack Overflow threads mostly sit in silence, and even Kite\n[https://kite.com/], AKA \"The smart copilot for programmers\" returns blank pages\nof documentation, akin to the blank stare of a clueless Golden Retriever.\n\nIn retrospect, it was probably a poor choice for me to pick up 4 separate\nFlask-based projects during this time.\n\nWe're in a historic place in time where a team of developers put together\nsomething beautiful, yet somehow feels undersold. It seems as though the niche\nmarket of \"those who can't do, teach\" remains untapped for Flask, as the usual\nsuspects have yet to \"do\". This leaves newcomers like myself to hack away for\ntheir own survival in the meantime. I've only just turned that mental corner\nwhere Flask's quirks are as comforting as home-cooked meal, as opposed to\nfrustrating single-word methods containing 6 words of documentation on average.\n\nThe good news is I am still technically alive, after spending weeks building\nFlask applications mostly through trial and error. The bad news is that I've\nbecome Mr. Robot  in the process. That said, if there will ever be an ideal\nmoment in my life to write about Flask, now is the time. As reality slowly slips\naway in 1s and 0s, I may as well pass along  what I've learned.\n\nBroad Strokes\nIt only takes a couple minutes into explaining what Flask is when you realize\nthat Flask, at its core, is overwhelmingly just the “V” in “MVC”. Jinja handles\nthe templates, and something like SQLAlchemy will likely handle your models.\nFlask has an abundance of third-party libraries to handle business logic, but it\nis the core Flask package that we all agreed to gather around. This speaks\nvolumes about the quality of Flask’s simple yet powerful request handling.\n\nI'll  break down as many of Flask's out-of-the-box features, focusing on what\nmatters most (in my opinion). Take a look at some of the Flask libraries we'll\nbe playing around with:\n\n# app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport os\n\nConfiguring Our App\nAs always, we create our app with app = Flask(name). Equally uninteresting is\nour configuration setup, which we'll import via a class in config.py:\n\n# app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport config\nimport os\n\n# Our app\napp = Flask(__name__)\n\n# Load our config variables\napp.config.from_object('config.ProductionConfig')\n\nA number of things in our config are absolutely essential for sessions to work.\nBelow is an example config file:\n\n# config.py\nimport os\n\nclass ProductionConfig():\n    \"\"\"Set app config vars.\"\"\"\n    SECRET_KEY = os.urandom(24)\n    SESSION_TYPE = null\n    SESSION_COOKIE_NAME = 'session name'\n    SESSION_PERMANENT = True\n    PERMANENT_SESSION_LIFETIME = timedelta(days=31) (2678400 seconds)\n\nSECRET_KEY  is critical: this variable needs to exist in out config for sessions\nto function properly. The best way to handle is is by generating a key as seen\nabove.\n\nSESSION_TYPE  allows us to specify where our session data should be stored. This\nis set null by default, but Flask supports a number of options:\n\n * RedisSessionInterface:  Uses the Redis key-value store as a session backend. \n * MemcachedSessionInterface:  Uses the Memcached as a session backend. \n * FileSystemSessionInterface:  werkzeug.contrib.cache.FileSystemCache  as a\n   session backend.\n * MongoDBSessionInterface:  Uses MongoDB as a backend \n   [http://api.mongodb.org/python/current/index.html]via pymongo\n * SqlAlchemySessionInterface:  Uses SQLAlchemy, or rather Flask-SQLAlchemy\n   [https://pythonhosted.org/Flask-SQLAlchemy/]\n\nThere are plenty more variables you can set if you want to take a look here\n[http://flask.pocoo.org/docs/1.0/config/].\n\nSessions and Contexts\nUnlike cookie-based sessions, Flask sessions are handled and stored on the\nserver-side. A session object is simply a dict which is accessible throughout\nthe application a global level, referring to a single 'logged-in user'. As long\nas the session is active, any context of our app will be able to retrieve,\nmodify, or delete the values held in this session object,\n\n# Save a value to the user's session.\nsession['username'] = 'MyUsername' \n\n# IMPORTANT: \"True\" forces our changes to be recognized.\nsession.modified = True: \n\n# Retrieve session values at any time, anywhere \nsession.get('username') = True\n\nSeeing as how sessions are accessible globally, it is also important to note\nthat sessions can last a very long time; pretty much self explanatory given the \nSESSION_PERMANENT = True  configuration option.  It's a good idea to set a\nsession timeout period, or better yet, close them by the user's own request.\nClearing a session is as simple as resetting the session dictionary values back\nto None  by using the pop  method: session.pop('value', None).\n\nThe Application Context\nBesides undying global sessions,  Flask also provides us with a feature with an\nobject more suitable for storing and passing temporary values between app\ncontexts. This object known simply as g. While  technically an abbreviation for\n\"global\",g  is really just a convenient place to store temporarily store values\nwhich you can always depend on to be by your side.\n\n# app.py\nfrom Flask import g\n\nIt's important to note that values assigned to g  only exist within the context\nthey were created by default. For example, if we store information to the object\ndue to some user interaction on the dashboard, these values are lost once the\nuser moves to another part of our app. That said, values assigned to g  can\ntechnically be passed between contexts if we return g.value. This distinction\nbetween always-alive sessions  and every dying g  should be indicative of what\nreach respective object does.  Spoiler alert: sensitive (or contextually\nuseless) data should be stored temporarily with g, where values which will\ncontinuously be useful in determining the functionality of our should should\nreside in session.\n\nInterestingly enough, Flask has a decorator  specifically for terminating values\nsaved to g  in the case we'd want to ensure the swift and total annihilation of\nsuch data. For instance, if we were to assign a database connection to g  using\ng.db = connect_to_database(), we'd want to make sure that connection is closed\nas fast as possible before we forget:\n\n# app.py\ndef db_stuff():\n    g.db = database_connection()\n    g.db.somequeryorwhatever\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db():\n    db = g.pop('db', None)\n\nRoutes & Decorators\nWe're surely familiar with the concepts behind routing users to deserved views\nby now. Before we look at the juicy stuff, consider this boring route for a\nboring product, where the homepage is a dashboard:\n\n# app.py\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef dashboard():\n    \"\"\"Boring route.\"\"\"\n    return render_template('/dashboard.html')\n\nOh snap, our landing page is a /dashboard?  How will we know which user's\ndashboard to display when they visit the dashboard, or any other page for that\nmatter? If only there were a way to intercept every request a user makes to our\napp?\n\nFlask comes with a bunch of insanely useful decorators. Python decorators are\nfunctions which either 'wrap'  other functions in additional logic, or in our\ncase, intercept functions to do with them what we what. Flask has a vast\nplethora of logic decorators, ranging from detecting first-time visitors,\nhandling exceptions, executing logic before/after page loads, etc. Even the\nroute we set above is a decorator!\n\n@flask.before_request\nAdding before_request  to our app allows us to run logic prior to the\naforementioned request. With this power, we can do things like treat users\ndifferently (such as recognized or anonymous users), or just execute some sort\nof unique logic upon page load. \n\nIn this simple case, we check to see if a visitor has an active session every\ntime they hit a route. This way, if a user's session expired between before\nhitting a route in our app, we can prompt them to log in... or whatever. \n\nbefore_request doesn't accept any value parameters - the handler is mostly\nintended to perform tasks such as making a database query necessary for our app\nto run, or make sure users are still logged in.\n\n# app.py\n@app.before_request\ndef before_request():\n    \"\"\"Handle multiple users.\"\"\"\n    if 'username' in session:\n        return render_template('/dashboard.html')\n    else:\n        return render_template('/login.html')\n\n@flask.url_value_preprocessor\nUnlike before_request, url_value_preprocessor  does  accept incoming data. This\nallows us to handle data being posted to any part of our app before we even\nbother serving up views. Not only does this provide a convenient separation of\nconcerns, but also helps us avoid callback hell, which yes, can happen in Python\ntoo.\n\nLet's say we're accepting a POST request, where we create a view for our user's\npersonal details. When the user passes us their email address, we decide to\nretrieve the user's records by hitting an API, and passing the results to the\nview.\n\nWithout modularizing our code, we'd have to handle things like waiting on API\ncalls in the same functions as  our routes. Not only is this shitty repetitive\ncode, but running numerous API calls and rendering a view all at once is going\nto eventually break. Go ahead and ask the NodeJS guys. They'll know.\n\n# app.py\n@app.url_value_preprocessor\ndef url_value_preprocessor(endpoint, values):\n    \"\"\"Handle data sent to any route.\"\"\"\n       if request.args:\n           email = request.args.get('email')\n           r = requests.post(endpoint, headers=headers, data=email)\n           session['usermetadata'] = r\n           session.modified = True\n           return session\n\nYou're Only Getting Started\nWe've only covered small percentage of convenient tools Flask offers us. Go\nahead and see how many decorators [http://flask.pocoo.org/docs/1.0/api/]   you\ncan fuck with. Yeah dude, shit is legit - and we haven't even talked about the\nFlask-Login package yet.\n\nThe beauty of lightweight frameworks is that they focus on the problems that\ndrive us to web frameworks in the first place. Flask is clearly designed to\nhandle serving views, standing up APIs, and handling user management\neffectively. Contrast this with frameworks like Django, which forces rigid app\nsetup in what can commonly be an  hour-long setup or greater. I'll truthfully\nalways have a place in my heart for Django as the fathers of Python MVC: I would\ncan say with confidence that without the creation of Django (as well as the\nofficial $10 dollar intro book from Barnes and Noble) I never would have\ntransitioned from an obnoxious product manager  personality to the kind of guy\nwho owns multiple Python t-shirts. Hmm. Now that I think about it, maybe I\nshould've stayed an office tool as opposed to solving all these complex\nproblems. oh well.\n\nFlask is indicative of a new direction of framework design - or rather lack\nthereof. Programmers who know what they're doing  can express themselves outside\nof traditional boundaries set by other frameworks, surely designed to keep\nidiots from ruining everything. There's nothing wrong with being a worker drone\nrepeating the same worthless projects,  using same libraries, and essentially\ncontributing nothing to humanity. I'd personally prefer to take the freedom and\nspeed of Flask any day.","html":"<p>It isn't often you find somebody sad or miserable enough to detail the inner workings of web framework features, such as sessions or routing. This is understandably so; we use frameworks because presumably hate dealing with these things from scratch. This is especially so when it comes to Flask, which only released version 1.0 a few months ago, introducing breaking changes rendering previous documentation more-or-less worthless. </p><p>Googling some of Flask's critical features mostly returns one-liners from the app's authors (half of which are useless, as they are for older versions of Flask). Stack Overflow threads mostly sit in silence, and even <a href=\"https://kite.com/\">Kite</a>, AKA <em>\"The smart copilot for programmers\" </em>returns blank pages of documentation, akin to the blank stare of a clueless Golden Retriever.</p><p><strong><em>In retrospect, it was probably a poor choice for me to pick up 4 separate Flask-based projects during this time.</em></strong></p><p>We're in a historic place in time where a team of developers put together something beautiful, yet somehow feels undersold. It seems as though the niche market of \"those who can't do, teach\" remains untapped for Flask, as the usual suspects have yet to \"do\". This leaves newcomers like myself to hack away for their own survival in the meantime. I've only just turned that mental corner where Flask's quirks are as comforting as home-cooked meal, as opposed to frustrating single-word methods containing 6 words of documentation on average.</p><p>The good news is I am still technically alive, after spending weeks building Flask applications mostly through trial and error. The bad news is that I've become <em>Mr. Robot</em> in the process. That said, if there will ever be an ideal moment in my life to write about Flask, now is the time. As reality slowly slips away in 1s and 0s, I may as well pass along  what I've learned.</p><h2 id=\"broad-strokes\">Broad Strokes</h2><p>It only takes a couple minutes into explaining what Flask is when you realize that Flask, at its core, is overwhelmingly just the “V” in “MVC”. Jinja handles the templates, and something like SQLAlchemy will likely handle your models. Flask has an abundance of third-party libraries to handle business logic, but it is the core Flask package that we all agreed to gather around. This speaks volumes about the quality of Flask’s simple yet powerful request handling.</p><p>I'll  break down as many of Flask's out-of-the-box features, focusing on what matters most (in my opinion). Take a look at some of the Flask libraries we'll be playing around with:</p><pre><code># app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport os</code></pre><h2 id=\"configuring-our-app\">Configuring Our App</h2><p>As always, we create our app with <code>app = Flask(name)</code><em>. </em>Equally uninteresting is our configuration setup, which we'll import via a class in <code>config.py</code>:</p><pre><code># app.py\nfrom flask import Flask, render_template, request, redirect, Session, g\nimport config\nimport os\n\n# Our app\napp = Flask(__name__)\n\n# Load our config variables\napp.config.from_object('config.ProductionConfig')</code></pre><p>A number of things in our config are absolutely essential for sessions to work. Below is an example config file:</p><pre><code># config.py\nimport os\n\nclass ProductionConfig():\n    \"\"\"Set app config vars.\"\"\"\n    SECRET_KEY = os.urandom(24)\n    SESSION_TYPE = null\n    SESSION_COOKIE_NAME = 'session name'\n    SESSION_PERMANENT = True\n    PERMANENT_SESSION_LIFETIME = timedelta(days=31) (2678400 seconds)</code></pre><p><strong>SECRET_KEY</strong> is critical: this variable needs to exist in out config for sessions to function properly. The best way to handle is is by generating a key as seen above.</p><p><strong>SESSION_TYPE</strong> allows us to specify where our session data should be stored. This is set null by default, but Flask supports a number of options:</p><ul><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.RedisSessionInterface\">RedisSessionInterface</a>:<strong> </strong>Uses the Redis key-value store as a session backend. </li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.MemcachedSessionInterface\">MemcachedSessionInterface</a>:<strong> </strong>Uses the Memcached as a session backend. </li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.FileSystemSessionInterface\">FileSystemSessionInterface</a>:<strong> </strong><code>werkzeug.contrib.cache.FileSystemCache</code> as a session backend.</li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.MongoDBSessionInterface\">MongoDBSessionInterface</a>:<strong> </strong>Uses MongoDB as a backend<a href=\"http://api.mongodb.org/python/current/index.html\"> </a>via <code>pymongo</code></li><li><a href=\"https://pythonhosted.org/Flask-Session/#flask.ext.session.SqlAlchemySessionInterface\">SqlAlchemySessionInterface</a>:<strong> </strong>Uses SQLAlchemy, or rather <a href=\"https://pythonhosted.org/Flask-SQLAlchemy/\">Flask-SQLAlchemy</a></li></ul><p>There are plenty more variables you can set if you want to take a look <a href=\"http://flask.pocoo.org/docs/1.0/config/\">here</a>.</p><h2 id=\"sessions-and-contexts\">Sessions and Contexts</h2><p>Unlike cookie-based sessions, Flask sessions are handled and stored on the server-side. A session object is simply a dict which is accessible throughout the application a global level, referring to a single 'logged-in user'. As long as the session is active, any context of our app will be able to retrieve, modify, or delete the values held in this session object,</p><pre><code># Save a value to the user's session.\nsession['username'] = 'MyUsername' \n\n# IMPORTANT: \"True\" forces our changes to be recognized.\nsession.modified = True: \n\n# Retrieve session values at any time, anywhere \nsession.get('username') = True</code></pre><p>Seeing as how sessions are accessible globally, it is also important to note that sessions can last a very long time; pretty much self explanatory given the <code>SESSION_PERMANENT = True</code> configuration option.  It's a good idea to set a session timeout period, or better yet, close them by the user's own request. Clearing a session is as simple as resetting the session dictionary values back to <em>None</em> by using the <strong>pop</strong> method: <code>session.pop('value', None)</code>.</p><h3 id=\"the-application-context\">The Application Context</h3><p>Besides undying global sessions,  Flask also provides us with a feature with an object more suitable for storing and passing temporary values between app contexts. This object known simply as <code>g</code>. While<strong> </strong>technically an abbreviation for \"global\",  <code>g</code> is really just a convenient place to store temporarily store values which you can always depend on to be by your side.</p><pre><code># app.py\nfrom Flask import g</code></pre><p>It's important to note that values assigned to <code>g</code> <em>only exist within the context they were created </em>by default. For example, if we store information to the object due to some user interaction on the dashboard, these values are lost once the user moves to another part of our app. That said, values assigned to <code>g</code> can technically be passed between contexts if we <code>return g.value</code>. This distinction between always-alive <em>sessions</em> and every dying <em>g</em> should be indicative of what reach respective object does.  Spoiler alert: sensitive (or contextually useless) data should be stored temporarily with <code>g</code>, where values which will continuously be useful in determining the functionality of our should should reside in <code>session</code><em>.</em></p><p>Interestingly enough, Flask has a <em>decorator</em> specifically for terminating values saved to <code>g</code> in the case we'd want to ensure the swift and total annihilation of such data. For instance, if we were to assign a database connection to <code>g</code> using  <code>g.db = connect_to_database()</code>, we'd want to make sure that connection is closed as fast as possible before we forget:</p><pre><code># app.py\ndef db_stuff():\n    g.db = database_connection()\n    g.db.somequeryorwhatever\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db():\n    db = g.pop('db', None)</code></pre><h2 id=\"routes-decorators\">Routes &amp; Decorators</h2><p>We're surely familiar with the concepts behind routing users to deserved views by now. Before we look at the juicy stuff, consider this boring route for a boring product, where the homepage is a dashboard:</p><pre><code># app.py\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef dashboard():\n    \"\"\"Boring route.\"\"\"\n    return render_template('/dashboard.html')</code></pre><p>Oh snap, our landing page is a /<em>dashboard?</em> How will we know which user's dashboard to display when they visit the dashboard, or any other page for that matter? If only there were a way to intercept every request a user makes to our app?</p><p>Flask comes with a bunch of insanely useful <strong><em>decorators</em></strong>. Python decorators are functions which either 'wrap'  other functions in additional logic, or in our case, intercept functions to do with them what we what. Flask has a vast plethora of logic decorators, ranging from detecting first-time visitors, handling exceptions, executing logic before/after page loads, etc. Even the route we set above is a decorator!</p><h3 id=\"-flask-before_request\">@flask.before_request</h3><p>Adding <strong>before_request</strong> to our app allows us to run logic prior to the aforementioned request. With this power, we can do things like treat users differently (such as recognized or anonymous users), or just execute some sort of unique logic upon page load. </p><p>In this simple case, we check to see if a visitor has an active session every time they hit a route. This way, if a user's session expired between before hitting a route in our app, we can prompt them to log in... or whatever. </p><p><strong>before_request </strong>doesn't accept any value parameters - the handler is mostly intended to perform tasks such as making a database query necessary for our app to run, or make sure users are still logged in.</p><pre><code># app.py\n@app.before_request\ndef before_request():\n    \"\"\"Handle multiple users.\"\"\"\n    if 'username' in session:\n        return render_template('/dashboard.html')\n    else:\n        return render_template('/login.html')</code></pre><h3 id=\"-flask-url_value_preprocessor\">@flask.url_value_preprocessor</h3><p>Unlike <em>before_request</em><strong>, url_value_preprocessor</strong> <em>does</em> accept incoming data. This allows us to handle data being posted to any part of our app before we even bother serving up views. Not only does this provide a convenient separation of concerns, but also helps us avoid <em>callback hell, </em>which yes, can happen in Python too.</p><p>Let's say we're accepting a POST request, where we create a view for our user's personal details. When the user passes us their email address, we decide to retrieve the user's records by hitting an API, and passing the results to the view.</p><p>Without modularizing our code, we'd have to handle things like waiting on API calls in the same functions as  our routes. Not only is this shitty repetitive code, but running numerous API calls and rendering a view all at once is going to eventually break. Go ahead and ask the NodeJS guys. They'll know.</p><pre><code># app.py\n@app.url_value_preprocessor\ndef url_value_preprocessor(endpoint, values):\n    \"\"\"Handle data sent to any route.\"\"\"\n       if request.args:\n           email = request.args.get('email')\n           r = requests.post(endpoint, headers=headers, data=email)\n           session['usermetadata'] = r\n           session.modified = True\n           return session</code></pre><h2 id=\"you-re-only-getting-started\">You're Only Getting Started</h2><p>We've only covered small percentage of convenient tools Flask offers us. Go ahead and see <a href=\"http://flask.pocoo.org/docs/1.0/api/\">how many decorators</a>  you can fuck with. Yeah dude, shit is legit - and we haven't even talked about the Flask-Login package yet.</p><p>The beauty of lightweight frameworks is that they focus on the problems that drive us to web frameworks in the first place. Flask is clearly designed to handle serving views, standing up APIs, and handling user management effectively. Contrast this with frameworks like <strong>Django</strong>, which forces rigid app setup in what can commonly be an  hour-long setup or greater. I'll truthfully always have a place in my heart for Django as the fathers of Python MVC: I would can say with confidence that without the creation of Django (as well as the official $10 dollar intro book from Barnes and Noble) I never would have transitioned from an obnoxious product manager  personality to the kind of guy who owns multiple Python t-shirts. Hmm. Now that I think about it, maybe I should've stayed an office tool as opposed to solving all these complex problems. oh well.</p><p>Flask is indicative of a new direction of framework design - or rather lack thereof. Programmers who <em>know what they're doing</em> can express themselves outside of traditional boundaries set by other frameworks, surely designed to keep idiots from ruining everything. There's nothing wrong with being a worker drone repeating the same worthless projects,  using same libraries, and essentially contributing nothing to humanity. I'd personally prefer to take the freedom and speed of Flask any day.</p><p></p>","url":"https://hackersandslackers.com/the-art-of-building-flask-routes/","uuid":"67a6407a-5804-4bd0-812d-219561e2488a","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b9f6e3ff79bcf0717187d8b"}},"pageContext":{"slug":"the-art-of-building-flask-routes"}}