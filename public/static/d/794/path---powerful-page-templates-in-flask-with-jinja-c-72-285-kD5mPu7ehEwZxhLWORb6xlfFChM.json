{"data":{"ghostPost":{"id":"Ghost__Post__5c5822200a214230dae40906","title":"Powerful Page Templates in Flask With Jinja","slug":"powerful-page-templates-in-flask-with-jinja","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","excerpt":"Work with markup that writes itself using Flask's built-in Jinja library.","custom_excerpt":"Work with markup that writes itself using Flask's built-in Jinja library.","created_at_pretty":"04 February, 2019","published_at_pretty":"20 July, 2018","updated_at_pretty":"28 March, 2019","created_at":"2019-02-04T06:29:36.000-05:00","published_at":"2018-07-20T06:30:00.000-04:00","updated_at":"2019-03-28T05:18:50.000-04:00","meta_title":"Powerful Page Templates in Flask With Jinja | Hackers and Slackers","meta_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","og_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","og_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","og_title":"Powerful Page Templates in Flask With Jinja","twitter_description":"Work with markup that writes itself. Flask's built-in Jinja library allows you to create Python applications with smarter page templates.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/jinja@2x.jpg","twitter_title":"Powerful Page Templates in Flask With Jinja","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#Building Flask Apps","slug":"building-flask-apps","description":"Python’s fast-growing and flexible microframework. Can handle apps as simple as API endpoints, to monoliths remininiscent of Django.","feature_image":"https://hackersandslackers.com/content/images/2019/03/flask-gettingstarted.jpg","meta_description":"Python’s fastest growing, most flexible, and perhaps most Pythonic framework.","meta_title":"Building Flask Apps","visibility":"internal"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"}],"plaintext":"So you want to build a web application in Python, eh? Hasn't anybody told you...\nPython is SLOW! Python is subject to CONTEXT SWITCHING! Oh, the HORROR!\n\nChances are most of these people aren't well-versed in Python at all. I enjoy\ncreating web applications in Flask more-so than I do in Node. Even if we were to\nput aside somehow the thousands of potentially malicious Javascript libraries\nneeded to stand up a simple app, or the decades of legacy knowledge needed to\ntolerate the JavaScript ecosystem without going insane: the simplicity of Flask\npaired and its libraries get the job done faster in most cases. Oh yeah, and you\ncan write backend logic in a language intended to do  so at the drop of a dime.\n\nOne of Flask's early surprises hits you when working with Jinja2. Jinja is\nFlask's default templating system, which processes templates into HTML markup to\nbe served to users at runtime. In addition to the inheritance and partial\ninclusion we've come to expect from templating systems, Jinja is particularly\nwell-equipped build pages out of raw data. You'll see what I mean.\n\nLayouts, Pages, and Partials\nLet's add three pages to our templates  folder, which is a directory typically\nreserved for template files. We'll add 3 files: layout.html, index.html, and \nnav.html.  Each of these templates represents one of three common template\n\"types\" when building in Jinja. \n\nOh, and disregard the fact that these files retain an HTML file extension- they\nare oh, so much more than that.\n\nmyproject\n├─ /templates\n│  ├─ layout.html\n│  ├─ index.html\n│  └─ nav.html\n└─ app.py\n\n\nCreate a Simple Route to Get Started\nWe'll make a brief stop in app.py  to set up the most basic logic an app can\nhave: serving up a homepage:\n\nfrom flask import Flask, render_template\n\napp = Flask(__name__, template_folder=\"templates\")\n\n@app.route('/')\ndef home():\n    \"\"\"Landing page.\"\"\"\n    return render_template('/index.html', title=\"Lame Site\")\n\n\nNote how we specify template_folder=\"templates\"  when instantiating our app\nobject; this is critical to let Flask know where templates are going to be\nstored in the project directory. Be aware that this directory is almost always\nexplicitly set as /templates. If you store your templates anywhere else, you\nhave a mental health problem.\n\nThe Bread and Butter of Template Inheritance\nLayout.html  is going to be our base template. In other words, this barebones\nfile will represent elements which should be common to all  of our app's pages,\nsuch as metadata, analytics, etc. It is the 'page we load other pages into.'  \n\nIf you're familiar with Handlebars\n[https://hackersandslackers.com/handlebars-templating-in-expressjs/], Jinja's\ntemplating concepts are the same deal with slightly different syntax. Here's a\ndecent layout.html  example:\n\n<!-- layout.html -->\n<!doctype html>\n<html>\n<head>\n  <title>{{title}}</title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\">\n    <!-- Google Analytics -->\n    <script>\n    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;\n    ga('create', 'UA-XXXXX-Y', 'auto');\n    ga('send', 'pageview');\n    </script>\n    <script async src='https://www.google-analytics.com/analytics.js'></script>\n    <!-- End Google Analytics -->\n</head>\n<body>\n  {% include 'nav.html' %}\n  {% block content %}{% endblock %}\n  {% include 'footer.html' %}\n</body>\n</html>\n\n\nNote the bracketed values in our otherwise-HTML! Each of these represents a\nreservation of \"stuff to come.\" That \"stuff\" could come in the form of a\nvariable, a partial, or code from another template. \n\nWe've just utilized three templating concepts in the above example:\n\n * The double-bracket {{title}}  is reserved to be replaced with a variable\n   named 'title' when we serve this view in Flask. We pass variables to\n   templates when we render them in the 'routes' part of our app.\n * Includes such as {% include 'nav.html' %}  are saying \"load the entirety of a\n   separate HTML file named nav.html  into this spot right here.\" This is called\n   a partial. Partials are encapsulated, standalone components intended to be\n   frequently reused throughout our app.\n * Things get real interesting with blocks, as seen in {% block content %}{%\n   endblock %}. This statement is reserving a chunk  of our template to receive\n   a corresponding chunk  of another template when such a template is loaded\n   into layout.hml. Remember: layouts are just barebones commonalities between\n   pages. To build meaningful pages, we must combine the parts of unique pages\n   (such as index.html) with layouts to create full pages. \n\nLet's look at index.html:  the file we're about to shove into layout.html:\n\n<!-- index.html -->\n{% extends 'layout.html' %}\n\n{% block content %}\n<div class=\"container\">\n<h1>My Lame site</h1>\n    <p>Hello, and welcome to my lame site! I'm so glad you're here. I'm so lonely.</p>\n</div>\n{% endblock %}\n\n\nRemember in the route we created in app.py:  our function states \"load\nindex.html when users visit /.\" We never mention layout.html  at all. That is\nbecause by including {% extends 'layout.html' %}  in  index.html, we're  stating\nthat index.html  should extend  layout.html. index.html  is our unique snowflake\nof a page, and layout  is our boring skeleton.\n\nBack to talking about blocks:  templates can contain multiple \"blocks\" of code.\nEach named block (such as  {% block content %}) in a page such as index.html \nshould correspond to an empty block we reserved in layout.html. When we serve\nthe final page, it's like we're plugging plugs into their respective sockets. We\ncan reserve as many \"blocks\" in our layout as we want, and thus serve multiple\nblocks within the same template. \n\nTo help illustrate this, let's say you're building a horrible clickbait site\nwhere your requirements dictate that horrible, invasive ads should appear\nbetween pieces of content of every page of your site. If we keep that page\nstructure to layout.html, then we can retrofit our layout to have multiple slots\nfor incoming content from index.html:  both before  and after  the horrible\nmonstrosity of an idea I already regret imagining. If index.html  contained both\n {% block content1 %}...{% endblock %}  and {% block content2 %}...{% endblock\n%}, those blocks are now independent entities which can be loaded to their\nrespective slots.\n\nPassing Data to Templates\nWhen we passed title=\"Lame Site\"  to index.html in our route, we were passing a\nsimple variable to replace {{title}}. Check out this example of what we can do\nwhen we pass JSON objects to templates:\n\n<form action=\"/submitted\" method=post>\n  {% if error %}\n   <p class=error><strong>Error:</strong> {{ error }}</p>\n  {% endif %}\n  {% for field in request.fields.requestTypeFields %}\n     {% if field.name in ('Category', 'Product', 'Dashboard Name') %}\n          <select id=\"{{request.name}} {{field.name}}\" \n                  name=\"{{field.name}}\" \n                  label=\"{{field.name}}\" \n                  class=\"input-field\">\n           <option value=\"Choose your option\" \n                   disabled \n                   selected>\n               {{field.description}}\n            </option>\n            {% for option in field.validValues %}\n                <option value=\"{{option.value}}\">\n                    {{option.label}}\n                </option>\n                {% endfor %}\n            </select>\n            <label>{{field.name}}</label>\n       {% elif field.name == 'Description' %}\n            <label for=\"{{request.name}} {{field.name}}\">\n                {{field.name}}\n            </label>\n            <textarea id=\"{{field.name}}\" \n                      class=\"materialize-textarea input-field\" \n                      placeholder=\"{{field.description}}\" \n                      name=\"{{field.name}}\">\n             </textarea>\n         {% else %}\n         <label for=\"{{request.name}} {{field.name}}\">\n             {{field.name}}\n         </label>\n         <input placeholder=\"{{field.description}}\" \n                id=\"{{request.name}} {{field.name}}\" \n                type=\"text\" \n                class=\"input-field validate\" \n                name=\"{{field.name}}\">\n         {% endif %}\n    {% endfor %}\n    <input type=\"submit\" value=\"Submit\" class=\"btn cyan formsubmit\">\n</form>\n\n\nThose are for  loops and if  statements all working against a single JSON\nobject. This specific example demonstrates building a form based on a JSON\nobject; one we've happened to fetch from JIRA. Just by passing this JSON to a\nJinja template, we can recreate an entire enterprise system's form logic in a\nsimple template block.\n\nHere's another example. This one returns feedback to a user who presumably\nfilled out a form incorrectly, thus must be chastised with popup error messages:\n\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n\n\nSmall But Powerful\nTemplates are one small part of Flask, but they demonstrate a greater philosophy\ngenerally consistent throughout the framework: small libraries can do big\nthings. Sometimes it may take some courage to maneuver with the tools at hand\ncleverly, but the power of the Triforce is with you. You are Hyrule's last hope,\ngreat warrior... now you must make haste in your duties to build little apps. Or\nwhatever.","html":"<p>So you want to build a web application in Python, eh? Hasn't anybody told you... Python is <em>SLOW</em>! Python is subject to <em>CONTEXT SWITCHING</em>! Oh, the <em>HORROR</em>!</p><p>Chances are most of these people aren't well-versed in Python at all. I enjoy creating web applications in Flask more-so than I do in Node. Even if we were to put aside somehow the thousands of potentially malicious Javascript libraries needed to stand up a simple app, or the decades of legacy knowledge needed to tolerate the JavaScript ecosystem without going insane: the simplicity of Flask paired and its libraries get the job done faster in most cases. Oh yeah, and you can write backend logic in a language <em>intended to do</em> so at the drop of a dime.</p><p>One of Flask's early surprises hits you when working with <strong>Jinja2</strong>. Jinja is Flask's default templating system, which processes templates into HTML markup to be served to users at runtime. In addition to the inheritance and partial inclusion we've come to expect from templating systems, Jinja is particularly well-equipped build pages out of raw data. You'll see what I mean.</p><h2 id=\"layouts-pages-and-partials\">Layouts, Pages, and Partials</h2><p>Let's add three pages to our <em>templates</em> folder, which is a directory typically reserved for template files. We'll add 3 files: <strong>layout.html, index.html, </strong>and <strong>nav.html.</strong> Each of these templates represents one of three common template \"types\" when building in Jinja. </p><p>Oh, and disregard the fact that these files retain an HTML file extension- they are oh, so much more than that.</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">myproject\n├─ /templates\n│  ├─ layout.html\n│  ├─ index.html\n│  └─ nav.html\n└─ app.py\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"create-a-simple-route-to-get-started\">Create a Simple Route to Get Started</h2><p>We'll make a brief stop in <strong>app.py</strong> to set up the most basic logic an app can have: serving up a homepage:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from flask import Flask, render_template\n\napp = Flask(__name__, template_folder=&quot;templates&quot;)\n\n@app.route('/')\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    return render_template('/index.html', title=&quot;Lame Site&quot;)\n</code></pre>\n<!--kg-card-end: markdown--><p>Note how we specify <code>template_folder=\"templates\"</code> when instantiating our app object; this is critical to let Flask know where templates are going to be stored in the project directory. Be aware that this directory is almost always explicitly set as /<em>templates. </em>If you store your templates anywhere else, you have a mental health problem.</p><h2 id=\"the-bread-and-butter-of-template-inheritance\">The Bread and Butter of Template Inheritance</h2><p><strong>Layout.html</strong> is going to be our base template. In other words, this barebones file will represent elements which should be common to <em>all</em> of our app's pages, such as metadata, analytics, etc. It is the '<em>page we load other pages into.'</em> </p><p>If you're familiar with <a href=\"https://hackersandslackers.com/handlebars-templating-in-expressjs/\">Handlebars</a>, Jinja's templating concepts are the same deal with slightly different syntax. Here's a decent <strong>layout.html</strong> example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;!-- layout.html --&gt;\n&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;{{title}}&lt;/title&gt;\n  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;\n    &lt;!-- Google Analytics --&gt;\n    &lt;script&gt;\n    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;\n    ga('create', 'UA-XXXXX-Y', 'auto');\n    ga('send', 'pageview');\n    &lt;/script&gt;\n    &lt;script async src='https://www.google-analytics.com/analytics.js'&gt;&lt;/script&gt;\n    &lt;!-- End Google Analytics --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  {% include 'nav.html' %}\n  {% block content %}{% endblock %}\n  {% include 'footer.html' %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Note the bracketed values in our otherwise-HTML! Each of these represents a reservation of \"stuff to come.\" That \"stuff\" could come in the form of a variable, a partial, or code from another template. </p><p>We've just utilized three templating concepts in the above example:</p><ul><li>The double-bracket <code>{{title}}</code> is reserved to be replaced with a variable named 'title' when we serve this view in Flask. We pass variables to templates when we render them in the 'routes' part of our app.</li><li>Includes such as <code>{% include 'nav.html' %}</code> are saying \"load the entirety of a separate HTML file named <strong>nav.html</strong> into this spot right here.\" This is called a <em>partial</em>. Partials are encapsulated, standalone components intended to be frequently reused throughout our app.</li><li>Things get real interesting with <em>blocks</em>, as seen in <code>{% block content %}{% endblock %}</code>. This statement is reserving a <em>chunk</em> of our template to receive a <em>corresponding chunk</em> of another template when such a template is loaded into <strong>layout.hml</strong>. Remember: layouts are just barebones commonalities between pages. To build meaningful pages, we must combine the parts of unique pages (such as <strong>index.html</strong>) with layouts to create full pages. </li></ul><p>Let's look at <strong>index.html:</strong> the file we're about to shove into <strong>layout.html:</strong></p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;!-- index.html --&gt;\n{% extends 'layout.html' %}\n\n{% block content %}\n&lt;div class=&quot;container&quot;&gt;\n&lt;h1&gt;My Lame site&lt;/h1&gt;\n    &lt;p&gt;Hello, and welcome to my lame site! I'm so glad you're here. I'm so lonely.&lt;/p&gt;\n&lt;/div&gt;\n{% endblock %}\n</code></pre>\n<!--kg-card-end: markdown--><p>Remember in the route we created in <strong>app.py:</strong> our function states <em>\"load index.html when users visit /.\" </em>We never mention <strong>layout.html</strong> at all. That is because by including <code>{% extends 'layout.html' %}</code><strong> </strong>in<strong> index.html, </strong>we're<strong> </strong>stating that <strong>index.html</strong> should <em>extend</em> <strong>layout.html. index.html</strong> is our unique snowflake of a page, and <strong>layout</strong> is our boring skeleton.</p><p>Back to talking about blocks:  templates can contain multiple \"blocks\" of code. Each named block (such as<strong> </strong><code>{% block content %}</code>) in a page such as <strong>index.html</strong> should correspond to an empty block we reserved in <strong>layout.html</strong>. When we serve the final page, it's like we're plugging plugs into their respective sockets. We can reserve as many \"blocks\" in our layout as we want, and thus serve multiple blocks within the same template. </p><p>To help illustrate this, let's say you're building a horrible clickbait site where your requirements dictate that horrible, invasive ads should appear between pieces of content of every page of your site. If we keep that page structure to <strong>layout.html</strong>, then we can retrofit our layout to have multiple slots for incoming content from <strong>index.html:</strong> both <em>before</em> and <em>after</em> the horrible monstrosity of an idea I already regret imagining. If <strong>index.html</strong> contained both <code>{% block content1 %}...{% endblock %}</code> and <code>{% block content2 %}...{% endblock %}</code>, those blocks are now independent entities which can be loaded to their respective slots.</p><h2 id=\"passing-data-to-templates\">Passing Data to Templates</h2><p>When we passed <code>title=\"Lame Site\"</code> to <strong>index.html </strong>in our route, we were passing a simple variable to replace <code>{{title}}</code>. Check out this example of what we can do when we pass JSON objects to templates:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;form action=&quot;/submitted&quot; method=post&gt;\n  {% if error %}\n   &lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt; {{ error }}&lt;/p&gt;\n  {% endif %}\n  {% for field in request.fields.requestTypeFields %}\n     {% if field.name in ('Category', 'Product', 'Dashboard Name') %}\n          &lt;select id=&quot;{{request.name}} {{field.name}}&quot; \n                  name=&quot;{{field.name}}&quot; \n                  label=&quot;{{field.name}}&quot; \n                  class=&quot;input-field&quot;&gt;\n           &lt;option value=&quot;Choose your option&quot; \n                   disabled \n                   selected&gt;\n               {{field.description}}\n            &lt;/option&gt;\n            {% for option in field.validValues %}\n                &lt;option value=&quot;{{option.value}}&quot;&gt;\n                    {{option.label}}\n                &lt;/option&gt;\n                {% endfor %}\n            &lt;/select&gt;\n            &lt;label&gt;{{field.name}}&lt;/label&gt;\n       {% elif field.name == 'Description' %}\n            &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;\n                {{field.name}}\n            &lt;/label&gt;\n            &lt;textarea id=&quot;{{field.name}}&quot; \n                      class=&quot;materialize-textarea input-field&quot; \n                      placeholder=&quot;{{field.description}}&quot; \n                      name=&quot;{{field.name}}&quot;&gt;\n             &lt;/textarea&gt;\n         {% else %}\n         &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;\n             {{field.name}}\n         &lt;/label&gt;\n         &lt;input placeholder=&quot;{{field.description}}&quot; \n                id=&quot;{{request.name}} {{field.name}}&quot; \n                type=&quot;text&quot; \n                class=&quot;input-field validate&quot; \n                name=&quot;{{field.name}}&quot;&gt;\n         {% endif %}\n    {% endfor %}\n    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; class=&quot;btn cyan formsubmit&quot;&gt;\n&lt;/form&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Those are <code>for</code> loops and <code>if</code> statements all working against a single JSON object. This specific example demonstrates building a form based on a JSON object; one we've happened to fetch from JIRA. Just by passing this JSON to a Jinja template, we can recreate an entire enterprise system's form logic in a simple template block.</p><p>Here's another example. This one returns feedback to a user who presumably filled out a form incorrectly, thus must be chastised with popup error messages:</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    &lt;ul class=flashes&gt;\n    {% for message in messages %}\n      &lt;li&gt;{{ message }}&lt;/li&gt;\n    {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n{% endwith %}\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"small-but-powerful\">Small But Powerful</h3><p>Templates are one small part of Flask, but they demonstrate a greater philosophy generally consistent throughout the framework: small libraries can do big things. Sometimes it may take some courage to maneuver with the tools at hand cleverly, but the power of the Triforce is with you. You are Hyrule's last hope, great warrior... now you must make haste in your duties to build little apps. Or whatever.</p>","url":"https://hackersandslackers.com/powerful-page-templates-in-flask-with-jinja/","uuid":"055ba6eb-f177-4b9d-b85e-2c7730850bf1","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c5822200a214230dae40906"}},"pageContext":{"slug":"powerful-page-templates-in-flask-with-jinja"}}