{"data":{"ghostPost":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736ac","title":"Trash Pandas: Messy, Convenient DB Operations via Pandas","slug":"trash-pandas","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/07/racoon@2x.jpg","excerpt":"(And a way to clean it up with SQLAlchemy).","custom_excerpt":"(And a way to clean it up with SQLAlchemy).","created_at_pretty":"19 July, 2018","published_at_pretty":"23 July, 2018","updated_at_pretty":"17 November, 2018","created_at":"2018-07-18T20:26:25.000-04:00","published_at":"2018-07-23T08:30:00.000-04:00","updated_at":"2018-11-16T20:50:25.000-05:00","meta_title":"(And a way to clean it up with SQLAlchemy) | Hackers And Slackers","meta_description":"Python has an extremely handy little tool called f-strings that make string templating a snap!  ","og_description":"Trash Pandas: Messy, Convenient DB Operations via Pandas","og_image":"https://hackersandslackers.com/content/images/2018/07/racoon@2x.jpg","og_title":"Trash Pandas: Messy, Convenient DB Operations via Pandas","twitter_description":"(And a way to clean it up with SQLAlchemy)","twitter_image":"https://hackersandslackers.com/content/images/2018/07/racoon@2x.jpg","twitter_title":"Trash Pandas: Messy, Convenient DB Operations via Pandas","authors":[{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null}],"primary_author":{"name":"Matthew Alhonte","slug":"matt","bio":"Super villain in somebody's action hero movie. Experienced a radioactive freak accident at a young age, which rendered him part-snake and strangely adept at Python.\n\n","profile_image":"https://hackersandslackers.com/content/images/2019/03/matt.jpg","twitter":"@MattAlhonte","facebook":null,"website":null},"primary_tag":{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Data Science","slug":"datascience","description":"Watch as we attempt to maintain a delicate harmony of math, engineering, and intuition to solve larger-than-life problems.","feature_image":null,"meta_description":"Watch as we attempt to maintain a delicate harmony of math, engineering, and intuition to solve larger-than-life problems.","meta_title":"Data Science | Hackers and Slackers","visibility":"public"},{"name":"#Data Analysis with Pandas","slug":"data-analysis-pandas","description":"Analyze data with Python's Pandas. Start from the basics or see real-life examples of using Pandas to solve problems.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/pandasseries-1.jpg","meta_description":"Analyze data with Python's Pandas. Start from the basics or see real-life examples of using Pandas to solve problems.","meta_title":"Data Analysis with Pandas","visibility":"internal"}],"plaintext":"Let's say you were continuing our task from last week\n[https://hackersandslackers.com/code-snippet-corner-a-dirty-way-of-cleaning-data-ft-pandas-sql/]\n: Taking a bunch of inconsistent Excel files and CSVs, and putting them into a\ndatabase.\n\nLet's say you've been given a new CSV that conflicts with some rows you've\nalready entered, and you're told that these rows are the correct values.\n\nWhy Not Use Pandas' Built-in Method?\nPandas' built-in to_sql  DataFrame method won't be useful here.  Remember, it\nwrites as a block - if you set the if_exists  flag to \"replace\", that'll make it\nreplace the entire DB table with a new one based on the DF you're uploading.\n And if you're doing this piecemeal, you presumably don't want that.\n\nLast week, we just made a new DataFrame out of each row and appended it to the\nDB table.  That won't work here - we need an Update.  Writing each update by\nhand would be annoying, though - luckily we can use code to generate more code!\n Python has an extremely handy little tool called f-strings  that make string\ntemplating a snap!\n\ndef updateStr(row):\n    return (f\"UPDATE books \"\n            f\"\"\"SET author = '{x.author}' \"\"\"\n            f\"\"\"WHERE id = {x.id};\"\"\")\n\n\nLet's walk through that.  It takes a row from a Dataframe - note that we're\nusing dot notation here instead of the bracket notation.  The reason we're doing\nthat is because, instead of using iterrows()  like last week, we'll be using \nitertuples  because the docstring for iterrows()  said I should.  One reason for\nthis is that iterrows()  gives a pandas Series, which will store everything as\nthe same datatype, which will be annoying in some cases.  I think it's supposed\nto be faster too?itertuples()  instead gives us Named Tuples, which is kind of\nlike a dictionary, except we have to use dot notation instead of square\nbrackets.\n\nSooo, we take a Named Tuple, and then the f-string goes to work.  It's mostly\njust a convenient way of formatting strings with variables - any code inside\ncurly parentheses will be evaluated.  They're convenient, flexible, and\nsupposedly pretty well-optimized!  Let's give it a spin.  Let's say we have a\nDataFrame df2  that only contains the rows to be updated...\n\ncnx = create_engine('mysql+pymysql://root:cracked1@localhost/appointments', echo=False)\nfor x in df2.itertuples(index=False):\n    print(updateStr(x))\nUPDATE books SET author = 'Abby' WHERE id = 3;\nUPDATE books SET author = 'Brian' WHERE id = 7;\nUPDATE books SET author = 'Celestine' WHERE id = 9;\n\n\nSweet!  Now let's actually execute it.  We'll be using the execute()  function\nin Pandas' io.sql  module.  I get the feeling I'm not supposed to, primarily\nbecause it doesn't have an entry in the official Pandas documentation, and I\nonly found it by poking around the module code.  But hey, it works!  (Warning\nfrom last time applies super-duper-extra-double this time!)\n\nfor x in df2.itertuples(index=False):\n    pd.io.sql.execute(updateStr(x), cnx)\n\n\nAnd now let's see if it worked...\n\npd.io.sql.read_sql_table(\"books\", cnx)\n   author copies  id\n     Abby      2   3\n    Brian          7\nCelestine      7   9`\n\n\nSweet!\n\nNow all that's well and good, but surely we're not the first person to try to\nmake SQL statements by calling Python functions!  How about a slightly less\nerror-prone way of doing this?\n\nSQLAlchemy\nI'll level with you - I've never actually used SQLAlchemy for anything but\nconnecting Pandas to databases before via the create_engine()  function.  But\nthat's why blogging's great - gives you an excuse to finally check out that\nthing you knew was gonna be useful!\n\nSQLAlchemy first needs some information about our table, then it'll let us\ncreate statements doing things to said table automagically.  We can either\ndefine it ourselves (maybe in a future post!) or read an existing table.  I\nfound the default way of doing this a little to\n\"has-a-couple-too-many-steps-and-function-args\"-y, so I packaged the version of\nthe command that worked into a little function.  I encourage you all to do the\nsame!\n\ndef loadTable(cnx, tableName):\n    meta = MetaData(bind=cnx) \n    return Table(tableName, meta, autoload=True, autoload_with=cnx)\n\n#Binding it to the Engine will make sure it uses the right SQL dialect\n\n\nThere we go!  Now, let's load our books  table...\n\nbooks = loadTable(cnx, \"books\")\n\n\nAnd here's the cool part!  Now that we have our table object, it has a bunch of\nbuilt-in methods for doing SQL things!  We can print an example...\n\nstr(books.update())\n'UPDATE books SET index=:index, author=:author, copies=:copies, id=:id'\n\n\nIf we call books.update, it'll do exactly that.  It also has a handy string\nrepresentation, for debugging and sanity checks.\n\nSQLAlchemy wants us to have a Connection  in addition to our Engine.  Well,\nalright then.\n\nconn = cnx.connect()\n\n\nFine, happy now?  Good.\n\nSQLAlchemy lets us build SQL statements by chain methods, which is fantastically\nuseful.  Less error-prone, easier to pass collections.  Our basic pattern would\nbe, based on iterating with itertuples...\n\nfor x in df2.itertuples(index=False):\n    stmt = (books\n          .update()\n          .where(books.c.id == x.id)\n          .values(author=x.author)\n         )\n    conn.execute(stmt)\n\n\nSuccess!","html":"<p>Let's say you were continuing our task from <em><a href=\"https://hackersandslackers.com/code-snippet-corner-a-dirty-way-of-cleaning-data-ft-pandas-sql/\">last week</a></em>: Taking a bunch of inconsistent Excel files and CSVs, and putting them into a database.</p><p>Let's say you've been given a new CSV that conflicts with some rows you've already entered, and you're told that these rows are the correct values.</p><h2 id=\"why-not-use-pandas-built-in-method\">Why Not Use Pandas' Built-in Method?</h2><p>Pandas' built-in <code>to_sql</code> DataFrame method won't be useful here.  Remember, it writes as a block - if you set the <code>if_exists</code> flag to <code>\"replace\"</code>, that'll make it replace the entire DB table with a new one based on the DF you're uploading.  And if you're doing this piecemeal, you presumably don't want that.</p><p>Last week, we just made a new DataFrame out of each row and appended it to the DB table.  That won't work here - we need an Update.  Writing each update by hand would be annoying, though - luckily we can use code to generate more code!  Python has an extremely handy little tool called <code>f-strings</code> that make string templating a snap!  </p><pre><code class=\"language-python\">def updateStr(row):\n    return (f&quot;UPDATE books &quot;\n            f&quot;&quot;&quot;SET author = '{x.author}' &quot;&quot;&quot;\n            f&quot;&quot;&quot;WHERE id = {x.id};&quot;&quot;&quot;)\n</code></pre>\n<p>Let's walk through that.  It takes a row from a Dataframe - note that we're using dot notation here instead of the bracket notation.  The reason we're doing that is because, instead of using <code>iterrows()</code> like last week, we'll be using <code>itertuples</code> because the docstring for <code>iterrows()</code> said I should.  One reason for this is that <code>iterrows()</code> gives a pandas Series, which will store everything as the same datatype, which will be annoying in some cases.  I think it's supposed to be faster too?  <code>itertuples()</code> instead gives us Named Tuples, which is kind of like a dictionary, except we have to use dot notation instead of square brackets.  </p><p>Sooo, we take a Named Tuple, and then the f-string goes to work.  It's mostly just a convenient way of formatting strings with variables - any code inside curly parentheses will be evaluated.  They're convenient, flexible, and supposedly pretty well-optimized!  Let's give it a spin.  Let's say we have a DataFrame <code>df2</code> that only contains the rows to be updated...</p><pre><code class=\"language-python\">cnx = create_engine('mysql+pymysql://root:cracked1@localhost/appointments', echo=False)\nfor x in df2.itertuples(index=False):\n    print(updateStr(x))\nUPDATE books SET author = 'Abby' WHERE id = 3;\nUPDATE books SET author = 'Brian' WHERE id = 7;\nUPDATE books SET author = 'Celestine' WHERE id = 9;\n</code></pre>\n<p>Sweet!  Now let's actually execute it.  We'll be using the <code>execute()</code> function in Pandas' <code>io.sql</code> module.  I get the feeling I'm not supposed to, primarily because it doesn't have an entry in the official Pandas documentation, and I only found it by poking around the module code.  But hey, it works!  (Warning from last time applies super-duper-extra-double this time!)</p><pre><code class=\"language-python\">for x in df2.itertuples(index=False):\n    pd.io.sql.execute(updateStr(x), cnx)\n</code></pre>\n<p>And now let's see if it worked...</p><pre><code class=\"language-python\">pd.io.sql.read_sql_table(&quot;books&quot;, cnx)\n   author copies  id\n     Abby      2   3\n    Brian          7\nCelestine      7   9`\n</code></pre>\n<p>Sweet!</p><p>Now all that's well and good, but surely we're not the first person to try to make SQL statements by calling Python functions!  How about a slightly less error-prone way of doing this?</p><h1 id=\"sqlalchemy\">SQLAlchemy</h1><p>I'll level with you - I've never actually used SQLAlchemy for anything but connecting Pandas to databases before via the <code>create_engine()</code> function.  But that's why blogging's great - gives you an excuse to finally check out that thing you knew was gonna be useful!</p><p>SQLAlchemy first needs some information about our table, then it'll let us create statements doing things to said table automagically.  We can either define it ourselves (maybe in a future post!) or read an existing table.  I found the default way of doing this a little to \"has-a-couple-too-many-steps-and-function-args\"-y, so I packaged the version of the command that worked into a little function.  I encourage you all to do the same!</p><pre><code class=\"language-python\">def loadTable(cnx, tableName):\n    meta = MetaData(bind=cnx) \n    return Table(tableName, meta, autoload=True, autoload_with=cnx)\n\n#Binding it to the Engine will make sure it uses the right SQL dialect\n</code></pre>\n<p>There we go!  Now, let's load our <code>books</code> table...</p><pre><code class=\"language-python\">books = loadTable(cnx, &quot;books&quot;)\n</code></pre>\n<p>And here's the cool part!  Now that we have our table object, it has a bunch of built-in methods for doing SQL things!  We can print an example...</p><pre><code class=\"language-python\">str(books.update())\n'UPDATE books SET index=:index, author=:author, copies=:copies, id=:id'\n</code></pre>\n<p>If we call <code>books.update</code>, it'll do exactly that.  It also has a handy string representation, for debugging and sanity checks.</p><p>SQLAlchemy wants us to have a <code>Connection</code> in addition to our <code>Engine</code>.  Well, alright then.</p><pre><code class=\"language-python\">conn = cnx.connect()\n</code></pre>\n<p>Fine, happy now?  Good.</p><p>SQLAlchemy lets us build SQL statements by chain methods, which is fantastically useful.  Less error-prone, easier to pass collections.  Our basic pattern would be, based on iterating with <code>itertuples</code>...</p><pre><code class=\"language-python\">for x in df2.itertuples(index=False):\n    stmt = (books\n          .update()\n          .where(books.c.id == x.id)\n          .values(author=x.author)\n         )\n    conn.execute(stmt)\n</code></pre>\n<p>Success!</p>","url":"https://hackersandslackers.com/trash-pandas/","uuid":"8a789f92-fbde-48b5-8bdf-01206e340cc1","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b4fdab10dda8433e079043f"}},"pageContext":{"slug":"trash-pandas"}}