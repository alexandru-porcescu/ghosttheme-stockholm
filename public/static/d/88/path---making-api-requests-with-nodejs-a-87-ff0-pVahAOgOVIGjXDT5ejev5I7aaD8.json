{"data":{"ghostPost":{"id":"Ghost__Post__5c6dd08fa624d869fba41325","title":"Making API Requests With node-fetch","slug":"making-api-requests-with-nodejs","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/node-fetch.jpg","excerpt":"Using the lightweight node-fetch library for REST API requests in NodeJS.","custom_excerpt":"Using the lightweight node-fetch library for REST API requests in NodeJS.","created_at_pretty":"20 February, 2019","published_at_pretty":"21 February, 2019","updated_at_pretty":"09 April, 2019","created_at":"2019-02-20T17:11:27.000-05:00","published_at":"2019-02-20T20:22:20.000-05:00","updated_at":"2019-04-08T23:21:34.000-04:00","meta_title":"Making API Requests with node-fetch | Hackers and Slackers","meta_description":"Using the lightweight node-fetch library for REST API requests in NodeJS.","og_description":"Using the lightweight node-fetch library for REST API requests in NodeJS.","og_image":"https://hackersandslackers.com/content/images/2019/02/node-fetch.jpg","og_title":"Making API Requests with node-fetch","twitter_description":"Using the lightweight node-fetch library for REST API requests in NodeJS.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/node-fetch.jpg","twitter_title":"Making API Requests with node-fetch","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},"tags":[{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"},{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"}],"plaintext":"If you're the type of person to read technical Javascript posts in your free\ntime (you are), you don't need me to tell you that JQuery is dead. JQuery\nthemselves have proclaimed JQuery to be dead. The only cool thing about JQuery\nis who can remove it from their legacy stack the fastest, which begs the\nquestion: why is the third most popular page on this site an old post about\nJQuery?\n\nMaintaining a blog of tutorials has taught me a lot about the gap between\nperception and reality. While we content publishers sling Medium posts from our\nivory towers, we quickly create a perception of what \"everybody\" is doing, but\nit turns out \"everybody\" only includes individuals who are exceptionally\nvisible. That demographic makes up significantly less than 10-20% of the active\nworkforce. I would have assumed any post with the word \"React\" would immediately\nexplode, when in reality people are more interested in using Handlebars with\nExpressJS [https://hackersandslackers.com/handlebars-templating-in-expressjs/] \n(I'm not proud of that post by the way, please don't read it).\n\nI want to provide an alternative to using AJAX calls when interacting with REST\nAPIs to clear my conscious of ever enabling bad behavior in the first place.\nHopefully, those who have lost their way might find something to take from it.\nConsidering how deep I've gone down the GraphQL rabbit hole myself, this may be\nthe last chance to bother writing about REST at all.\n\nLibrary of Choice: node-fetch\nLike everything in Javascript, there are way too many packages doing the same\nthing and solving the same problem. Making API requests is no exception. http\n[https://www.npmjs.com/package/http]  is a bit primitive, request\n[https://www.npmjs.com/package/request]  breaks when building with Webpack, r2\n[https://www.npmjs.com/package/r2]  seems like a pointless clone, and so on.\nDon't get me started with async libraries with 40 different methods for chaining\nrequests. Who is gunslinging API requests to the point where we need this many\noptions to pipe or parallel API requests anyway?\n\nAfter using all of these libraries, node-fetch\n[https://www.npmjs.com/package/node-fetch]  is the weapon of choice for today.\nTo put it simply: it's straightforward, and the only one that actually works out\nof the box with Webpack without absurd configuration nonsense. \n\nThe other request library worth mentioning is isomorphic-fetch\n[https://www.npmjs.com/package/isomorphic-fetch], which is intended to be a\ndrop-in replacement for node-fetch. isometric-fetch  mimics the syntax of \nnode-fetch, but impressively works on both  the client and server-side. When\nused on the client side, isomorphicfetch works by first importing the \nes6-promise  polyfill.\n\nGetting Set Up\nStart a Node project and install node-fetch:\n\nnpm install --save node-fetch\n\n\nIn the JS file we'd like to make a request, we can reference node-fetch  using \nrequire():\n\nconst fetch = require('node-fetch');\n\n\nCreating a node-fetch Request\nWe'll start with the most basic GET request possible:\n\nfetch('https://example.com')\n  .then(response => response.json())\n  .then(data => {\n    console.log(data)\n  })\n  .catch(err => ...)\n\n\nIndeed, that's all it takes a base level. Without specifying a method,\nnode-fetch assumes we're making a GET request. From we generate JSON from the\nrequest body and print the result to the console.\n\nChances are you're not going to get much value out of any request without\npassing headers, parameters, or a body to the target endpoint. Here's how we'd\nmake a more complicated (and realistic) POST call:\n\nvar url ='https://example.com';\nvar headers = {\n  \"Content-Type\": \"application/json\",\n  \"client_id\": \"1001125\",\n  \"client_secret\": \"876JHG76UKFJYGVHf867rFUTFGHCJ8JHV\"\n}\nvar data = {\n  \"name\": \"Wade Wilson\",\n  \"occupation\": \"Murderer\",\n  \"age\": \"30 (forever)\"\n}\nfetch(url, { method: 'POST', headers: headers, body: data})\n  .then((res) => {\n     return res.json()\n})\n.then((json) => {\n  console.log(json);\n  // Do something with the returned data.\n});\n\n\nThat's more like it: now we're passing headers and a JSON body. If needed, the \nfetch()  method also accepts a credentials  parameter for authentication.\n\nNote that we are avoiding callback hell by keeping logic that utilizes the\nresponse JSON in our then()  arrow functions. We can chain together as many of\nthese statements as we want.\n\nProperties of a Response\nThe response object contains much more than just the response body JSON:\n\nfetch('https://example.com')\n.then(res => {\n  res.text()       // response body (=> Promise)\n  res.json()       // parse via JSON (=> Promise)\n  res.status       //=> 200\n  res.statusText   //=> 'OK'\n  res.redirected   //=> false\n  res.ok           //=> true\n  res.url          //=> 'https://example.com'\n  res.type         //=> 'basic'\n                   //   ('cors' 'default' 'error'\n                   //    'opaque' 'opaqueredirect')\n\n  res.headers.get('Content-Type')\n})\n\n\nres.status  is particularly handy when building functionality around catching\nerrors:\n\nfetch('https://example.com')\n  .then(reportStatus)\n  \nfunction checkStatus (res) {\n  if (res.status >= 200 && res.status < 300) {\n    return res\n  } else {\n    let err = new Error(res.statusText)\n    err.response = res\n    throw err\n  }\n}\n\n\nMaking Asynchronous Requests\nChances are that when we make an API request, we're planning to do something\nwith the resulting data. Once we start building logic which depends on the\noutcome of a request, this is when we start running into Callback Hell: perhaps\nthe worst  part of JavaScript. In a nutshell, JavaScript will not wait for a\nrequest to execute the next line of code, therefore making a request and\nreferencing it immediately will result in no data returned. We can get around\nthis by using a combination of async  and await.\n\nasync  is a keyword which denotes that a function is to be executed\nasynchronously (as in async function my_func(){...}). await  can be used when\ncalling async  functions to wait on the result of an async function to be\nreturned (ie: const response = await my_func()).\n\nHere's an example of async/await  in action:\n\nconst fetch = require(\"node-fetch\");\n\nconst url = \"https://example.com\";\n\nconst get_data = async url => {\n  try {\n    const response = await fetch(url);\n    const json = await response.json();\n    console.log(json);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\ngetData(url);","html":"<p>If you're the type of person to read technical Javascript posts in your free time (you are), you don't need me to tell you that JQuery is dead. JQuery themselves have proclaimed JQuery to be dead. The only cool thing about JQuery is who can remove it from their legacy stack the fastest, which begs the question: why is the third most popular page on this site an old post about JQuery?</p><p>Maintaining a blog of tutorials has taught me a lot about the gap between perception and reality. While we content publishers sling Medium posts from our ivory towers, we quickly create a perception of what \"everybody\" is doing, but it turns out \"everybody\" only includes individuals who are exceptionally visible. That demographic makes up significantly less than 10-20% of the active workforce. I would have assumed any post with the word \"React\" would immediately explode, when in reality people are more interested in using <a href=\"https://hackersandslackers.com/handlebars-templating-in-expressjs/\">Handlebars with ExpressJS</a> (I'm not proud of that post by the way, please don't read it).</p><p>I want to provide an alternative to using AJAX calls when interacting with REST APIs to clear my conscious of ever enabling bad behavior in the first place. Hopefully, those who have lost their way might find something to take from it. Considering how deep I've gone down the GraphQL rabbit hole myself, this may be the last chance to bother writing about REST at all.</p><h2 id=\"library-of-choice-node-fetch\">Library of Choice: node-fetch</h2><p>Like everything in Javascript, there are way too many packages doing the same thing and solving the same problem. Making API requests is no exception. <strong><a href=\"https://www.npmjs.com/package/http\">http</a> </strong>is a bit primitive, <strong><a href=\"https://www.npmjs.com/package/request\">request</a></strong> breaks when building with Webpack, <strong><a href=\"https://www.npmjs.com/package/r2\">r2</a></strong> seems like a pointless clone, and so on. Don't get me started with async libraries with 40 different methods for chaining requests. Who is gunslinging API requests to the point where we need this many options to pipe or parallel API requests anyway?</p><p>After using all of these libraries, <strong><a href=\"https://www.npmjs.com/package/node-fetch\">node-fetch</a></strong> is the weapon of choice for today. To put it simply: it's straightforward, and the only one that actually works out of the box with Webpack without absurd configuration nonsense. </p><p>The other request library worth mentioning is <strong><a href=\"https://www.npmjs.com/package/isomorphic-fetch\">isomorphic-fetch</a>, </strong>which is intended to be a drop-in replacement for <em>node-fetch</em>. <strong>isometric-fetch</strong> mimics the syntax of <strong>node-fetch</strong>, but impressively works on <em>both</em> the client and server-side. When used on the client side, <em>isomorphicfetch </em>works by first importing the <code>es6-promise</code> polyfill.</p><h3 id=\"getting-set-up\">Getting Set Up</h3><p>Start a Node project and install node-fetch:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">npm install --save node-fetch\n</code></pre>\n<!--kg-card-end: markdown--><p>In the JS file we'd like to make a request, we can reference <strong>node-fetch</strong> using <strong>require():</strong></p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const fetch = require('node-fetch');\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"creating-a-node-fetch-request\">Creating a node-fetch Request</h2><p>We'll start with the most basic GET request possible:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">fetch('https://example.com')\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    console.log(data)\n  })\n  .catch(err =&gt; ...)\n</code></pre>\n<!--kg-card-end: markdown--><p>Indeed, that's all it takes a base level. Without specifying a method, node-fetch assumes we're making a GET request. From we generate JSON from the request body and print the result to the console.</p><p>Chances are you're not going to get much value out of any request without passing headers, parameters, or a body to the target endpoint. Here's how we'd make a more complicated (and realistic) POST call:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">var url ='https://example.com';\nvar headers = {\n  &quot;Content-Type&quot;: &quot;application/json&quot;,\n  &quot;client_id&quot;: &quot;1001125&quot;,\n  &quot;client_secret&quot;: &quot;876JHG76UKFJYGVHf867rFUTFGHCJ8JHV&quot;\n}\nvar data = {\n  &quot;name&quot;: &quot;Wade Wilson&quot;,\n  &quot;occupation&quot;: &quot;Murderer&quot;,\n  &quot;age&quot;: &quot;30 (forever)&quot;\n}\nfetch(url, { method: 'POST', headers: headers, body: data})\n  .then((res) =&gt; {\n     return res.json()\n})\n.then((json) =&gt; {\n  console.log(json);\n  // Do something with the returned data.\n});\n</code></pre>\n<!--kg-card-end: markdown--><p>That's more like it: now we're passing headers and a JSON body. If needed, the <strong>fetch()</strong> method also accepts a <code>credentials</code> parameter for authentication.</p><p>Note that we are avoiding callback hell by keeping logic that utilizes the response JSON in our <strong>then()</strong> arrow functions. We can chain together as many of these statements as we want.</p><h3 id=\"properties-of-a-response\">Properties of a Response</h3><p>The response object contains much more than just the response body JSON:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">fetch('https://example.com')\n.then(res =&gt; {\n  res.text()       // response body (=&gt; Promise)\n  res.json()       // parse via JSON (=&gt; Promise)\n  res.status       //=&gt; 200\n  res.statusText   //=&gt; 'OK'\n  res.redirected   //=&gt; false\n  res.ok           //=&gt; true\n  res.url          //=&gt; 'https://example.com'\n  res.type         //=&gt; 'basic'\n                   //   ('cors' 'default' 'error'\n                   //    'opaque' 'opaqueredirect')\n\n  res.headers.get('Content-Type')\n})\n</code></pre>\n<!--kg-card-end: markdown--><p><code>res.status</code> is particularly handy when building functionality around catching errors:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">fetch('https://example.com')\n  .then(reportStatus)\n  \nfunction checkStatus (res) {\n  if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) {\n    return res\n  } else {\n    let err = new Error(res.statusText)\n    err.response = res\n    throw err\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"making-asynchronous-requests\">Making Asynchronous Requests</h2><p>Chances are that when we make an API request, we're planning to do something with the resulting data. Once we start building logic which depends on the outcome of a request, this is when we start running into <strong>Callback Hell</strong>: perhaps the <em>worst</em> part of JavaScript. In a nutshell, JavaScript will not wait for a request to execute the next line of code, therefore making a request and referencing it immediately will result in no data returned. We can get around this by using a combination of <strong>async</strong> and <strong>await.</strong></p><p><code>async</code> is a keyword which denotes that a function is to be executed asynchronously (as in <code>async function my_func(){...}</code>). <code>await</code> can be used when calling <code>async</code> functions to wait on the result of an async function to be returned (ie: <code>const response = await my_func()</code>).</p><p>Here's an example of <strong>async/await</strong> in action:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const fetch = require(&quot;node-fetch&quot;);\n\nconst url = &quot;https://example.com&quot;;\n\nconst get_data = async url =&gt; {\n  try {\n    const response = await fetch(url);\n    const json = await response.json();\n    console.log(json);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\ngetData(url);\n</code></pre>\n<!--kg-card-end: markdown-->","url":"https://hackersandslackers.com/making-api-requests-with-nodejs/","uuid":"9b46eb2c-0339-44f9-8909-13474dff9377","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c6dd08fa624d869fba41325"}},"pageContext":{"slug":"making-api-requests-with-nodejs"}}