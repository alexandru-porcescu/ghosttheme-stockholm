{"data":{"ghostTag":{"slug":"graphql","name":"GraphQL","visibility":"public","feature_image":null,"description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon."},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5c82cfe75af763016e85082e","title":"Working With GraphQL Fragments and Mutations","slug":"creating-updating-and-deleting-data-via-graphql-mutations","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","custom_excerpt":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","created_at_pretty":"08 March, 2019","published_at_pretty":"19 March, 2019","updated_at_pretty":"20 March, 2019","created_at":"2019-03-08T15:26:15.000-05:00","published_at":"2019-03-19T16:34:38.000-04:00","updated_at":"2019-03-20T18:39:27.000-04:00","meta_title":"Working With GraphQL Fragments and Mutations | Hackers and Slackers","meta_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-3.jpg","og_title":"Working With GraphQL Fragments and Mutations","twitter_description":"Make your GraphQL queries more dynamic with Fragments, plus get started with Mutations.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphql-mutations-1-2.jpg","twitter_title":"Working With GraphQL Fragments and Mutations","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"Last week we encountered a genuine scenario when working with GraphQL clients.\nWhen building real applications consuming data via GraphQL, we usually don't\nknow precisely the query we're going to want to run at runtime. Imagine a user\ncruising through your application, setting preferences, and arriving at core\npieces of functionality under a content which is specific only to them. Say\nwe're building a GrubHub knockoff (we hate profits and love entering\nimpenetrable parts of the market, it's not that uncommon really.) At its core,\nthe information we're serving will always be restaurants; we'll always want to\nreturn things like the restaurant address, name, rating, etc. Because we want\nour app to be intelligent, this means that circumstances in which User 1  makes\na query are vastly different than User 2. Aside from the obvious facts (residing\nin different locales), perhaps there's more metadata we can leverage from User 1\n's longterm app usage, versus User 2  who is a total noob to our knockoff app.\n\nYet, the information we're serving will always be restaurants. There's a core\nquery being reused at the heart of our requests: we need to be dynamic enough to\naccount for the fact that User 1  has checked off 13 different cuisines and\nstrict delivery time windows, whereas User 2  doesn't give a shit. User 2  just\nwants pizza.\n\nThis is where GraphQL Fragments  come in to play. We've already seen how we can\npass variables through our queries to receive contextual data: the next step is\ncreating blocks of reusable code which may never change, which become the\nfoundational building blocks of all future queries.\n\nWhen to Use Fragments\nBack to our JIRA example, I demonstrated precisely the sort of thing one should\nnever do: making more than one GraphQL request to serve a single purpose.\n\nTo recap, we're pulling in JIRA issues to a Kanban board. Our board has 4\ncolumns: one per \"status.\" Here's a god-awful way of hardcoding a query like\nthat:\n\nquery JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }\n\nSeems like a lot of repetition, yeah? What if we could define chunks of queries\nto be reused to simplify things?\n\n# Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}\n\nProgress! Instead of reiterating the fields we want to query for each time, we\nset these once.  We do this by creating a fragment  named JiraFields  (naming\nconventions for fragments are totally up to you- these don't relate to\nanything). To make this easier to visualize, let's just look at the parts:\n\nfragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}\n\nTake note of [nameOfDatamodelToQuery(SINGULAR)]. Our fragment will refer to data\nmodel in the singular syntax  - this is important.\n\nOur New Query Using a Fragment\nAgain, let's simply what we're looking at:\n\nquery [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}\n\n * [subsetName]  is the name of the embedded JSON object to be returned in the\n   response. The naming is up to us.\n * [DatamodelToQuery(PLURAL)]  contrasts the singular data model we specified in\n   our fragment.\n * Finally, ...[GivenNameToYourFragment]  is the syntax for dumping a fragment\n   into a query. Yes, the ...  is intentional.\n\nHere's how we managed to get on:\n\nNow we're talkin'.Implementing On The Client Side\nWith the big picture in hand, this is still all theoretical until we have some\nreal code making real dynamic queries. So which GraphQL client tools should we\nuse?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.\n\nAs we all know, Apollo [https://github.com/apollographql/apollo-client]  is\ncrushing the game with their seemingly endless libraries doing... a lot of\nsimilar stuff? Then there's Prisma\n[https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/]\n, the new hotshot looking to make a buck. But what about this repo\n[https://github.com/smooth-code/fraql]? It seems totally fine, but why won't it\nfreakin work?! And what about this Lokka [https://github.com/kadirahq/lokka] \nthing? Also, apparently you can just use node-fetch\n[https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher] \n anyway?\n\nFor somebody looking for simplicity, this gets very frustrating. Most clients\nare immediately concerned with integrating with React as fast as possible\n(totally understandable), but a small-town country boy like me just wants to\nstart with simple. I'm just trying to write a god damn tutorial!\n\nAnyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything\nrelated to JavaScript could be cohesive or straightforward. Instead of wrestling\nwith that reality, now's as good a time as ever to move on to the part of\nGraphQL we've failed to speak of: modifying data.\n\nGraphQL Mutation Cheatsheet\nAny form of creating, changing, or deleting data in GraphQL falls under the\numbrella of mutations. The structure is similar to queries, except that we take\ndata in (presumably through variables) and spit out whichever fields you'd like\nto see as a result of that.\n\nCreating Records\nA functioning \"create\" mutation with the resulting response:\n\nSimple enough.And the mutation itself, just in case anybody is copy/pasting out\nthere:\n\nmutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}\n\nUpdating Records\nWe can update records (aka nodes) by specifying the target node using where: {},\nand the data to be updated within data: {}\n\nSyntax is just like creating nodes, but with an added where:{} statement.mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}\n\nDeleting Records\nYou can even specify which fields you want returned from the node you're in the\nact of ruthlessly murdering! \n\nAnd with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue\nwith GraphQL\" to please its master once last time.mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}\n\nEnough For Now\nHopefully, I'm not the only one to have bee deceived by the simplicity of\nGraphQL's syntax at first glance. The minimalism of GraphQL queries and\nmutations would lead one to believe that they're simple to understand right off\nthe bat. The problem with that logic is the syntax is so  simplistic, that\nthere's hardly any way of telling what nearly identical queries or mutations\nmight do from one character to the next. Even in JSON, the combination of \nexplicit quotations, key:value relationships, and  comma-separation  affords us\na lot of inferred knowledge we take for granted.\n\nI'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much\nas it can easily be frustrating to newcomers (and rightfully so). As long as\npeople keep reading, I'll keep posting, so let's chip away at this thing week by\nweek.","html":"<p>Last week we encountered a genuine scenario when working with GraphQL clients. When building real applications consuming data via GraphQL, we usually don't know precisely the query we're going to want to run at runtime. Imagine a user cruising through your application, setting preferences, and arriving at core pieces of functionality under a content which is specific only to them. Say we're building a GrubHub knockoff (we hate profits and love entering impenetrable parts of the market, it's not that uncommon really.) At its core, the information we're serving will always be restaurants; we'll always want to return things like the restaurant address, name, rating, etc. Because we want our app to be intelligent, this means that circumstances in which <strong>User 1</strong> makes a query are vastly different than <strong>User 2</strong>. Aside from the obvious facts (residing in different locales), perhaps there's more metadata we can leverage from <strong>User 1</strong>'s longterm app usage, versus <strong>User 2</strong> who is a total noob to our knockoff app.</p><p>Yet, <em>the information we're serving will always be restaurants</em>. There's a core query being reused at the heart of our requests: we need to be dynamic enough to account for the fact that <strong>User 1</strong> has checked off 13 different cuisines and strict delivery time windows, whereas <strong>User 2</strong> doesn't give a shit. <strong>User 2</strong> just wants pizza.</p><p>This is where GraphQL <em><strong>Fragments</strong></em> come in to play. We've already seen how we can pass variables through our queries to receive contextual data: the next step is creating blocks of reusable code which may never change, which become the foundational building blocks of all future queries.</p><h2 id=\"when-to-use-fragments\">When to Use Fragments</h2><p>Back to our JIRA example, I demonstrated precisely the sort of thing one should never do: making more than one GraphQL request to serve a single purpose.</p><p>To recap, we're pulling in JIRA issues to a Kanban board. Our board has 4 columns: one per \"status.\" Here's a god-awful way of hardcoding a query like that:</p><!--kg-card-begin: code--><pre><code>query JiraIssuesByStatus($project: String, $status: String) {\n\tbacklog: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  todo: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  progress: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n  done: jiraIssues(where: {project: $project, status: $status}, orderBy: updated_DESC, first: 6) {\n\tkey\n    summary\n    epic_color\n    epic_name\n    status\n    priority_rank\n    priority_url\n    issuetype_name\n    issuetype_url\n    assignee_name\n    assignee_url \n   }\n }</code></pre><!--kg-card-end: code--><p>Seems like a lot of repetition, yeah? What if we could define chunks of queries to be reused to simplify things?</p><!--kg-card-begin: code--><pre><code># Write your query or mutation here\nfragment JiraFields on jiraIssue {\n  key\n  summary\n  epic_color\n  epic_name\n  status\n  priority_rank\n  priority_url\n  issuetype_name\n  issuetype_url\n  assignee_name\n  assignee_url \n}\n\nquery JiraIssuesViaFragments($project: String) {\n  backlog: jiraIssues(where: {status: \"Backlog\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  todo: jiraIssues(where: {status: \"To Do\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  progress: jiraIssues(where: {status: \"In Progress\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n  done: jiraIssues(where: {status: \"Done\", project: $project}, orderBy: updated_DESC, first: 6) {\n    ...JiraFields\n  }\n}</code></pre><!--kg-card-end: code--><p>Progress! Instead of reiterating the fields we want to query for each time, we set these <em>once.</em> We do this by creating a <code>fragment</code> named <strong>JiraFields</strong> (naming conventions for fragments are totally up to you- these don't relate to anything). To make this easier to visualize, let's just look at the parts:</p><!--kg-card-begin: code--><pre><code>fragment [GivenNameToYourFragment] on [DatamodelToQuery(SINGULAR)] {\n  [fields] \n}</code></pre><!--kg-card-end: code--><p>Take note of <code>[nameOfDatamodelToQuery(SINGULAR)]</code>. Our fragment will refer to data model in the singular syntax  - this is important.</p><h3 id=\"our-new-query-using-a-fragment\">Our New Query Using a Fragment</h3><p>Again, let's simply what we're looking at:</p><!--kg-card-begin: code--><pre><code>query [GivenNameToYourQuery]($project: String) {\n  [subsetName]: [DatamodelToQuery(PLURAL)](where: {status: \"Backlog\", project: $project}) {\n    ...[GivenNameToYourFragment]\n  }\n}</code></pre><!--kg-card-end: code--><ul><li><code>[subsetName]</code> is the name of the embedded JSON object to be returned in the response. The naming is up to us.</li><li><code>[DatamodelToQuery(PLURAL)]</code> contrasts the singular data model we specified in our fragment.</li><li>Finally, <code>...[GivenNameToYourFragment]</code> is the syntax for dumping a fragment into a query. Yes, the <code>...</code> is intentional.</li></ul><p>Here's how we managed to get on:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-18-at-8.15.19-AM.png\" class=\"kg-image\"><figcaption>Now we're talkin'.</figcaption></figure><!--kg-card-end: image--><h2 id=\"implementing-on-the-client-side\">Implementing On The Client Side</h2><p>With the big picture in hand, this is still all theoretical until we have some real code making real dynamic queries. So which GraphQL client tools should we use?!?! Sweet baby Jesus have mercy, I wish I had a straight answer.</p><p>As we all know, <a href=\"https://github.com/apollographql/apollo-client\"><strong>Apollo</strong></a> is crushing the game with their seemingly endless libraries doing... a lot of similar stuff? Then there's <strong><a href=\"https://www.prisma.io/docs/prisma-client/basic-data-access/reading-data-JAVASCRIPT-rsc2/\">Prisma</a></strong>, the new hotshot looking to make a buck. But what about <a href=\"https://github.com/smooth-code/fraql\"><strong>this repo</strong></a>? It seems totally fine, but why won't it freakin work?! And what about this <strong><a href=\"https://github.com/kadirahq/lokka\">Lokka</a></strong> thing? Also, <a href=\"https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher\">apparently you can just use <strong>node-fetch</strong></a> anyway?</p><p>For somebody looking for simplicity, this gets very frustrating. Most clients are immediately concerned with integrating with React as fast as possible (totally understandable), but a small-town country boy like me just wants to start with simple. I'm just trying to write a god damn tutorial!</p><p>Anyway. The GraphQL ecosystem is was it is: we'd be foolish to think anything related to JavaScript could be cohesive or straightforward. Instead of wrestling with that reality, now's as good a time as ever to move on to the part of GraphQL we've failed to speak of: modifying data.</p><h2 id=\"graphql-mutation-cheatsheet\">GraphQL Mutation Cheatsheet</h2><p>Any form of creating, changing, or deleting data in GraphQL falls under the umbrella of mutations. The structure is similar to queries, except that we take data in (presumably through variables) and spit out whichever fields you'd like to see as a result of that.</p><h3 id=\"creating-records\">Creating Records</h3><p>A functioning \"create\" mutation with the resulting response:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.41-PM.png\" class=\"kg-image\"><figcaption>Simple enough.</figcaption></figure><!--kg-card-end: image--><p>And the mutation itself, just in case anybody is copy/pasting out there:</p><!--kg-card-begin: code--><pre><code>mutation CreateJiraIssue($key: String!, $summary: String!, $status: String!) {\n  createjiraissues(data: {key: $key, status: $status, summary: $summary}) {\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"updating-records\">Updating Records</h3><p>We can update records (aka nodes) by specifying the target node using <code>where: {}</code>, and the data to be updated within <code>data: {}</code></p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-19-at-1.23.28-PM.png\" class=\"kg-image\"><figcaption>Syntax is just like creating nodes, but with an added where:{} statement.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation UpdateJIRAIssue($summary: String, $status: String) {\n  updatejiraIssue(data: {status: $status, summary: $summary}, where:{key: \"HACK-10\"}) {\n    key\n    status\n    summary\n    project\n    issuetype_name\n    epic_name\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"deleting-records\">Deleting Records</h3><p>You can even specify which fields you want returned from the node you're in the act of ruthlessly murdering! </p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-08-at-4.02.20-PM.png\" class=\"kg-image\"><figcaption>And with its final breath, the node shouted out \"Hack-9999, Backlog, Test issue with GraphQL\" to please its master once last time.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: code--><pre><code>mutation DeleteJiraIssue ($key: String!){\n    deletejiraissues(where: {key: $key}){\n    key\n    status\n    summary\n  }\n}</code></pre><!--kg-card-end: code--><h3 id=\"enough-for-now\">Enough For Now</h3><p>Hopefully, I'm not the only one to have bee deceived by the simplicity of GraphQL's syntax at first glance. The minimalism of GraphQL queries and mutations would lead one to believe that they're simple to understand right off the bat. The problem with that logic is the syntax is <em>so</em> simplistic, that there's hardly any way of telling what nearly identical queries or mutations might do from one character to the next. Even in JSON, the combination of <strong>explicit quotations</strong>, <strong>key:value relationships</strong>, and<strong> comma-separation</strong> affords us a lot of inferred knowledge we take for granted.</p><p>I'm not saying GraphQL is wrong, or painstakingly difficult to pick up, as much as it can easily be frustrating to newcomers (and rightfully so). As long as people keep reading, I'll keep posting, so let's chip away at this thing week by week.</p><p></p>","url":"https://hackersandslackers.com/creating-updating-and-deleting-data-via-graphql-mutations/","uuid":"a042692b-1812-49a1-a2fb-c0bd97973edf","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c82cfe75af763016e85082e"}},{"node":{"id":"Ghost__Post__5c838ee05af763016e85085b","title":"Building a Client For Your GraphQL API","slug":"interacting-with-your-graphql-api","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","excerpt":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","custom_excerpt":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","created_at_pretty":"09 March, 2019","published_at_pretty":"09 March, 2019","updated_at_pretty":"14 April, 2019","created_at":"2019-03-09T05:01:04.000-05:00","published_at":"2019-03-09T15:43:14.000-05:00","updated_at":"2019-04-14T05:36:35.000-04:00","meta_title":"Building a Client For Your GraphQL API | Hackers and Slackers","meta_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","og_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","og_title":"Building a Client For Your GraphQL API","twitter_description":"Now that we have an understanding of GraphQL queries and API setup, it's time to get that data.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphqlclient.jpg","twitter_title":"Building a Client For Your GraphQL API","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"JavaScript","slug":"javascript","description":"JavaScript covering both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","feature_image":null,"meta_description":"JavaScript topics, both Frontend and NodeJS. Build bundles with Webpack or Parcel, create task runners, or endure our criticism of the JavaScript ecosystem.","meta_title":"Javascript Tutorials | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"If you had the pleasure of joining us last time, we had just completed a crash\ncourse in structuring GraphQL Queries\n[https://hackersandslackers.com/writing-your-first-graphql-queries/]. As much we\nall love studying abstract queries within the confines of a playground\nenvironment, the only real way to learn anything to overzealously attempt to\nbuild something way out of our skill level. Thus, we're going to shift gears and\nactually make something  with all the dry technical knowledge we've accumulated\nso far. Hooray!\n\nData Gone Wild: Exposing Your GraphQL Endpoint\nIf you're following along with Prisma as your GraphQL service, the endpoint for\nyour API defaults to [your_ip_address]:4466. What's more, you've probably\nnoticed it is publicly accessible. THIS IS VERY BAD.  Your server has full\nread/write access to whichever database you configured with it... if anybody\nfinds your endpoint hanging out in a Github commit somewhere, you've just lost\nyour database and everything in it. You're pretty much Equifax, and you should\nfeel bad.\n\nPrisma has a straightforward solution. While SSHed into\nwherever-you-set-up-your-server, check out the prisma.yaml  file which was\ngenerated as a result of when we first started getting set up. You know, this\ndirectory:\n\nmy-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n\n\nprisma.yaml  seems inglorious, but that's because it's hiding a secret; or\nshould I say, it's not  hiding a secret! Hah!... (you know, like, credentials).\nAnyway. \n\nIn order to enable authorization on our endpoint, we need to add a secret to our\n prisma.yaml  file. The secret can be anything you like; this is simply a string\nwhich will be used to generate a token. Add a line which defines secret  like\nthis:\n\nendpoint: http://localhost:4466\ndatamodel: datamodel.prisma\nsecret: HIIHGUTFTUY$VK$G$YI&TUYCUY$DT$\n\ngenerate:\n  - generator: typescript-client\n    output: ./generated/prisma-client/\n\n\nWith your secret stashed away safely, the Prisma CLI can now use this secret to\ncreate the authentication token. This will be the value we pass in the headers\nof our requests to actually interact with our Prisma server remotely.\n\nType $ prisma token  in your project directory to get the work of art:\n\n$ prisma token\neyJhbGciOiJIUzI1NiIsInUYGFUJGSFKHFGSJFKSFJKSFGJdfSwiaWF0IjoxNTUyMTYwMDQ5LCJleHAiOjE1NTI3NjQ4NDl9.xrubUg_dRc93bqqR4f6jGt-KvQRS2Xq6lRi0a0uw-C0\n\n\nNice; believe it or not, that was the \"hard\" part.\n\nEXTRA CREDIT: Assign a DNS Record and Apply a Security Certificate\nIf really want to, you could already query against your insecure IP address and\nstart receiving some information. That said, making HTTP  requests as such from \nHTTPS  origins will fail. Not only that, but you kind of look shitty for not\neven bothering to name your API, much less apply a free SSL certificate. For the\neasiest possible way to do this, see our post on using Caddy as an HTTP server\n[https://hackersandslackers.com/serve-docker-containers-with-custom-dns-and-ssl/]\n.\n\nBuilding a Javascript Client to Consume Our API\nWith our API nice and secure, we can start hitting this baby from wherever we\nwant... as long as it's a Node app. We'll start by requiring two packages:\n\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\n\nGraphQLClient  is the magic behind our client- it's everything. It also happens\nto be very similar to existing npm  libraries for making requests, such as \nnode-fetch [https://hackersandslackers.com/making-api-requests-with-nodejs/].\n\nWe'll also leverage the dotenv  library to make sure our API endpoint  and \nBearer token  stay out of source code. Try not to be Equifax whenever possible. \ndotenv  allows us to load sensitive values from a .env  file. Just in case you\nneed a refresher, that file should look like this:\n\nNODE_ENV=Production\nENDPOINT=https://yourapiendpoint.com\nAUTH=Bearer eyJhbGciOBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHGUYFIERIBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHZl-UGnMrOk3w\n\nInitialize The GraphQL Client\nI like to set up a one-time client for our API that we can go back and reuse if\nneed be. After pulling the API endpoint and token from our .env  file, setting\nup the client is easy:\n\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n\nEMERGENCY MEETING: EVERYBODY HUDDLE UP\nOh I'm sorry, were you focusing on development? Unfortunately for you, I spent 8\nyears as a product manager, and I love  stopping everything suddenly to call\nemergency meetings.\n\nReal talk though, let's think back to the JIRA Kanban board example we've been\nusing for the last two posts. If you recall, we're going to write a query that\npopulates a 4-column Kanban board. The board represents a project (in this case,\n Hackers and Slackers) and each column represents a status  of ticket, like\nthis:\n\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n\nWe've previously established that GraphQL queries are friendly to drop-in\nvariables. Let's use this to build some logic into our client, as opposed to\nhardcoding a massive query, which is really just the same 4 queries stitched\ntogether. Here's what a query to populate a single JIRA column looks like:\n\n// Structured query\nconst query = `\n    query JiraIssuesByStatus($project: String, $status: String) {\n         jiraIssues(where: {project: $project, status: $status}, \n         orderBy: timestamp_DESC, \n         first: 6) {\n            key\n            summary\n            epic\n            status\n            project\n            priority\n            issuetype\n            timestamp\n            }\n         }\n       `\n\nWe're passing both the project  and the issue status  as variables to our query.\nWe can make things a bit dynamic here by looping through our statuses and\nexecuting this query four times: each time resulting in a callback filling the\nappropriate columns with JIRA issues.\n\nThis approach is certainly less clunky and more dynamic than a hardcoded query.\nThat said, this still  isn't the best solution. Remember: the strength of\nGraphQL is the ability to get obscene amounts of data across complex\nrelationships in a single call. The best approach here would probably be to\nbuild the query string itself dynamically using fragments,  which we'll review\nin the next post.Game On: Our Client in Action\nconst { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n// Structured query\nconst query = `\n   query JiraIssuesByStatus($project: String, $status: String) {\n      jiraIssues(where: {project: $project, status: $status}, orderBy: timestamp_DESC, first: 6) {\n         key\n         summary\n         epic\n         status\n         project\n         priority\n         issuetype\n         timestamp\n        }\n      }\n    `;\n\n// All Possible Issue Statuses\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n// Execute a query per issue status\nfor(var i = 0; i < statuses.length; i++){\n  var variables = {\n    project: \"Hackers and Slackers\",\n    status: statuses[i]\n  }\n\n  client.request(query, variables).then((data) => {\n    console.log(data)\n  }).catch(err => {\n    console.log(err.response.errors) // GraphQL response errors\n    console.log(err.response.data) // Response data if available\n  });\n}\n\n\nWorks like a charm. We only had one endpoint, only had to set one header, and\ndidn't spend any time reading through hundreds of pages of documentation to\nfigure out which combination of REST API endpoint, parameters, and methods\nactually get us what we want. It's almost as if we're writing SQL now, except...\nit looks a lot more like... NoSQL. Thanks for the inspiration, MongoDB! Hope\nthat whole selling-open-source-software  thing works out.\n\nOh, and of course, here were the results of my query:\n\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550194791,\n       project: 'Hackers and Slackers',\n       key: 'HACK-778',\n       epic: 'Code snippets',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'HLJS: set indentation level' },\n     { priority: 'Medium',\n       timestamp: 1550194782,\n\n       project: 'Hackers and Slackers',\n       key: 'HACK-555',\n       epic: 'Optimization',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Minify Babel' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-785',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Unix commands for data' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-251',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Using Ghost\\'s content filtering' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-302',\n       epic: 'Widgets',\n       status: 'Backlog',\n       issuetype: 'Integration',\n       summary: 'Discord channel signups ' },\n     { priority: 'Low',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-336',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Linux: Configuring your server to send SMTP emails' } ] }\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550224412,\n       project: 'Hackers and Slackers',\n       key: 'HACK-769',\n       epic: 'Projects Page',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'Fix projects dropdown' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-710',\n       epic: 'Lynx',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Implement auto text synopsis for Lynx posts' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-777',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Redesign footer to be informative; link-heavy' },\n     { priority: 'Highest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-779',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Changeover from cloudinary to DO' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-780',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Make mobile post title bold' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-781',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'This post consistently doesn’t work on mobile' } ] }\n{ jiraIssues:\n   [ { priority: 'Low',\n       timestamp: 1550223282,\n       project: 'Hackers and Slackers',\n       key: 'HACK-782',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary:\n        'Lynx: on mobile, instead of full link, show domainname.com/...' },\n     { priority: 'High',\n       timestamp: 1550194799,\n       project: 'Hackers and Slackers',\n       key: 'HACK-774',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'New Widget: Next/Previous article in series' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-395',\n       epic: 'Page Templates',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Create fallback image for posts with no image' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-756',\n       epic: 'Newsletter',\n       status: 'To Do',\n       issuetype: 'Major Functionality',\n       summary: 'Automate newsletter' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-775',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Data & Analytics',\n       summary: 'Update issuetype icons' },\n     { priority: 'Lowest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-776',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Add fork icon to repos' } ] }\n{ jiraIssues:\n   [ { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-784',\n       epic: 'New Post',\n       status: 'In Progress',\n       issuetype: 'Content',\n       summary: 'Welcome to SQL part1' } ] }\n\n\nBefore we say \"GG, 2ez, 1v1 me,\" know that we're  only getting started \nuncovering what GraphQL can do. It's not all just creating and deleting records\neither; we're talking full-on database JOIN equivalent type shit here. Stick\naround folks, the bandwagon's just getting warmed up.","html":"<p>If you had the pleasure of joining us last time, we had just completed a <a href=\"https://hackersandslackers.com/writing-your-first-graphql-queries/\">crash course in structuring GraphQL Queries</a>. As much we all love studying abstract queries within the confines of a playground environment, the only real way to learn anything to overzealously attempt to build something way out of our skill level. Thus, we're going to shift gears and actually <em>make something</em> with all the dry technical knowledge we've accumulated so far. Hooray!</p><h2 id=\"data-gone-wild-exposing-your-graphql-endpoint\">Data Gone Wild: Exposing Your GraphQL Endpoint</h2><p>If you're following along with Prisma as your GraphQL service, the endpoint for your API defaults to <code>[your_ip_address]:4466</code>. What's more, you've probably noticed it is publicly accessible. <strong>THIS IS VERY BAD.</strong> Your server has full read/write access to whichever database you configured with it... if anybody finds your endpoint hanging out in a Github commit somewhere, you've just lost your database and everything in it. You're pretty much Equifax, and you should feel bad.</p><p>Prisma has a straightforward solution. While SSHed into wherever-you-set-up-your-server, check out the <code>prisma.yaml</code> file which was generated as a result of when we first started getting set up. You know, this directory:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">my-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n</code></pre>\n<!--kg-card-end: markdown--><p><code>prisma.yaml</code> seems inglorious, but that's because it's hiding a secret; or should I say, it's <em>not</em> hiding a secret! Hah!... (you know, like, credentials). Anyway. </p><p>In order to enable authorization on our endpoint, we need to add a secret to our <code>prisma.yaml</code> file. The secret can be anything you like; this is simply a string which will be used to generate a token. Add a line which defines <code>secret</code> like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">endpoint: http://localhost:4466\ndatamodel: datamodel.prisma\nsecret: HIIHGUTFTUY$VK$G$YI&amp;TUYCUY$DT$\n\ngenerate:\n  - generator: typescript-client\n    output: ./generated/prisma-client/\n</code></pre>\n<!--kg-card-end: markdown--><p>With your secret stashed away safely, the <strong>Prisma CLI </strong>can now use this secret to create the authentication token. This will be the value we pass in the headers of our requests to actually interact with our Prisma server remotely.</p><p>Type <code>$ prisma token</code> in your project directory to get the work of art:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ prisma token\neyJhbGciOiJIUzI1NiIsInUYGFUJGSFKHFGSJFKSFJKSFGJdfSwiaWF0IjoxNTUyMTYwMDQ5LCJleHAiOjE1NTI3NjQ4NDl9.xrubUg_dRc93bqqR4f6jGt-KvQRS2Xq6lRi0a0uw-C0\n</code></pre>\n<!--kg-card-end: markdown--><p>Nice; believe it or not, that was the \"hard\" part.</p><h3 id=\"extra-credit-assign-a-dns-record-and-apply-a-security-certificate\">EXTRA CREDIT: Assign a DNS Record and Apply a Security Certificate</h3><p>If really want to, you could already query against your insecure IP address and start receiving some information. That said, making <strong>HTTP</strong> requests as such from <strong>HTTPS</strong> origins will fail. Not only that, but you kind of look shitty for not even bothering to name your API, much less apply a free SSL certificate. For the easiest possible way to do this, see our post on <a href=\"https://hackersandslackers.com/serve-docker-containers-with-custom-dns-and-ssl/\">using Caddy as an HTTP server</a>.</p><h2 id=\"building-a-javascript-client-to-consume-our-api\">Building a Javascript Client to Consume Our API</h2><p>With our API nice and secure, we can start hitting this baby from wherever we want... as long as it's a Node app. We'll start by requiring two packages:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n</code></pre>\n<!--kg-card-end: markdown--><p><code>GraphQLClient</code> is the magic behind our client- it's everything. It also happens to be very similar to existing <strong>npm</strong> libraries for making requests, such as <a href=\"https://hackersandslackers.com/making-api-requests-with-nodejs/\">node-fetch</a>.</p><p>We'll also leverage the <code>dotenv</code> library to make sure our <strong>API endpoint</strong> and <strong>Bearer token</strong> stay out of source code. Try not to be Equifax whenever possible. <code>dotenv</code> allows us to load sensitive values from a <code>.env</code> file. Just in case you need a refresher, that file should look like this:</p><!--kg-card-begin: code--><pre><code>NODE_ENV=Production\nENDPOINT=https://yourapiendpoint.com\nAUTH=Bearer eyJhbGciOBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHGUYFIERIBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHBLAHZl-UGnMrOk3w</code></pre><!--kg-card-end: code--><h3 id=\"initialize-the-graphql-client\">Initialize The GraphQL Client</h3><p>I like to set up a one-time client for our API that we can go back and reuse if need be. After pulling the API endpoint and token from our <code>.env</code> file, setting up the client is easy:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"emergency-meeting-everybody-huddle-up\">EMERGENCY MEETING: EVERYBODY HUDDLE UP</h2><p>Oh I'm sorry, were you focusing on development? Unfortunately for you, I spent 8 years as a product manager, and I <em>love</em> stopping everything suddenly to call emergency meetings.</p><p>Real talk though, let's think back to the JIRA Kanban board example we've been using for the last two posts. If you recall, we're going to write a query that populates a 4-column Kanban board. The board represents a <em>project </em>(in this case, <strong>Hackers and Slackers</strong>) and each column represents a <em>status</em> of ticket, like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n</code></pre>\n<!--kg-card-end: markdown--><p>We've previously established that GraphQL queries are friendly to drop-in variables. Let's use this to build some logic into our client, as opposed to hardcoding a massive query, which is really just the same 4 queries stitched together. Here's what a query to populate a single JIRA column looks like:</p><!--kg-card-begin: code--><pre><code>// Structured query\nconst query = `\n    query JiraIssuesByStatus($project: String, $status: String) {\n         jiraIssues(where: {project: $project, status: $status}, \n         orderBy: timestamp_DESC, \n         first: 6) {\n            key\n            summary\n            epic\n            status\n            project\n            priority\n            issuetype\n            timestamp\n            }\n         }\n       `</code></pre><!--kg-card-end: code--><p>We're passing both the <em>project</em> and the <em>issue status</em> as variables to our query. We can make things a bit dynamic here by looping through our statuses and executing this query four times: each time resulting in a callback filling the appropriate columns with JIRA issues.</p><!--kg-card-begin: html--><div class=\"protip\">\nThis approach is certainly less clunky and more dynamic than a hardcoded query. That said, this <i>still</i> isn't the best solution. Remember: the strength of GraphQL is the ability to get obscene amounts of data across complex relationships in a single call. The best approach here would probably be to build the query string itself dynamically using <strong>fragments,</strong> which we'll review in the next post.\n</div><!--kg-card-end: html--><h2 id=\"game-on-our-client-in-action\">Game On: Our Client in Action</h2><!--kg-card-begin: markdown--><pre><code class=\"language-javascript\">const { GraphQLClient } = require('graphql-request')\nconst { dotenv } = require('dotenv').config()\n\nconst endpoint = process.env.ENDPOINT;\nconst token = process.env.AUTH;\n\n// Initialize GraphQL Client\nconst client = new GraphQLClient(endpoint, {\n  headers: {\n    Authorization: token\n  }\n});\n\n// Structured query\nconst query = `\n   query JiraIssuesByStatus($project: String, $status: String) {\n      jiraIssues(where: {project: $project, status: $status}, orderBy: timestamp_DESC, first: 6) {\n         key\n         summary\n         epic\n         status\n         project\n         priority\n         issuetype\n         timestamp\n        }\n      }\n    `;\n\n// All Possible Issue Statuses\nconst statuses = ['Backlog', 'To Do', 'In Progress', 'Done'];\n\n// Execute a query per issue status\nfor(var i = 0; i &lt; statuses.length; i++){\n  var variables = {\n    project: &quot;Hackers and Slackers&quot;,\n    status: statuses[i]\n  }\n\n  client.request(query, variables).then((data) =&gt; {\n    console.log(data)\n  }).catch(err =&gt; {\n    console.log(err.response.errors) // GraphQL response errors\n    console.log(err.response.data) // Response data if available\n  });\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Works like a charm. We only had one endpoint, only had to set one header, and didn't spend any time reading through hundreds of pages of documentation to figure out which combination of REST API endpoint, parameters, and methods actually get us what we want. It's almost as if we're writing SQL now, except... it looks a lot more like... NoSQL. Thanks for the inspiration, <strong>MongoDB</strong>! Hope that whole <em>selling-open-source-software</em> thing works out.</p><p>Oh, and of course, here were the results of my query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550194791,\n       project: 'Hackers and Slackers',\n       key: 'HACK-778',\n       epic: 'Code snippets',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'HLJS: set indentation level' },\n     { priority: 'Medium',\n       timestamp: 1550194782,\n\n       project: 'Hackers and Slackers',\n       key: 'HACK-555',\n       epic: 'Optimization',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Minify Babel' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-785',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Task',\n       summary: 'Unix commands for data' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-251',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Using Ghost\\'s content filtering' },\n     { priority: 'Medium',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-302',\n       epic: 'Widgets',\n       status: 'Backlog',\n       issuetype: 'Integration',\n       summary: 'Discord channel signups ' },\n     { priority: 'Low',\n       timestamp: 1550016000,\n       project: 'Hackers and Slackers',\n       key: 'HACK-336',\n       epic: 'New Post',\n       status: 'Backlog',\n       issuetype: 'Content',\n       summary: 'Linux: Configuring your server to send SMTP emails' } ] }\n{ jiraIssues:\n   [ { priority: 'Medium',\n       timestamp: 1550224412,\n       project: 'Hackers and Slackers',\n       key: 'HACK-769',\n       epic: 'Projects Page',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'Fix projects dropdown' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-710',\n       epic: 'Lynx',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Implement auto text synopsis for Lynx posts' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-777',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Redesign footer to be informative; link-heavy' },\n     { priority: 'Highest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-779',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Changeover from cloudinary to DO' },\n     { priority: 'Medium',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-780',\n       epic: 'Creative',\n       status: 'Done',\n       issuetype: 'Task',\n       summary: 'Make mobile post title bold' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-781',\n       epic: 'Urgent',\n       status: 'Done',\n       issuetype: 'Bug',\n       summary: 'This post consistently doesn’t work on mobile' } ] }\n{ jiraIssues:\n   [ { priority: 'Low',\n       timestamp: 1550223282,\n       project: 'Hackers and Slackers',\n       key: 'HACK-782',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary:\n        'Lynx: on mobile, instead of full link, show domainname.com/...' },\n     { priority: 'High',\n       timestamp: 1550194799,\n       project: 'Hackers and Slackers',\n       key: 'HACK-774',\n       epic: 'Widgets',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'New Widget: Next/Previous article in series' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-395',\n       epic: 'Page Templates',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Create fallback image for posts with no image' },\n     { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-756',\n       epic: 'Newsletter',\n       status: 'To Do',\n       issuetype: 'Major Functionality',\n       summary: 'Automate newsletter' },\n     { priority: 'Low',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-775',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Data &amp; Analytics',\n       summary: 'Update issuetype icons' },\n     { priority: 'Lowest',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-776',\n       epic: 'Projects Page',\n       status: 'To Do',\n       issuetype: 'Task',\n       summary: 'Add fork icon to repos' } ] }\n{ jiraIssues:\n   [ { priority: 'High',\n       timestamp: 1550102400,\n       project: 'Hackers and Slackers',\n       key: 'HACK-784',\n       epic: 'New Post',\n       status: 'In Progress',\n       issuetype: 'Content',\n       summary: 'Welcome to SQL part1' } ] }\n</code></pre>\n<!--kg-card-end: markdown--><p>Before we say \"GG, 2ez, 1v1 me,\" know that we're<em> only getting started</em> uncovering what GraphQL can do. It's not all just creating and deleting records either; we're talking full-on database JOIN equivalent type shit here. Stick around folks, the bandwagon's just getting warmed up.</p>","url":"https://hackersandslackers.com/interacting-with-your-graphql-api/","uuid":"34fef193-6a56-4754-a329-3d34571fcd15","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c838ee05af763016e85085b"}},{"node":{"id":"Ghost__Post__5c806baf199621174e904b03","title":"Writing Your First GraphQL Query","slug":"writing-your-first-graphql-queries","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-3.jpg","excerpt":"Begin to structure complex queries against your GraphQL API.","custom_excerpt":"Begin to structure complex queries against your GraphQL API.","created_at_pretty":"07 March, 2019","published_at_pretty":"07 March, 2019","updated_at_pretty":"28 March, 2019","created_at":"2019-03-06T19:54:07.000-05:00","published_at":"2019-03-07T10:37:00.000-05:00","updated_at":"2019-03-28T11:01:59.000-04:00","meta_title":"Writing Your First GraphQL Queries | Hackers and Slackers","meta_description":"Structure your first GraphQL Queries and begin to build a client.","og_description":"Structure your first GraphQL Queries and begin to build a client.","og_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-3.jpg","og_title":"Writing Your First GraphQL Queries","twitter_description":"Structure your first GraphQL Queries and begin to build a client.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/graphql-1-2.jpg","twitter_title":"Writing Your First GraphQL Queries","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"In our last run-in with GraphQL, we used Prisma  to assist in setting up a\nGraphQL server\n[https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/]. This\neffectively gave us an endpoint to work with for making GraphQL requests against\nthe database we specified when getting started. If you're still in the business\nof setting up a GraphQL server, there are plenty of alternative services to\nPrisma you could explore. Apollo [https://www.apollographql.com/]  is perhaps\nthe most popular. A different approach could be to use GraphCMS\n[https://graphcms.com/]: a headless CMS for building GraphQL models with a\nbeautiful interface.\n\nWith our first models are created and deployed, we’re now able to explore\nGraphQL hands-on. Prisma (and just about any other service) gives us the luxury\nof a “playground” interface, where we can write all sorts of nonsensical and\notherwise dangerous shit. This is our opportunity to get comfortable before\nunleashing our ignorance upon the world in a production environment. To guide\nus, I’ll be using my own example of creating models, importing dummy data, and\nhow to write the queries to fetch said data.\n\nOur Example Model\nIn my case, I created a model for one of my favorite things: JIRA issues. I'll\nbe creating a Kanban widget using the data we play with here down the line, so\nthis is a real live use-case we'll be working with.\n\nHere are the contents of my datamodel.prisma  file:\n\ntype jiraissue {\n  id: ID! @unique,\n  key: String! @unique,\n  assignee: String,\n  summary: String,\n  status: String!,\n  priority: String,\n  issuetype: String,\n  epic_name: String,\n  updated: DateTime,\n  rank: Int,\n  timestamp: Int,\n  project: String\n}\n\nYou'll notice we have a good number of datatypes here, as well as two unique\nkeys. In case this point has been missed before, the exclamation marks in our\nmodel denote a required field.\n\nDeploying this model results in the following PostgreSQL query:\n\nCREATE TABLE \"default$default\".\"jiraissues\" (\n    \"id\" varchar(25) NOT NULL,\n    \"key\" text NOT NULL,\n    \"assignee\" text,\n    \"summary\" text,\n    \"status\" text NOT NULL,\n    \"priority\" text,\n    \"issuetype\" text,\n    \"epic_name\" text,\n    \"updated\" timestamp(3),\n    \"rank\" int4,\n    \"timestamp\" int4,\n    \"project\" text,\n    \"updatedAt\" timestamp(3) NOT NULL,\n    \"createdAt\" timestamp(3) NOT NULL,\n    PRIMARY KEY (\"id\")\n);\n\n\nLooks like everything lines up! The only caveat are the updatedAt  and createdAt \n fields: Prisma adds these to every database table for us.\n\nHere's a sample of the data I added by connecting to my database and importing a\nCSV:\n\nid\n key\n assignee\n summary\n status\n priority\n issuetype\n epic_name\n updated\n rank\n timestamp\n project\n updatedAt\n createdAt\n 430\n HACK-769\n Todd Birchard\n Fix projects dropdown\n Done\n Medium\n Bug\n Projects Page\n 2019-02-15 00:00:00\n 3\n 1550224412\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 465\n HACK-782\n Todd Birchard\n Lynx: on mobile, instead of full link, show domainname.com/...\n To Do\n Low\n Task\n Widgets\n 2019-02-15 00:00:00\n 4\n 1550223282\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 472\n HACK-774\n Todd Birchard\n New Widget: Next/Previous article in series\n To Do\n High\n Task\n Widgets\n 2019-02-14 00:00:00\n 2\n 1550194799\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 464\n HACK-778\n Todd Birchard\n HLJS: set indentation level\n Backlog\n Medium\n Task\n Code snippets\n 2019-02-14 00:00:00\n 3\n 1550194791\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 481\n HACK-555\n Todd Birchard\n Minify Babel\n Backlog\n Medium\n Task\n Optimization\n 2019-02-14 00:00:00\n 3\n 1550194782\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 432\n HACK-777\n Todd Birchard\n Redesign footer to be informative; link-heavy\n Done\n Medium\n Task\n Creative\n 2019-02-14 00:00:00\n 2\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 433\n HACK-779\n Todd Birchard\n Changeover from cloudinary to DO\n Done\n Highest\n Task\n Urgent\n 2019-02-14 00:00:00\n 0\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 428\n HACK-775\n Todd Birchard\n Update issuetype icons\n To Do\n Low\n Data & Analytics\n Projects Page\n 2019-02-14 00:00:00\n 3\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 374\n HACK-710\n Todd Birchard\n Implement auto text synopsis for Lynx posts\n Done\n High\n Task\n Lynx\n 2019-02-14 00:00:00\n 1\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n 185\n HACK-395\n Todd Birchard\n Create fallback image for posts with no image\n To Do\n Low\n Task\n Page Templates\n 2019-02-14 00:00:00\n 3\n 1550102400\n Hackers and Slackers\n 2019-03-02 15:43:59.419\n 2019-03-02 15:43:59.419\n A Few Things About GraphQL Queries\nBefore going any further, let's touch on a few concepts that are easy to stumble\nover.\n\nFirstly, a  GraphQL API only has a single endpoint. It makes sense: the logic of\nGraphQL API hits sit with the person creating the queries. That said, we've all\nbeen building REST APIs long enough to have this slip past us; I caught myself\nthinking through how to separate which endpoints I wanted before remembering\nthat's entirely not how this works.\n\nIt's import to understand that GraphQL is designed to be explicit. A significant\nadvantage of GraphQL is that we can be sure only to return the information which\nis essential to us.  For applications looking to optimize system resources (such\nas mobile apps), avoiding massive payloads is a feature, not a bug. This\nexplains many of the design decisions which went into designing GraphQL, as\nyou'll see it's intentionally difficult (but possible) to create a \"get all\nrecords\" query.\n\nLastly, GraphQL allows us to create queries in both shorthand and long-form  \nformats.  We'll take a look at both, starting with shorthand.\n\nGraphQL Shorthand Queries\nShorthand queries are an excellent place to start for beginners like us just\ntrying to get some data out of our database.\n\nThe structure of such a query looks like this:\n\n{\n  [model_name]s {\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n\nUsing our example, our model_name  in this case would be jiraissue made plural, \nresulting in jiraissues. This is an important thing to note: when creating\nmodels, we should name them as a single entity, as things get confusing very\nfast otherwise. I initially made the mistake of naming my model jiraissues,\nwhich would then drive me to query jiraissueses. That was a fun little trip.\n\nWithin the brackets of our model, we must explicitly specify which fields (aka\ndatabase columns) we'd like returned with our query. Here's a full example of a\nshorthand query:\n\n{\n  jiraissues {\n    key\n    summary\n    epic_name\n  }\n}\n\n\nCheck out what this results in when entered in our \"playground\":\n\nQuery on the left, results on the right.Just like that, we have liftoff!\n\nThe \"Where\" Clause\nAs mentioned earlier, a major point of GraphQL is to return only the data which\nis necessary. Thus, we should almost always make queries with a where clause.\nThus, we can extend our simple query as such:\n\n{\n  jiraissueses(where: {status: \"Backlog\"}) {\n    key\n    summary\n    epic_name\n    status\n  }\n}\n\n\nAnd here's the result:\n\nFiltering results \"where\" certain criteria are met.Adding to Our Query\nJust like SQL or MongoDB queries, we can add more to our query to get more\nspecific:\n\n{\n  jiraissues(where: {status: \"Backlog\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC,  first: 6) \n  {\n    key\n    summary\n    epic_name\n    status\n    updated\n  }\n}\n\n\nHere, we've expanded our filter to work on two  fields: now our query will only\nreturn issues which match our criteria for both status  and project. \n\nWe've also added a few other things to our query. With orderBy, we can set the\norder in which records will be returned to us by field, either in ascending\n(ASC) or descending (DESC) order. first  imposes a limit on our results, giving\nus the first 6 which meet our criteria. Alternatively, last  would give us the\nopposite.\n\nThere are plenty of more parameters we could add here. For example:\n\n * [fieldname]_contains: Filters results where the string field contains a\n   substring.\n * [fieldname]_in: Checks a list to return records where the value of the field\n   matches any substring in a provided list.\n * [fieldname]_starts_with: An expression to check for values that start with a\n   provided substring.\n * [fieldname]_ends_with: Similar to the above, only for ending with a\n   substring.\n\nNot only are there more to add to this list, but each as an accompanying reverse\nstatement which would return the opposite. For example, [fieldname]_not_contains \n is the opposite of [fieldname]_contains.\n\nGraphQL Longform Queries\nWhat we've seen so far is already pretty powerful, but we're far from seeing\njust how far GraphQL can go. \n\nTo demonstrate what a more complicated query is capable of, let's use out Kanban\nboard example. Our board is going to have 4 columns representing 4 statuses: \nBacklog, To Do, In Progress, and Done.  Check out how we can receive all of this\nwith a single query:\n\nquery KanbanJiraIssues {\n  backlog: jiraissues(where: {status: \"Backlog\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  todo: jiraissues(where: {status: \"To Do\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  inprogress: jiraissues(where: {status: \"In Progress\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  done: jiraissues(where: {status: \"Done\", project: \"Hackers and Slackers\"}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n}\n\n\nUnlike our shorthand queries, we begin this query with the syntax query\n[your_query_name]. You can name your query anything you'd like.\n\nWithin that query, we can perform multiple individual queries which we too give\ndisplay names. In whole, the structure looks like this:\\\n\nquery [your_query_name] {\n  [subquery_name]: [model_name]s(where: {[your_criteria]}){\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n\n\nCheck out the result:\n\nNow THAT's a query.This format has helped us accomplish something previously\nimpossible with REST APIs: we've used a single endpoint to give us exactly  the\ninformation we need while omitting the information we don't.\n\nPassing Variables Into Queries\nAs you can see, queries can get lengthy pretty quick. It would suck if we had to\nwrite the entirety of the query above every time we wanted to hit an API.\nLuckily, we don't don't have to: that's where GraphQL variables come in.\n\nVariables allow us to use the structure of a GraphQL query repeatedly, while\nproviding different values where we see fit. That means if we have a\nparticularly complicated query structure that we'd like to repurpose, we can\npass dynamic values into said query. This is where things start to get really\npowerful.\n\nLet's assume that finding JIRA issues by epic link  is a common task we'll have\nto deal with. This is how we'd pass a dynamic value for epic_link:\n\nquery JiraIssuesByEpicName($epic_name: String) {\n  jiraissues(where: {epic_name: $epic_name}) {\n    key\n    summary\n    epic_name\n    status\n    updated\n    project\n    priority\n    issuetype\n    timestamp\n  }\n}\n\n$epic_name  is the name of our variable, which we set in the object we pass to\nthe query. That object looks like this:\n\n{\n  \"epic_name\": \"SEO\"\n}\n\nSo what we're saying on line 1  is that we're passing a variable named \n$epic_name, and that variable will be a String. When $epic_name  appears again\non line 2, the variable is interpreted as its value, which is \"SEO\".\n\nLuckily, our playground has a place specifically for setting variables which get\npassed to our queries. Here's how it all looks:\n\nHeavy breathing intensifies.Unlimited Power?\nWhile GraphQL's syntax looks clean and simple at first glance, it's easy to see\nhow quickly simple queries evolve into complex behemoths. It's no coincidence\nthat all GraphQL services come with a playground. It's hard to imagine how\nanybody could internalize GraphQL syntax without trial and error, and we're only\ngetting started.\n\nSo far we've only queried existing data; we haven't even begun to touch on\nmutations yet. Catch us next time when we start modifying data and get ourselves\ninto a whole lot of trouble.","html":"<p>In our last run-in with GraphQL, we used <strong>Prisma</strong> to assist in <a href=\"https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/\">setting up a GraphQL server</a>. This effectively gave us an endpoint to work with for making GraphQL requests against the database we specified when getting started. If you're still in the business of setting up a GraphQL server, there are plenty of alternative services to Prisma you could explore. <a href=\"https://www.apollographql.com/\"><strong>Apollo</strong></a> is perhaps the most popular. A different approach could be to use <a href=\"https://graphcms.com/\"><strong>GraphCMS</strong></a>: a headless CMS for building GraphQL models with a beautiful interface.</p><p>With our first models are created and deployed, we’re now able to explore GraphQL hands-on. Prisma (and just about any other service) gives us the luxury of a “playground” interface, where we can write all sorts of nonsensical and otherwise dangerous shit. This is our opportunity to get comfortable before unleashing our ignorance upon the world in a production environment. To guide us, I’ll be using my own example of creating models, importing dummy data, and how to write the queries to fetch said data.</p><h2 id=\"our-example-model\">Our Example Model</h2><p>In my case, I created a model for one of my favorite things: JIRA issues. I'll be creating a Kanban widget using the data we play with here down the line, so this is a real live use-case we'll be working with.</p><p>Here are the contents of my <code>datamodel.prisma</code> file:</p><!--kg-card-begin: code--><pre><code>type jiraissue {\n  id: ID! @unique,\n  key: String! @unique,\n  assignee: String,\n  summary: String,\n  status: String!,\n  priority: String,\n  issuetype: String,\n  epic_name: String,\n  updated: DateTime,\n  rank: Int,\n  timestamp: Int,\n  project: String\n}</code></pre><!--kg-card-end: code--><p>You'll notice we have a good number of datatypes here, as well as two unique keys. In case this point has been missed before, the exclamation marks in our model denote a required field.</p><p>Deploying this model results in the following PostgreSQL query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">CREATE TABLE &quot;default$default&quot;.&quot;jiraissues&quot; (\n    &quot;id&quot; varchar(25) NOT NULL,\n    &quot;key&quot; text NOT NULL,\n    &quot;assignee&quot; text,\n    &quot;summary&quot; text,\n    &quot;status&quot; text NOT NULL,\n    &quot;priority&quot; text,\n    &quot;issuetype&quot; text,\n    &quot;epic_name&quot; text,\n    &quot;updated&quot; timestamp(3),\n    &quot;rank&quot; int4,\n    &quot;timestamp&quot; int4,\n    &quot;project&quot; text,\n    &quot;updatedAt&quot; timestamp(3) NOT NULL,\n    &quot;createdAt&quot; timestamp(3) NOT NULL,\n    PRIMARY KEY (&quot;id&quot;)\n);\n</code></pre>\n<!--kg-card-end: markdown--><p>Looks like everything lines up! The only caveat are the <code>updatedAt</code> and <code>createdAt</code> fields: Prisma adds these to every database table for us.</p><p>Here's a sample of the data I added by connecting to my database and importing a CSV:</p><!--kg-card-begin: html--><div class=\"tableContainer\">\n<table>\n    <thead>\n       <tr>\n             <th>id</th>\n             <th>key</th>\n             <th>assignee</th>\n             <th>summary</th>\n             <th>status</th>\n             <th>priority</th>\n             <th>issuetype</th>\n             <th>epic_name</th>\n             <th>updated</th>\n             <th>rank</th>\n             <th>timestamp</th>\n             <th>project</th>\n             <th>updatedAt</th>\n             <th>createdAt</th>\n         </tr>\n    </thead>\n    <tbody>\n       <tr>\n              <td>430</td>\n              <td>HACK-769</td>\n              <td>Todd Birchard</td>\n              <td>Fix projects dropdown</td>\n              <td>Done</td>\n              <td>Medium</td>\n              <td>Bug</td>\n              <td>Projects Page</td>\n              <td>2019-02-15 00:00:00</td>\n              <td>3</td>\n              <td>1550224412</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>465</td>\n              <td>HACK-782</td>\n              <td>Todd Birchard</td>\n              <td>Lynx: on mobile, instead of full link, show domainname.com/...</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Task</td>\n              <td>Widgets</td>\n              <td>2019-02-15 00:00:00</td>\n              <td>4</td>\n              <td>1550223282</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>472</td>\n              <td>HACK-774</td>\n              <td>Todd Birchard</td>\n              <td>New Widget: Next/Previous article in series</td>\n              <td>To Do</td>\n              <td>High</td>\n              <td>Task</td>\n              <td>Widgets</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>2</td>\n              <td>1550194799</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>464</td>\n              <td>HACK-778</td>\n              <td>Todd Birchard</td>\n              <td>HLJS: set indentation level</td>\n              <td>Backlog</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Code snippets</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550194791</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>481</td>\n              <td>HACK-555</td>\n              <td>Todd Birchard</td>\n              <td>Minify Babel</td>\n              <td>Backlog</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Optimization</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550194782</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>432</td>\n              <td>HACK-777</td>\n              <td>Todd Birchard</td>\n              <td>Redesign footer to be informative; link-heavy</td>\n              <td>Done</td>\n              <td>Medium</td>\n              <td>Task</td>\n              <td>Creative</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>2</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>433</td>\n              <td>HACK-779</td>\n              <td>Todd Birchard</td>\n              <td>Changeover from cloudinary to DO</td>\n              <td>Done</td>\n              <td>Highest</td>\n              <td>Task</td>\n              <td>Urgent</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>0</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>428</td>\n              <td>HACK-775</td>\n              <td>Todd Birchard</td>\n              <td>Update issuetype icons</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Data & Analytics</td>\n              <td>Projects Page</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>374</td>\n              <td>HACK-710</td>\n              <td>Todd Birchard</td>\n              <td>Implement auto text synopsis for Lynx posts</td>\n              <td>Done</td>\n              <td>High</td>\n              <td>Task</td>\n              <td>Lynx</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>1</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n       <tr>\n              <td>185</td>\n              <td>HACK-395</td>\n              <td>Todd Birchard</td>\n              <td>Create fallback image for posts with no image</td>\n              <td>To Do</td>\n              <td>Low</td>\n              <td>Task</td>\n              <td>Page Templates</td>\n              <td>2019-02-14 00:00:00</td>\n              <td>3</td>\n              <td>1550102400</td>\n              <td>Hackers and Slackers</td>\n              <td>2019-03-02 15:43:59.419</td>\n              <td>2019-03-02 15:43:59.419</td>\n          </tr>\n    </tbody>\n   </table>\n</div><!--kg-card-end: html--><h2 id=\"a-few-things-about-graphql-queries\">A Few Things About GraphQL Queries</h2><p>Before going any further, let's touch on a few concepts that are easy to stumble over.</p><p>Firstly, a<strong> GraphQL API only has a single endpoint</strong>. It makes sense: the logic of GraphQL API hits sit with the person creating the queries. That said, we've all been building REST APIs long enough to have this slip past us; I caught myself thinking through how to separate which endpoints I wanted before remembering that's entirely not how this works.</p><p>It's import to understand that <strong>GraphQL is designed to be explicit</strong>. A significant advantage of GraphQL is that we can be sure <em>only to return the information which is essential to us.</em> For applications looking to optimize system resources (such as mobile apps), avoiding massive payloads is a feature, not a bug. This explains many of the design decisions which went into designing GraphQL, as you'll see it's intentionally difficult (but possible) to create a \"get all records\" query.</p><p>Lastly, GraphQL allows us to <strong>create queries in both shorthand and long-form</strong> <strong>formats</strong>.<strong> </strong>We'll take a look at both, starting with shorthand.</p><h2 id=\"graphql-shorthand-queries\">GraphQL Shorthand Queries</h2><p>Shorthand queries are an excellent place to start for beginners like us just trying to get some data out of our database.</p><p>The structure of such a query looks like this:</p><!--kg-card-begin: code--><pre><code>{\n  [model_name]s {\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}</code></pre><!--kg-card-end: code--><p>Using our example, our <strong>model_name</strong> in this case would be <strong>jiraissue </strong><em>made plural,</em> resulting in <strong>jiraissues</strong>. This is an important thing to note: when creating models, we should name them as a single entity, as things get confusing very fast otherwise. I initially made the mistake of naming my model <strong>jiraissues</strong>, which would then drive me to query <strong>jiraissueses</strong>. That was a fun little trip.</p><p>Within the brackets of our model, we must explicitly specify which fields (aka database columns) we'd like returned with our query. Here's a full example of a shorthand query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissues {\n    key\n    summary\n    epic_name\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Check out what this results in when entered in our \"playground\":</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-8.50.53-PM.png\" class=\"kg-image\"><figcaption>Query on the left, results on the right.</figcaption></figure><!--kg-card-end: image--><p>Just like that, we have liftoff!</p><h3 id=\"the-where-clause\">The \"Where\" Clause</h3><p>As mentioned earlier, a major point of GraphQL is to return only the data which is necessary. Thus, we should almost always make queries with a <em>where </em>clause. Thus, we can extend our simple query as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissueses(where: {status: &quot;Backlog&quot;}) {\n    key\n    summary\n    epic_name\n    status\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>And here's the result:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-9.21.23-PM.png\" class=\"kg-image\"><figcaption>Filtering results \"where\" certain criteria are met.</figcaption></figure><!--kg-card-end: image--><h3 id=\"adding-to-our-query\">Adding to Our Query</h3><p>Just like SQL or MongoDB queries, we can add more to our query to get more specific:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">{\n  jiraissues(where: {status: &quot;Backlog&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC,  first: 6) \n  {\n    key\n    summary\n    epic_name\n    status\n    updated\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Here, we've expanded our filter to work on <em>two</em> fields: now our query will only return issues which match our criteria for both <code>status</code> and <code>project</code>. </p><p>We've also added a few other things to our query. With <code>orderBy</code>, we can set the order in which records will be returned to us by field, either in ascending (ASC) or descending (DESC) order. <code>first</code> imposes a limit on our results, giving us the first 6 which meet our criteria. Alternatively, <code>last</code> would give us the opposite.</p><p>There are plenty of more parameters we could add here. For example:</p><ul><li><code>[fieldname]_contains</code>: Filters results where the string field contains a substring.</li><li><code>[fieldname]_in</code>: Checks a list to return records where the value of the field matches any substring in a provided list.</li><li><code>[fieldname]_starts_with</code>: An expression to check for values that start with a provided substring.</li><li><code>[fieldname]_ends_with</code>: Similar to the above, only for ending with a substring.</li></ul><p>Not only are there more to add to this list, but each as an accompanying reverse statement which would return the opposite. For example, <code>[fieldname]_not_contains</code> is the opposite of <code>[fieldname]_contains</code>.</p><h2 id=\"graphql-longform-queries\">GraphQL Longform Queries</h2><p>What we've seen so far is already pretty powerful, but we're far from seeing just how far GraphQL can go. </p><p>To demonstrate what a more complicated query is capable of, let's use out Kanban board example. Our board is going to have 4 columns representing 4 statuses: <strong>Backlog, To Do, In Progress, </strong>and <strong>Done.</strong> Check out how we can receive all of this with a single query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">query KanbanJiraIssues {\n  backlog: jiraissues(where: {status: &quot;Backlog&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  todo: jiraissues(where: {status: &quot;To Do&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  inprogress: jiraissues(where: {status: &quot;In Progress&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n  done: jiraissues(where: {status: &quot;Done&quot;, project: &quot;Hackers and Slackers&quot;}, orderBy: updated_DESC, first: 6){\n    key\n    status\n    summary\n    assignee\n    priority\n    issuetype\n    epic_name\n    updated\n    rank\n    timestamp\n    project\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Unlike our shorthand queries, we begin this query with the syntax <code>query [your_query_name]</code>. You can name your query anything you'd like.</p><p>Within that query, we can perform multiple individual queries which we too give display names. In whole, the structure looks like this:\\</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">query [your_query_name] {\n  [subquery_name]: [model_name]s(where: {[your_criteria]}){\n    [desired_field_name_1]\n    [desired_field_name_2]\n    [desired_field_name_3]\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Check out the result:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-06-at-11.22.29-PM.png\" class=\"kg-image\"><figcaption>Now THAT's a query.</figcaption></figure><!--kg-card-end: image--><p>This format has helped us accomplish something previously impossible with REST APIs: we've used a single endpoint to give us <em>exactly</em> the information we need while omitting the information we don't.</p><h2 id=\"passing-variables-into-queries\">Passing Variables Into Queries</h2><p>As you can see, queries can get lengthy pretty quick. It would suck if we had to write the entirety of the query above every time we wanted to hit an API. Luckily, we don't don't have to: that's where GraphQL <em>variables </em>come in.</p><p>Variables allow us to use the structure of a GraphQL query repeatedly, while providing different values where we see fit. That means if we have a particularly complicated query structure that we'd like to repurpose, we can pass dynamic values into said query. This is where things start to get really powerful.</p><p>Let's assume that finding JIRA issues by <em>epic link</em> is a common task we'll have to deal with. This is how we'd pass a dynamic value for <strong>epic_link:</strong></p><!--kg-card-begin: code--><pre><code>query JiraIssuesByEpicName($epic_name: String) {\n  jiraissues(where: {epic_name: $epic_name}) {\n    key\n    summary\n    epic_name\n    status\n    updated\n    project\n    priority\n    issuetype\n    timestamp\n  }\n}</code></pre><!--kg-card-end: code--><p><code>$epic_name</code> is the name of our variable, which we set in the object we pass to the query. That object looks like this:</p><!--kg-card-begin: code--><pre><code>{\n  \"epic_name\": \"SEO\"\n}</code></pre><!--kg-card-end: code--><p>So what we're saying on <strong>line 1</strong> is that we're passing a variable named <code>$epic_name</code>, and that variable will be a <code>String</code>. When <code>$epic_name</code> appears again on <strong>line 2</strong>, the variable is interpreted as its value, which is \"SEO\".</p><p>Luckily, our playground has a place specifically for setting variables which get passed to our queries. Here's how it all looks:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/graphql-variables.png\" class=\"kg-image\"><figcaption>Heavy breathing intensifies.</figcaption></figure><!--kg-card-end: image--><h3 id=\"unlimited-power\">Unlimited Power?</h3><p>While GraphQL's syntax looks clean and simple at first glance, it's easy to see how quickly simple queries evolve into complex behemoths. It's no coincidence that all GraphQL services come with a playground. It's hard to imagine how anybody could internalize GraphQL syntax without trial and error, and we're only getting started.</p><p>So far we've only queried existing data; we haven't even begun to touch on mutations yet. Catch us next time when we start modifying data and get ourselves into a whole lot of trouble.</p>","url":"https://hackersandslackers.com/writing-your-first-graphql-queries/","uuid":"4019e61f-0f68-4921-99d4-5085864f9143","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c806baf199621174e904b03"}},{"node":{"id":"Ghost__Post__5c570ae30b20340296f57709","title":"Easily Build GraphQL APIs with Prisma","slug":"easily-build-graphql-apis-with-prisma","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","excerpt":"Jump on the GraphQL Bandwagon with a little help from Prisma.","custom_excerpt":"Jump on the GraphQL Bandwagon with a little help from Prisma.","created_at_pretty":"03 February, 2019","published_at_pretty":"03 February, 2019","updated_at_pretty":"29 March, 2019","created_at":"2019-02-03T10:38:11.000-05:00","published_at":"2019-02-03T16:33:15.000-05:00","updated_at":"2019-03-29T14:47:01.000-04:00","meta_title":"Build GraphQL APIs with Prisma | Hackers and Slackers","meta_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","og_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","og_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","og_title":"Build GraphQL APIs with Prisma","twitter_description":"Embrace GraphQL by leveraging Prisma: a free service which generates a GraphQL API atop any database.","twitter_image":"https://hackersandslackers.com/content/images/2019/02/prisma2-1.jpg","twitter_title":"Build GraphQL APIs with Prisma","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},"tags":[{"name":"GraphQL","slug":"graphql","description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","feature_image":null,"meta_description":"Ditch REST endpoints and build APIs that make sense with your workflow. Get started with Prisma or Apollo toolkits, and join the GraphQL bandwagon.","meta_title":"Build a GraphQL API | Hackers and Slackers","visibility":"public"},{"name":"SaaS Products","slug":"saas","description":"Third-party products and services we’ve discovered to be diamonds in the rough. These are products we’ve included in our stack based on price and value add.","feature_image":null,"meta_description":"Third-party products and services we’ve discovered to be diamonds in the rough. These are products we’ve included in our stack based on price and value add.","meta_title":"Our Picks: SaaS Products | Hackers and Slackers","visibility":"public"},{"name":"Architecture","slug":"architecture","description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to Lambda functions, Docker containers, Google Cloud functions,  Kubernetes, Heroku, etc.","feature_image":null,"meta_description":"Advancements in software architecture, serverless and beyond. Examples include equivalents to cloud functions, Docker containers, Kubernetes, Heroku, etc.","meta_title":"Software Architecture | Hackers and Slackers","visibility":"public"},{"name":"DevOps","slug":"devops","description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","feature_image":null,"meta_description":"Configuring server-side infrastructure, cloud architecture, and sometimes networking. Even automate your DevOps workflow with products from Hashicorp.","meta_title":"DevOps: Networking And Server Configuration | Hackers and Slackers","visibility":"public"},{"name":"NodeJS","slug":"nodejs","description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","feature_image":null,"meta_description":"All things related to backend JavaScript. Learn frameworks or take our word for selecting the right NPM packages.","meta_title":"NodeJS | Hackers and Slackers","visibility":"public"},{"name":"#GraphQL Hype","slug":"graphql-hype","description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","feature_image":"https://hackersandslackers.com/content/images/2019/03/graphqlseries.jpg","meta_description":"Learn GraphQL syntax and see the reasons why the future of APIs is here to stay. We walk through everything from server/client setup to intricate tricks.","meta_title":"GraphQL Hype","visibility":"internal"}],"plaintext":"The technology sector is reeling after an official statement was released by the\nUN's International Council of Coolness last week. The statement clearly states\nwhat status-quo developers have feared for months: if you haven't shifted from\nREST to GraphQL by now, you are officially recognized by the international\ncommunity to hold \"uncool\" status. A humanitarian crisis is already unfolding as\nrefugees of coolness are threatening to overtake borders, sparking fears of an\ninflux of Thinkpad Laptops, IntelliJ, and other Class A  uncool narcotics.\n\nHold up: is GraphQL That Dramatic of an Improvement over REST?\nIn all honesty, I've found that the only way to properly answer this question is\nto first utter \"kinda,\" then mull back and forth for a little while, and then\nfinishing with a weak statement like \"so pretty much, yeah.\"\n\nLet’s put it this way. When you’re first familiarizing yourself with a set of\ndata, what do you do? Do you read extensive documentation about the SQL table\nyou’re about to check out? Do you read the entire spec for your version\nPostgreSQL to see if it contains the functionality that might be missing for\nsome reason? I’m going to guess you do neither of these- chances are you just\nlook at the data. \n\nUsing any REST API is inherently a context-switch. No matter how many APIs\nyou’ve worked with in the past, you’ll never be able to know a new API’s\nendpoints, quirks, or the awful manner in which the creator has abandoned any\ndistinction between GET, POST, or PUT methods altogether. GraphQL is not\nnecessarily more technologically impressive than REST, but it does  provide us a\nsyntax and workflow comparable to working directly with databases with which\nwe're already familiar.\n\nRemember when us young guys justified replacing older devs when we came out of\nthe gate with NodeJS, arguing that context-switching changes everything? GraphQL\nis just that: a \"better\" technology with less mental context-switching, which\nconveniently serves a double-purpose for enterprises looking to fire anybody\nthey perceive to be dead weight over the age of 30. Good luck finding a better\nsynopsis than that.\n\nWhat’s this Prisma Nonsense? \nPrisma [https://www.prisma.io/]  is a free (FREE!) service that provides with\nthe tools to create an API client, as well as an Admin panel to manage it.\nWithout any prior knowledge of GraphQL needed, Prisma provides us with:\n\n * A CLI which’s stand up a web server which will serve as our API: either cloud\n   or self-hosted.\n * Automatic integration with your database of choice (including cloud DBs, such\n   as RDS).\n * A clever obfuscation of data models via a simple config file. No classes, no\n   code, no bullshit.\n * A \"playground\" interface which allows us to mess around in GraphQL syntax\n   against our models without breaking everything.\n * A web GUI which displays the relationships between all of these things and\n   their usage.\n\nIn short, Prisma does our jobs for us. Now that tasks associated with building\nAPIs, creating ORMs, and managing databases have all been trivialized, we can\nfinally cut some more of that dead weight we mentioned earlier- specifically\nBob, the asshole coming up on his 35th birthday sitting on his high-horse just\nbecause he has an obligation to feed 3 beautiful children. Sorry Bob, it just\nwasn't working out.\n\nPrisma does  provide the option to set up a test environment on their cloud, but\nlet's do something useful with our lives for once and build something\nproduction-ready. In this case, that means standing up a 5-dollar Digital Ocean\nDroplet.\n\nCreate a Prisma Account\nGet over to the sexually appealing Prisma Cloud landing page\n[https://www.prisma.io/cloud]  and make yourself an account. When prompted, make\nsure you select Deploy a new Prisma Service.\n\nExample services are for sissys.You should then be prompted with the following\nscreen. It will instruct you to install an NPM package, but there are a few\nthings we need to do first.\n\nWhen she says \"waiting for login,\" she means \"I'd wait a lifetime for you, my\nlove.\"Installing Prisma Dependencies on a Fresh VPS\nSSH into whichever VPS you've chosen. I'll be using a Ubuntu instance for this\ntutorial. If you happen to be using Ubuntu as well, feel free to copy + paste\nall the stuff I'm sure you've done a million times already. First, we need to\ninstall Node:\n\n$ apt update\n$ apt upgrade -y\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n$ sudo apt-get install -y nodejs\n$ sudo apt-get install gcc g++ make\n$ sudo npm install -g npm@latest\n\n\nBefore you do anything crazy like copy & paste those two lines from Prisma,\nyou're going to need to set up Docker a few steps later, so you might as well do\nthat now: \n\n1. Install Docker Dependencies\n$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n\n\n2. Add Docker Key\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n$ sudo apt-key fingerprint 0EBFCD88\n\n\n3. Get Docker Repository\n$ sudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\n\n4. Finally Install Docker\n$ sudo apt-get update\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\nGood job, you're doing great.\n\nInstall & Activate The Prisma CLI\nCool, now we can carry on with Prisma's demands. Install the Prisma CLI\nglobally, and then use said CLI to log in to Prisma.\n\n$ npm install -g prisma\n$ prisma login -k eyJhbGciGYU78tfuyLALALTHISKEYISFAKELOL69KFGs\n\n\nWait a couple of seconds after entering the login prompt, and you'll notice your\nbrowser window will have changed to indicate that you're now logged in. \n\nThe next step will create the local files which serve as the heart and soul of\nour API. Make sure you init Prisma  in whichever directory you like to keep\nthings in:\n\n$ cd /my/desired/directory/\n$ prisma init my-prisma\n\n\nInitiating the project will kickstart a quick and painless interrogation\nprocess. Keep in mind that it's recommended to use Prisma with a fresh database\ninstance; in my case, I spun up a cloud PostgreSQL instance.\n\n? Set up a new Prisma server or deploy to an existing server? Use existing database\n? What kind of database do you want to deploy to?:\n? Does your database contain existing data?:\n? Enter database host:\n? Enter database port:\n? Enter database user:\n? Enter database password: \n? Enter database name (the database includes the schema):\n? Use SSL?:\n\n\nCompleting this will result in the following structure:\n\nmy-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n\n\nWe're almost there cowboy and/or cowgirl. \n\nSet Phasers to \"Deploy\"\nPrisma is going to stand itself up on port 4466, which is closed by default on\nmost servers. Make sure you have this port open:\n\n$ ufw allow 4466\n\n\nFinally, we need to set a secret  in order to connect to Prisma cloud. Open the \ndocker-compose.yml  file and uncomment the managementApiSecret  line. Replace\nthe value with some sort of deep dark personal secret of yours.\n\n$ vim docker-compose.yml\n\n\nversion: '3'\nservices:\n  prisma:\n    image: prismagraphql/prisma:1.25\n    restart: always\n    ports:\n    - \"4466:4466\"\n    environment:\n      PRISMA_CONFIG: |\n        port: 4466\n        # uncomment the next line and provide the env var \n        managementApiSecret: my-secret\n        databases:\n          default:\n            connector: postgres\n            host: 123.45.678.90\n            database: databasename\n            user: username\n            password: password\n            rawAccess: true\n            port: '5432'\n            migrations: true\n\n\n\nFor some reason, Prisma does not automatically specify your SSL preferences in\ndocker-compose, even if you explicity answer \"yes\" to the SSL prompt. If your\ndatabase requires SSL, be sure to add ssl: true  to the end of your\ndocker-compose config. Otherwise, your deployment will fail.As per the comment\nin our yml  file, we need to export the secret we specify with \nmanagementApiSecret: my-secret  as an environment variable. Back in your Prisma\ndirectory, export your secret as such:\n\n$ export PRISMA_MANAGEMENT_API_SECRET=my-secret\n\n\nThis secret is used to generate a token to secure our endpoint. Skipping this\nstep would result in exposing your database to the world with full read/write\naccess to anybody.\n\nIt's Game Time\nIt's time to deploy, baby! Do it, push the button! DO IT NOW!\n\n$ docker-compose up -d\n$ prisma deploy\n\n\nDeploying for the first time does a few things. It'll stand up a 'playground'\ninterface on your local server (localhost:4466), as well as automatically get\nyou set up with Prisma Cloud, which is essentially an admin interface for your\ndeployment hosted on Prisma's site.\n\nCheck Out Your Workspace \nVisit [Your Server's IP]:4466 to see what you've done:\n\nA playground for children of all agesCheck it out! Along with documentation of\nthe generic data models Prisma shipped with, you can test queries or mutations\non the left side of the UI, and receive responses on the right. Sure beats\nPostman imho.\n\nDon't Look Down: You're in the Cloud\nYou can now add your server to Prisma Cloud to get the benefits of their admin\npanel. From here, you can modify information directly, review usage metrics, and\nmanage multiple instances:\n\nBreaking News: Prisma is Too Cool For School.Working With Prisma And GraphQL\nNow that we've spun up this shiny new toy, let's be sure we know how to drive\nit.\n\nOn your VPS, take a look at the datamodels.prisma  file:\n\n$ vim datamodels.prisma\n\n\nYou should see a data model called User (everybody has this model). To add or\nmodify data models, all we need to do is change the fields as we see fit, set\ntheir data type, and specify whether or not we'd like the field to be unique.\nBelow I've added a couple of new 'fields.'\n\ntype User {\n  id: ID! @unique\n  name: String!\n  email: String! @unique\n  gravatar: String!\n}\n\n\nDeploying Prisma again with these changes will modify our database's table\nstructure to match the new model:\n\n$ prisma deploy\n\n\nThere you have it: one more buzzword to put your resum\u001d\u001de. In fact, feel free to\ncompletely falsify the existence of a GraphQL certification and throw that on\nthere, too. If you're the kind of person who enjoys reading technical posts like\nthis in your free time, chances are you're already qualified for the job. Unless\nyou're Bob.","html":"<p>The technology sector is reeling after an official statement was released by the UN's International Council of Coolness last week. The statement clearly states what status-quo developers have feared for months: if you haven't shifted from REST to GraphQL by now, you are officially recognized by the international community to hold \"uncool\" status. A humanitarian crisis is already unfolding as refugees of coolness are threatening to overtake borders, sparking fears of an influx of Thinkpad Laptops, IntelliJ, and other <em>Class A</em> uncool narcotics.</p><h3 id=\"hold-up-is-graphql-that-dramatic-of-an-improvement-over-rest\">Hold up: is GraphQL That Dramatic of an Improvement over REST?</h3><p>In all honesty, I've found that the only way to properly answer this question is to first utter \"kinda,\" then mull back and forth for a little while, and then finishing with a weak statement like \"so pretty much, yeah.\"</p><p>Let’s put it this way. When you’re first familiarizing yourself with a set of data, what do you do? Do you read extensive documentation about the SQL table you’re about to check out? Do you read the entire spec for your version PostgreSQL to see if it contains the functionality that might be missing for some reason? I’m going to guess you do neither of these- chances are you <em>just look at the data. </em></p><p>Using any REST API is inherently a context-switch. No matter how many APIs you’ve worked with in the past, you’ll never be able to know a new API’s endpoints, quirks, or the awful manner in which the creator has abandoned any distinction between GET, POST, or PUT methods altogether. GraphQL is not necessarily more technologically impressive than REST, but it <em>does</em> provide us a syntax and workflow comparable to working directly with databases with which we're already familiar.</p><p>Remember when us young guys justified replacing older devs when we came out of the gate with NodeJS, arguing that context-switching <em>changes everything</em>? GraphQL is just that: a \"better\" technology with less mental context-switching, which conveniently serves a double-purpose for enterprises looking to fire anybody they perceive to be dead weight over the age of 30. Good luck finding a better synopsis than that.</p><h2 id=\"what-s-this-prisma-nonsense\">What’s this Prisma Nonsense? </h2><p><a href=\"https://www.prisma.io/\">Prisma</a> is a free (FREE!) service that provides with the tools to create an API client, as well as an Admin panel to manage it. Without any prior knowledge of GraphQL needed, Prisma provides us with:</p><ul><li>A CLI which’s stand up a web server which will serve as our API: either cloud or self-hosted.</li><li>Automatic integration with your database of choice (including cloud DBs, such as RDS).</li><li>A clever obfuscation of data models via a simple config file. No classes, no code, no bullshit.</li><li>A \"playground\" interface which allows us to mess around in GraphQL syntax against our models without breaking everything.</li><li>A web GUI which displays the relationships between all of these things and their usage.</li></ul><p>In short, Prisma does our jobs for us. Now that tasks associated with building APIs, creating ORMs, and managing databases have all been trivialized, we can finally cut some more of that dead weight we mentioned earlier- specifically Bob, the asshole coming up on his 35th birthday sitting on his high-horse just because he has an obligation to feed 3 beautiful children. Sorry Bob, it just wasn't working out.</p><p>Prisma <em>does</em> provide the option to set up a test environment on their cloud, but let's do something useful with our lives for once and build something production-ready. In this case, that means standing up a 5-dollar Digital Ocean Droplet.</p><h3 id=\"create-a-prisma-account\">Create a Prisma Account</h3><p>Get over to the sexually appealing <a href=\"https://www.prisma.io/cloud\">Prisma Cloud landing page</a> and make yourself an account. When prompted, make sure you select <strong>Deploy a new Prisma Service</strong>.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prisma-step1.png\" class=\"kg-image\"><figcaption>Example services are for sissys.</figcaption></figure><!--kg-card-end: image--><p>You should then be prompted with the following screen. It will instruct you to install an NPM package, but there are a few things we need to do first.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prisma-step2.png\" class=\"kg-image\"><figcaption>When she says \"waiting for login,\" she means \"I'd wait a lifetime for you, my love.\"</figcaption></figure><!--kg-card-end: image--><h2 id=\"installing-prisma-dependencies-on-a-fresh-vps\">Installing Prisma Dependencies on a Fresh VPS</h2><p>SSH into whichever VPS you've chosen. I'll be using a Ubuntu instance for this tutorial. If you happen to be using Ubuntu as well, feel free to copy + paste all the stuff I'm sure you've done a million times already. First, we need to install Node:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ apt update\n$ apt upgrade -y\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n$ sudo apt-get install -y nodejs\n$ sudo apt-get install gcc g++ make\n$ sudo npm install -g npm@latest\n</code></pre>\n<!--kg-card-end: markdown--><p>Before you do anything crazy like copy &amp; paste those two lines from Prisma, you're going to need to set up Docker a few steps later, so you might as well do that now: </p><h3 id=\"1-install-docker-dependencies\">1. Install Docker Dependencies</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"2-add-docker-key\">2. Add Docker Key</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n$ sudo apt-key fingerprint 0EBFCD88\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"3-get-docker-repository\">3. Get Docker Repository</h3><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"4-finally-install-docker\">4. Finally Install Docker</h3><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ sudo apt-get update\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n</code></pre>\n<!--kg-card-end: markdown--><p>Good job, you're doing great.</p><h2 id=\"install-activate-the-prisma-cli\">Install &amp; Activate The Prisma CLI</h2><p>Cool, now we can carry on with Prisma's demands. Install the Prisma CLI globally, and then use said CLI to log in to Prisma.  </p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ npm install -g prisma\n$ prisma login -k eyJhbGciGYU78tfuyLALALTHISKEYISFAKELOL69KFGs\n</code></pre>\n<!--kg-card-end: markdown--><p>Wait a couple of seconds after entering the login prompt, and you'll notice your browser window will have changed to indicate that you're now logged in. </p><p>The next step will create the local files which serve as the heart and soul of our API. Make sure you init <code>Prisma</code> in whichever directory you like to keep things in:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">$ cd /my/desired/directory/\n$ prisma init my-prisma\n</code></pre>\n<!--kg-card-end: markdown--><p>Initiating the project will kickstart a quick and painless interrogation process. Keep in mind that it's recommended to use Prisma with a fresh database instance; in my case, I spun up a cloud PostgreSQL instance.</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">? Set up a new Prisma server or deploy to an existing server? Use existing database\n? What kind of database do you want to deploy to?:\n? Does your database contain existing data?:\n? Enter database host:\n? Enter database port:\n? Enter database user:\n? Enter database password: \n? Enter database name (the database includes the schema):\n? Use SSL?:\n</code></pre>\n<!--kg-card-end: markdown--><p>Completing this will result in the following structure:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">my-prisma\n├── datamodel.prisma\n├── docker-compose.yml\n├── generated\n│   └── prisma-client\n│       ├── index.ts\n│       └── prisma-schema.ts\n└── prisma.yml\n</code></pre>\n<!--kg-card-end: markdown--><p>We're almost there cowboy and/or cowgirl. </p><h2 id=\"set-phasers-to-deploy\">Set Phasers to \"Deploy\"</h2><p>Prisma is going to stand itself up on port <strong>4466</strong>, which is closed by default on most servers. Make sure you have this port open:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ ufw allow 4466\n</code></pre>\n<!--kg-card-end: markdown--><p>Finally, we need to set a <em>secret</em> in order to connect to Prisma cloud. Open the <code>docker-compose.yml</code> file and uncomment the <code>managementApiSecret</code> line. Replace the value with some sort of deep dark personal secret of yours.</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ vim docker-compose.yml\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">version: '3'\nservices:\n  prisma:\n    image: prismagraphql/prisma:1.25\n    restart: always\n    ports:\n    - &quot;4466:4466&quot;\n    environment:\n      PRISMA_CONFIG: |\n        port: 4466\n        # uncomment the next line and provide the env var \n        managementApiSecret: my-secret\n        databases:\n          default:\n            connector: postgres\n            host: 123.45.678.90\n            database: databasename\n            user: username\n            password: password\n            rawAccess: true\n            port: '5432'\n            migrations: true\n\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: html--><div class=\"proptip\">\nFor some reason, Prisma does not automatically specify your SSL preferences in docker-compose, even if you explicity answer \"yes\" to the SSL prompt. If your database requires SSL, be sure to add <code>ssl: true</code> to the end of your docker-compose config. Otherwise, your deployment will fail. \n</div><!--kg-card-end: html--><p>As per the comment in our <code>yml</code> file, we need to export the secret we specify with <code>managementApiSecret: my-secret</code> as an environment variable. Back in your Prisma directory, export your secret as such:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ export PRISMA_MANAGEMENT_API_SECRET=my-secret\n</code></pre>\n<!--kg-card-end: markdown--><p>This secret is used to generate a token to secure our endpoint. Skipping this step would result in exposing your database to the world with full read/write access to anybody.</p><h2 id=\"it-s-game-time\">It's Game Time</h2><p>It's time to deploy, baby! Do it, push the button! DO IT NOW!</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ docker-compose up -d\n$ prisma deploy\n</code></pre>\n<!--kg-card-end: markdown--><p>Deploying for the first time does a few things. It'll stand up a 'playground' interface on your local server (localhost:4466), as well as automatically get you set up with Prisma Cloud, which is essentially an admin interface for your deployment hosted on Prisma's site.</p><h3 id=\"check-out-your-workspace\">Check Out Your Workspace </h3><p>Visit [Your Server's IP]:4466 to see what you've done:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/playground.png\" class=\"kg-image\"><figcaption>A playground for children of all ages</figcaption></figure><!--kg-card-end: image--><p>Check it out! Along with documentation of the generic data models Prisma shipped with, you can test queries or mutations on the left side of the UI, and receive responses on the right. Sure beats Postman imho.</p><h3 id=\"don-t-look-down-you-re-in-the-cloud\">Don't Look Down: You're in the Cloud</h3><p>You can now add your server to Prisma Cloud to get the benefits of their admin panel. From here, you can modify information directly, review usage metrics, and manage multiple instances:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://res-5.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/prismacloud.gif\" class=\"kg-image\"><figcaption>Breaking News: Prisma is Too Cool For School.</figcaption></figure><!--kg-card-end: image--><h2 id=\"working-with-prisma-and-graphql\">Working With Prisma And GraphQL</h2><p>Now that we've spun up this shiny new toy, let's be sure we know how to drive it.</p><p>On your VPS, take a look at the <code>datamodels.prisma</code> file:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ vim datamodels.prisma\n</code></pre>\n<!--kg-card-end: markdown--><p>You should see a data model called User (everybody has this model). To add or modify data models, all we need to do is change the fields as we see fit, set their data type, and specify whether or not we'd like the field to be unique. Below I've added a couple of new 'fields.'</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">type User {\n  id: ID! @unique\n  name: String!\n  email: String! @unique\n  gravatar: String!\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Deploying Prisma again with these changes will modify our database's table structure to match the new model:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ prisma deploy\n</code></pre>\n<!--kg-card-end: markdown--><p>There you have it: one more buzzword to put your resum\u001d\u001de. In fact, feel free to completely falsify the existence of a GraphQL certification and throw that on there, too. If you're the kind of person who enjoys reading technical posts like this in your free time, chances are you're already qualified for the job. Unless you're Bob.</p>","url":"https://hackersandslackers.com/easily-build-graphql-apis-with-prisma/","uuid":"86286c72-478c-4108-8bef-89ca01caf043","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c570ae30b20340296f57709"}}]}},"pageContext":{"slug":"graphql","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}