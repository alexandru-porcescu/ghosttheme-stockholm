{"data":{"ghostPost":{"id":"Ghost__Post__5c654f34eab17b74dbf2d2c0","title":"Welcome to SQL 4: Aggregate Functions","slug":"welcome-to-sql-4-aggregate-functions","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/welcometosql4.jpg","excerpt":"Become more intimate with your data- use SQL's aggregate functions to explore the traits which make your data unique and beautiful.","custom_excerpt":"Become more intimate with your data- use SQL's aggregate functions to explore the traits which make your data unique and beautiful.","created_at_pretty":"14 February, 2019","published_at_pretty":"14 March, 2019","updated_at_pretty":"17 March, 2019","created_at":"2019-02-14T06:21:24.000-05:00","published_at":"2019-03-14T03:10:00.000-04:00","updated_at":"2019-03-17T17:25:34.000-04:00","meta_title":"Welcome to SQL 4: Aggregate Functions | Hackers and Slackers","meta_description":"Become more intimate with your data- use SQL's aggregate functions to explore the traits which make your data unique and beautiful.","og_description":"Become more intimate with your data- use SQL's aggregate functions to explore the traits which make your data unique and beautiful.","og_image":"https://hackersandslackers.com/content/images/2019/03/welcometosql4.jpg","og_title":"Welcome to SQL 4: Aggregate Functions","twitter_description":"Become more intimate with your data- use SQL's aggregate functions to explore the traits which make your data unique and beautiful.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/welcometosql4.jpg","twitter_title":"Welcome to SQL 4: Aggregate Functions","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},"tags":[{"name":"SQL","slug":"sql","description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","feature_image":"https://res-1.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/sql-tag.jpg","meta_description":"Configure relational databases, brush up on your query language syntax, or find third-party services to interact with your data.","meta_title":"Working with SQL | Hackers and Slackers","visibility":"public"},{"name":"MySQL","slug":"mysql","description":"Database configuration, building queries, and cloud hosting options for MySQL.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/mysqlrevamp_o.jpg","meta_description":"Database configuration, building queries, and cloud hosting options for MySQL.","meta_title":"Working with MySQL | Hackers and Slackers","visibility":"public"},{"name":"PostgreSQL","slug":"postgresql","description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","feature_image":null,"meta_description":"Our preferred relational database of choice which deserves more love. Learn the advantages that PostgreSQL provides over closed-source competitors.","meta_title":"Working with PostgreSQL | Hackers and Slackers","visibility":"public"},{"name":"#Welcome to SQL","slug":"welcome-to-sql","description":"If you feel like you’re late to the data party, we all are. The party has been going strong since the 70s: brush up on SQL syntax the old-fashioned way.","feature_image":"https://hackers.nyc3.cdn.digitaloceanspaces.com/posts/2019/02/welcometosqlseries.jpg","meta_description":"If you feel like you’re late to the data party, we all are. The party has been going strong since the 70s: brush up on SQL syntax the old-fashioned way.","meta_title":"Welcome to SQL","visibility":"internal"}],"plaintext":"Aggregate functions in SQL are super dope. When combining these functions with\nclauses such as GROUP BY  and HAVING, we discover ways to view our data from\ncompletely new perspectives. Instead of looking at the same old endless flat\ntable, we can use these functions to give us entirely new insights; aggregate\nfunctions help us to understand bigger-picture things.  Those things might\ninclude finding outliers in datasets, or simply figuring out which employee with\na family to feed should be terminated, based on some arbitrary metric such as\nsales numbers.\n\nWith the basics of JOINs under our belts, this is when SQL starts feel really,\nreally powerful. Our plain two-dimensional tables suddenly gain this power to be\ncombined, aggregated, folded on to themselves, expand infinitely outward as the\nuniverse itself, and even transcend into the fourth dimension.*\n\n*Needs citationOur Base Aggregation Functions\nFirst up, let's see what we mean by \"aggregate functions\" anyway. These simple\nfunctions provide us with a way to mathematically quantify what exactly is in\nour database. Aggregate functions are performed on table columns to give us the\nmake-up of said column. On their own, they seem quite simple:\n\n * AVG: The average of a set of values in a column.\n * COUNT: Number of rows a column contains in a specified table or view.\n * MIN: The minimum value in a set of values.\n * MAX: The maximum value in a set of values.\n * SUM: The sum of values.\n\nDISTINCT Aggregations\nA particularly useful way of using aggregate functions on their own is when we'd\nlike to know the number of DISTINCT  values. While aggregate values take all\nrecords into account, using DISTINCT  limits the data returned to specifically\nrefer to unique values. COUNT(column_name)  will return the number of all\nrecords in a column, where COUNT(DISTINCT column_name)  will ignore counting\nrecords where the value in the counted column is repeated.\n\nUsing GROUP BY\nThe GROUP BY  statement is often used with aggregate functions (COUNT, MAX, MIN,\nSUM, AVG) to group the result-set by one or more columns.\n\nTo demonstrate how aggregate functions work moving forward, I'll be using a\nfamiliar database: the database which contains all the content for this very\nblog. Let's look at how we can use aggregate functions to find which authors\nhave been posting most frequently:\n\nSELECT\n  COUNT(title), author_id\nFROM\n  posts\nGROUP BY author_id;\n\n\nAnd the result:\n\nCount\n author_id\n 102\n 1\n 280\n 5c12c3821345c22dced9f591\n 17\n 5c12c3821345c22dced9f592\n 5\n 5c12c3821345c22dced9f593\n 2\n 5c12c3821345c22dced9f594\n 2\n 5c12c3821345c22dced9f595\n Oh look, a real-life data problem to solve! It seems like authors are\nrepresented in Ghost's posts  table simply by their IDs. This isn't very useful.\nLuckily, we've already learned enough about JOINs\n[https://hackersandslackers.com/welcome-to-sql-3-building-relationships-and-combining-data/] \n to know we can fill in the missing information from the users  table!\n\nSELECT\n  COUNT(posts.title),\n  users.name\nFROM\n  posts\nLEFT JOIN users\nON \n  (posts.author_id = users.id)\nGROUP BY users.id\nORDER BY COUNT(posts.title) DESC;\n\n\nLet's see the results this time around:\n\nCount\n author_id\n 280\n Matthew Alhonte\n 102\n Todd Birchard\n 17\n Max Mileaf\n 5\n Ryan Rosado\n 2\n Graham Beckley\n 2\n David Aquino\n Now that's more like it! Matt is crushing the game with his Lynx Roundup \nseries, with myself in second place. Max had respectable numbers for a moment\nbut has presumably moved on to other hobbies, such as living his life.\n\nFor the remainder, well, I've got nothing to say other than we're hiring. We\ndon't pay though. In fact, there's probably zero benefits to joining us.\n\nConditional Grouping With \"HAVING\"\nHAVING  is like the WHERE  of aggregations. We can't use WHERE  on aggregate\nvalues, so that's why HAVING  exists. HAVING  can't accept any conditional\nvalue, but instead it must accept a numerical conditional derived from a GROUP\nBY. Perhaps this would be easier to visualize in a query:\n\nSELECT\n  tags.name,\n  COUNT(DISTINCT posts_tags.post_id)\nFROM posts_tags \n  LEFT JOIN tags ON tags.id = posts_tags.tag_id\n  LEFT JOIN posts ON posts.id = posts_tags.post_id\nGROUP BY\n  tags.id\nHAVING \n  COUNT(DISTINCT posts_tags.post_id) > 10\nORDER BY\n  COUNT(DISTINCT posts_tags.post_id)\n  DESC;\n\n\nIn this scenario, we want to see which tags on our blog have the highest number\nof associated posts. The query is very similar to the one we made previously,\nonly this time we have a special guest:\n\nHAVING \n  COUNT(DISTINCT posts_tags.post_id) > 10\n\n\nThis usage of HAVING  only gives us tags which have ten posts or more. This\nshould clean up our report by letting Darwinism takes its course. Here's how it\nworked out:\n\ntag\n Count\n Roundup\n 263\n Python\n 80\n Machine Learning\n 29\n DevOps\n 28\n Data Science\n 28\n Software Development\n 27\n Data Engineering\n 23\n Excel\n 19\n SQL\n 18\n Architecture\n 18\n REST APIs\n 16\n #Adventures in Excel\n 16\n Pandas\n 15\n Flask\n 14\n Data Analysis\n 12\n JavaScript\n 12\n AWS\n 11\n MySQL\n 11\n As expected, Matt's roundup posts take the lead (and if we compare this to\nprevious data, we can see Matt has made a total of 17  non-Lynx posts: meaning\nMax and Matt are officially TIED).\n\nIf we hadn't included our HAVING  statement, this list would be much longer,\nfilled with tags nobody cares about. Thanks to explicit omission, now we don't\nneed to experience the dark depression that comes when confronting those sad\npathetic tags. Out of sight, out of mind.\n\nGet Creative\nAggregate functions aren't just about counting values. Especially in Data\nScience, these functions are critical  to drawing any statistical conclusions\nfrom data. That said, attention spans only last so long, and I'm not a\nscientist. Perhaps that can be your job.","html":"<p>Aggregate functions in SQL are super dope. When combining these functions with clauses such as <code>GROUP BY</code> and <code>HAVING</code>, we discover ways to view our data from completely new perspectives. Instead of looking at the same old endless flat table, we can use these functions to give us entirely new insights; aggregate functions help us to understand bigger-picture things.<em> </em>Those things might include finding outliers in datasets, or simply figuring out which employee with a family to feed should be terminated, based on some arbitrary metric such as sales numbers.</p><p>With the basics of <code>JOIN</code>s under our belts, this is when SQL starts feel really, really powerful. Our plain two-dimensional tables suddenly gain this power to be combined, aggregated, folded on to themselves, expand infinitely outward as the universe itself, and even transcend into the fourth dimension.*</p><!--kg-card-begin: html--><div style=\"color:grey; text-align: right; font-style: italic;\">\n    *Needs citation\n</div><!--kg-card-end: html--><h2 id=\"our-base-aggregation-functions\">Our Base Aggregation Functions</h2><p>First up, let's see what we mean by \"aggregate functions\" anyway. These simple functions provide us with a way to mathematically quantify what exactly is in our database. Aggregate functions are performed on table columns to give us the make-up of said column. On their own, they seem quite simple:</p><ul><li><code>AVG</code>: The average of a set of values in a column.</li><li><code>COUNT</code>: Number of rows a column contains in a specified table or view.</li><li><code>MIN</code>: The minimum value in a set of values.</li><li><code>MAX</code>: The maximum value in a set of values.</li><li><code>SUM</code>: The sum of values.</li></ul><h3 id=\"distinct-aggregations\">DISTINCT Aggregations</h3><p>A particularly useful way of using aggregate functions on their own is when we'd like to know the number of <code>DISTINCT</code> values. While aggregate values take all records into account, using <code>DISTINCT</code> limits the data returned to specifically refer to unique values. <code>COUNT(column_name)</code> will return the number of all records in a column, where <code>COUNT(DISTINCT column_name)</code> will ignore counting records where the value in the counted column is repeated.</p><h2 id=\"using-group-by\">Using GROUP BY</h2><p>The <code>GROUP BY</code> statement is often used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result-set by one or more columns.</p><p>To demonstrate how aggregate functions work moving forward, I'll be using a familiar database: the database which contains all the content for this very blog. Let's look at how we can use aggregate functions to find which authors have been posting most frequently:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">SELECT\n  COUNT(title), author_id\nFROM\n  posts\nGROUP BY author_id;\n</code></pre>\n<!--kg-card-end: markdown--><p>And the result:</p><!--kg-card-begin: html--><div class=\"tableContainer\">\n  <table>\n    <thead>\n      <tr>\n        <th>Count</th>\n        <th>author_id</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>102</td>\n        <td>1</td>\n      </tr>\n      <tr>\n        <td>280</td>\n        <td>5c12c3821345c22dced9f591</td>\n      </tr>\n      <tr>\n        <td>17</td>\n        <td>5c12c3821345c22dced9f592</td>\n      </tr>\n      <tr>\n        <td>5</td>\n        <td>5c12c3821345c22dced9f593</td>\n      </tr>\n      <tr>\n        <td>2</td>\n        <td>5c12c3821345c22dced9f594</td>\n      </tr>\n      <tr>\n        <td>2</td>\n        <td>5c12c3821345c22dced9f595</td>\n      </tr>\n    </tbody>\n  </table>\n</div><!--kg-card-end: html--><p>Oh look, a real-life data problem to solve! It seems like authors are represented in Ghost's <strong><em>posts</em></strong> table simply by their IDs. This isn't very useful. Luckily, we've <a href=\"https://hackersandslackers.com/welcome-to-sql-3-building-relationships-and-combining-data/\">already learned enough about JOINs</a> to know we can fill in the missing information from the <strong><em>users</em></strong> table!</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">SELECT\n  COUNT(posts.title),\n  users.name\nFROM\n  posts\nLEFT JOIN users\nON \n  (posts.author_id = users.id)\nGROUP BY users.id\nORDER BY COUNT(posts.title) DESC;\n</code></pre>\n<!--kg-card-end: markdown--><p>Let's see the results this time around:</p><!--kg-card-begin: html--><div class=\"tableContainer\">\n    <table>\n  <thead>\n    <tr>\n      <th>Count</th>\n      <th>author_id</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>280</td>\n      <td>Matthew Alhonte</td>\n    </tr>\n    <tr>\n      <td>102</td>\n      <td>Todd Birchard</td>\n    </tr>\n    <tr>\n      <td>17</td>\n      <td>Max Mileaf</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>Ryan Rosado</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>Graham Beckley</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>David Aquino</td>\n    </tr>\n  </tbody>\n</table>\n</div><!--kg-card-end: html--><p>Now that's more like it! Matt is crushing the game with his <strong>Lynx Roundup</strong> series, with myself in second place. Max had respectable numbers for a moment but has presumably moved on to other hobbies, such as living his life.</p><p>For the remainder, well, I've got nothing to say other than we're hiring. We don't pay though. In fact, there's probably zero benefits to joining us.</p><h3 id=\"conditional-grouping-with-having\">Conditional Grouping With \"HAVING\"</h3><p><code>HAVING</code> is like the <code>WHERE</code> of aggregations. We can't use <code>WHERE</code> on aggregate values, so that's why <code>HAVING</code> exists. <code>HAVING</code> can't accept any conditional value, but instead it <em>must </em>accept a numerical conditional derived from a <code>GROUP BY</code>. Perhaps this would be easier to visualize in a query:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">SELECT\n  tags.name,\n  COUNT(DISTINCT posts_tags.post_id)\nFROM posts_tags \n  LEFT JOIN tags ON tags.id = posts_tags.tag_id\n  LEFT JOIN posts ON posts.id = posts_tags.post_id\nGROUP BY\n  tags.id\nHAVING \n  COUNT(DISTINCT posts_tags.post_id) &gt; 10\nORDER BY\n  COUNT(DISTINCT posts_tags.post_id)\n  DESC;\n</code></pre>\n<!--kg-card-end: markdown--><p>In this scenario, we want to see which tags on our blog have the highest number of associated posts. The query is very similar to the one we made previously, only this time we have a special guest:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sql\">HAVING \n  COUNT(DISTINCT posts_tags.post_id) &gt; 10\n</code></pre>\n<!--kg-card-end: markdown--><p>This usage of <code>HAVING</code> only gives us tags which have ten posts or more. This should clean up our report by letting Darwinism takes its course. Here's how it worked out:</p><!--kg-card-begin: html--><div class=\"tableContainer\">\n    <table>\n  <thead>\n    <tr>\n      <th>tag</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Roundup</td>\n      <td>263</td>\n    </tr>\n    <tr>\n      <td>Python</td>\n      <td>80</td>\n    </tr>\n    <tr>\n      <td>Machine Learning</td>\n      <td>29</td>\n    </tr>\n    <tr>\n      <td>DevOps</td>\n      <td>28</td>\n    </tr>\n    <tr>\n      <td>Data Science</td>\n      <td>28</td>\n    </tr>\n    <tr>\n      <td>Software Development</td>\n      <td>27</td>\n    </tr>\n    <tr>\n      <td>Data Engineering</td>\n      <td>23</td>\n    </tr>\n    <tr>\n      <td>Excel</td>\n      <td>19</td>\n    </tr>\n    <tr>\n      <td>SQL</td>\n      <td>18</td>\n    </tr>\n    <tr>\n      <td>Architecture</td>\n      <td>18</td>\n    </tr>\n    <tr>\n      <td>REST APIs</td>\n      <td>16</td>\n    </tr>\n    <tr>\n      <td>#Adventures in Excel</td>\n      <td>16</td>\n    </tr>\n    <tr>\n      <td>Pandas</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <td>Flask</td>\n      <td>14</td>\n    </tr>\n    <tr>\n      <td>Data Analysis</td>\n      <td>12</td>\n    </tr>\n    <tr>\n      <td>JavaScript</td>\n      <td>12</td>\n    </tr>\n    <tr>\n      <td>AWS</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <td>MySQL</td>\n      <td>11</td>\n    </tr>\n  </tbody>\n</table>\n</div><!--kg-card-end: html--><p>As expected, Matt's roundup posts take the lead (and if we compare this to previous data, we can see Matt has made a total of <strong>17</strong> non-Lynx posts: meaning Max and Matt are officially TIED).</p><p>If we hadn't included our <code>HAVING</code> statement, this list would be much longer, filled with tags nobody cares about. Thanks to explicit omission, now we don't need to experience the dark depression that comes when confronting those sad pathetic tags. Out of sight, out of mind.</p><h3 id=\"get-creative\">Get Creative</h3><p>Aggregate functions aren't just about counting values. Especially in Data Science, these functions are <em>critical</em> to drawing any statistical conclusions from data. That said, attention spans only last so long, and I'm not a scientist. Perhaps that can be your job.</p>","url":"https://hackersandslackers.com/welcome-to-sql-4-aggregate-functions/","uuid":"f45c0ccc-3efc-4963-a236-a23db74c2e96","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c654f34eab17b74dbf2d2c0"}},"pageContext":{"slug":"welcome-to-sql-4-aggregate-functions"}}