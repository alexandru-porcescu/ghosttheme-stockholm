{"data":{"ghostTag":{"slug":"atlassian","name":"Atlassian","visibility":"public","feature_image":null,"description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies."},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5c95e08ef654036aa06c6a02","title":"Building an ETL Pipeline: From JIRA to SQL","slug":"building-an-etl-pipeline-from-jira-to-postgresql","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-3.jpg","excerpt":"An example data pipeline which extracts data from the JIRA Cloud API and loads it to a SQL database.","custom_excerpt":"An example data pipeline which extracts data from the JIRA Cloud API and loads it to a SQL database.","created_at_pretty":"23 March, 2019","published_at_pretty":"28 March, 2019","updated_at_pretty":"09 April, 2019","created_at":"2019-03-23T03:30:22.000-04:00","published_at":"2019-03-28T04:15:00.000-04:00","updated_at":"2019-04-08T23:34:47.000-04:00","meta_title":"Building an ETL Pipeline: From JIRA to SQL | Hackers and Slackers","meta_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","og_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","og_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-2.jpg","og_title":"Building an ETL Pipeline: From JIRA to SQL","twitter_description":"How to build and structure a data pipeline. This example takes issue data extracted from the JIRA Cloud API, transforms it, and loads it to a SQL database.","twitter_image":"https://hackersandslackers.com/content/images/2019/03/jira-etl-3-1.jpg","twitter_title":"Building an ETL Pipeline: From JIRA to SQL","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Data Engineering","slug":"dataengineering","description":"The systematic collection and transformation of data via the creation of tools and pipelines.","feature_image":null,"meta_description":null,"meta_title":"Data Engineering | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Pandas","slug":"pandas","description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","feature_image":"https://res-3.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/pandasmerge.jpg","meta_description":"Analyze data with the Pandas data analysis library for Python. Start from the basics or see real-life examples of pros using Pandas to solve problems.","meta_title":"Pythons and Pandas | Hackers and Slackers","visibility":"public"},{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"}],"plaintext":"Something we haven't done just yet on this site is walking through the humble\nprocess of creating data pipelines: the art of taking a bunch of data, changing\nsaid data, and putting it somewhere else. It's kind of a weird thing to be into,\nhence why the MoMA has been rejecting my submissions of Github repositories.\nDon't worry; I'll keep at it.\n\nSomething you don't see every day are people sharing their pipelines, which is\nunderstandable. Presumably, the other people who do this kind of stuff do it for\nwork; nobody is happily building stupid pipelines in their free time begging to\nbe open sourced. Except me.\n\nWe've recently revamped our projects [https://hackersandslackers.com/projects/] \npage to include a public-facing Kanban board using GraphQL. To achieve this, we\nneed to extract JIRA data from the JIRA Cloud REST API and place it securely in\nour database.\n\nStructuring our Pipeline\nAn ETL pipeline which is considered 'well-structured' is in the eyes of the\nbeholder. There are a million different ways to pull and mess with data, so\nthere isn't a \"template\" for building these things out. In my case, the\nstructure of my script just so happened to end up as three modules: one for \nextracting, one for loading, and one for transforming. This was unplanned, but\nit's a good sign when our app matches our mindset. Here's the breakdown:\n\njira-database-etl\n├── __main__.py\n├── jira_etl\n│   ├── __init__.py\n│   ├── fetch.py\n│   ├── data.py\n│   └── db.py\n├── LICENSE\n├── MANIFEST.in\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── requirements.txt\n├── setup.cfg\n└── setup.py\n\n\nmain.py  is our application entry point. The logic of our pipeline is stored in\nthree parts under the jira_etl  directory:\n\n * fetch.py  grabs the data from the source (JIRA Cloud's REST API) and handles\n   fetching all JIRA issues.\n * data.py  transforms the data we've fetched and constructs a neat DataFrame\n   containing only the information we're after.\n * db.py  finally loads the data into a SQL database.\n\nDon't look into it too much, but here's our entry point:\n\nfrom jira_etl import fetch\nfrom jira_etl import data\nfrom jira_etl import db\n\n\ndef main():\n    \"\"\"Application Entry Point.\n\n    1. Fetch all desired JIRA issues from an instance's REST API.\n    2. Sanitize the data and add secondary metadata.\n    3. Upload resulting DataFrame to database.\n    \"\"\"\n    jira_issues_json = fetch.FetchJiraIssues.fetch_all_results()\n    jira_issues_df = data.TransformData.construct_dataframe(jira_issues_json)\n    upload_status = db.DatabaseImport.upload_dataframe(jira_issues_df)\n    return upload_status\n\n\nWithout further adieu, let's dig into the logic!\n\nExtracting Our Data\nBefore doing anything, it's essential we become familiar with the data we're\nabout to pull. Firstly, JIRA's REST API returns paginated results which max out\nat 100 results per page. This means we'll have to loop through the pages\nrecursively until all results are loaded.\n\nNext, let's look at an example of a single  JIRA issue JSON object returned by\nthe API:\n\n{\n    \"expand\": \"names,schema\",\n    \"startAt\": 0,\n    \"maxResults\": 1,\n    \"total\": 888,\n    \"issues\": [\n        {\n            \"expand\": \"operations,versionedRepresentations,editmeta,changelog,renderedFields\",\n            \"id\": \"11718\",\n            \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/11718\",\n            \"key\": \"HACK-756\",\n            \"fields\": {\n                \"issuetype\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issuetype/10014\",\n                    \"id\": \"10014\",\n                    \"description\": \"Placeholder item for \\\"holy shit this is going to be a lot of work\\\"\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&avatarId=10311&avatarType=issuetype\",\n                    \"name\": \"Major Functionality\",\n                    \"subtask\": false,\n                    \"avatarId\": 10311\n                },\n                \"customfield_10070\": null,\n                \"customfield_10071\": null,\n                \"customfield_10073\": null,\n                \"customfield_10074\": null,\n                \"customfield_10075\": null,\n                \"project\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/project/10015\",\n                    \"id\": \"10015\",\n                    \"key\": \"HACK\",\n                    \"name\": \"Hackers and Slackers\",\n                    \"projectTypeKey\": \"software\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?pid=10015&avatarId=10535\",\n                        \"24x24\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=small&pid=10015&avatarId=10535\",\n                        \"16x16\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=xsmall&pid=10015&avatarId=10535\",\n                        \"32x32\": \"https://hackersandslackers.atlassian.net/secure/projectavatar?size=medium&pid=10015&avatarId=10535\"\n                    }\n                },\n                \"fixVersions\": [],\n                \"resolution\": null,\n                \"resolutiondate\": null,\n                \"workratio\": -1,\n                \"lastViewed\": \"2019-03-24T02:01:31.355-0400\",\n                \"watches\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/watchers\",\n                    \"watchCount\": 1,\n                    \"isWatching\": true\n                },\n                \"created\": \"2019-02-03T00:47:36.677-0500\",\n                \"customfield_10062\": null,\n                \"customfield_10063\": null,\n                \"customfield_10064\": null,\n                \"customfield_10065\": null,\n                \"customfield_10066\": null,\n                \"priority\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/priority/2\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/images/icons/priorities/high.svg\",\n                    \"name\": \"High\",\n                    \"id\": \"2\"\n                },\n                \"customfield_10067\": null,\n                \"customfield_10068\": null,\n                \"customfield_10069\": [],\n                \"labels\": [],\n                \"versions\": [],\n                \"issuelinks\": [],\n                \"assignee\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"updated\": \"2019-03-24T02:01:30.724-0400\",\n                \"status\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/status/10004\",\n                    \"description\": \"\",\n                    \"iconUrl\": \"https://hackersandslackers.atlassian.net/\",\n                    \"name\": \"To Do\",\n                    \"id\": \"10004\",\n                    \"statusCategory\": {\n                        \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/statuscategory/2\",\n                        \"id\": 2,\n                        \"key\": \"new\",\n                        \"colorName\": \"blue-gray\",\n                        \"name\": \"To Do\"\n                    }\n                },\n                \"components\": [],\n                \"description\": {\n                    \"version\": 1,\n                    \"type\": \"doc\",\n                    \"content\": [\n                        {\n                            \"type\": \"paragraph\",\n                            \"content\": [\n                                {\n                                    \"type\": \"text\",\n                                    \"text\": \"https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/\",\n                                    \"marks\": [\n                                        {\n                                            \"type\": \"link\",\n                                            \"attrs\": {\n                                                \"href\": \"https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/\"\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                },\n                \"customfield_10010\": null,\n                \"customfield_10011\": \"0|i0064j:i\",\n                \"customfield_10012\": null,\n                \"customfield_10013\": null,\n                \"security\": null,\n                \"customfield_10008\": \"HACK-143\",\n                \"customfield_10009\": {\n                    \"hasEpicLinkFieldDependency\": false,\n                    \"showField\": false,\n                    \"nonEditableReason\": {\n                        \"reason\": \"PLUGIN_LICENSE_ERROR\",\n                        \"message\": \"Portfolio for Jira must be licensed for the Parent Link to be available.\"\n                    }\n                },\n                \"summary\": \"Automate newsletter\",\n                \"creator\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"subtasks\": [],\n                \"reporter\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"name\": \"bro\",\n                    \"key\": \"admin\",\n                    \"accountId\": \"557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8\",\n                    \"emailAddress\": \"toddbirchard@gmail.com\",\n                    \"avatarUrls\": {\n                        \"48x48\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue\",\n                        \"24x24\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue\",\n                        \"16x16\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue\",\n                        \"32x32\": \"https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue\"\n                    },\n                    \"displayName\": \"Todd Birchard\",\n                    \"active\": true,\n                    \"timeZone\": \"America/New_York\",\n                    \"accountType\": \"atlassian\"\n                },\n                \"customfield_10000\": \"{}\",\n                \"customfield_10001\": null,\n                \"customfield_10004\": null,\n                \"environment\": null,\n                \"duedate\": null,\n                \"votes\": {\n                    \"self\": \"https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/votes\",\n                    \"votes\": 0,\n                    \"hasVoted\": false\n                }\n            }\n        }\n    ]\n}\n\n\nWhoa, mama! That's a ton of BS for a single issue. You can see now why we'd want\nto transform this data before importing ten million fields into any database.\nMake note of these important fields:\n\n * startAt: An integer which tells us which issue number the paginated results\n   start at.\n * maxResults: Denotes the maximum number of results page - maxes out at 100\n   issues.\n * total: The total number of issues across all pages.\n * issues: A list of objects which contain the information for exactly one JIRA\n   issue per object\n\nGreat. So the purpose of fetch.py will essentially consist of creating a list of\nall 888  issues (in my case), and passing that off for transformation. Check it\nthe source I came up with:\n\nimport os\nimport math\nimport requests\n\n\nclass FetchJiraIssues:\n    \"\"\"Fetch all public-facing issues from JIRA instance.\n\n    1. Retrieve all values from env vars.\n    2. Construct request against JIRA REST API.\n    3. Fetch paginated issues via recursion.\n    4. Pass final JSON to be transformed into a DataFrame.\n     \"\"\"\n    results_per_page = 100\n    username = os.environ.get('JIRA_USERNAME')\n    password = os.environ.get('JIRA_PASSWORD')\n    endpoint = os.environ.get('JIRA_ENDPOINT')\n    jql = os.environ.get('JIRA_QUERY')\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    @classmethod\n    def get_total_number_of_issues(cls):\n        \"\"\"Gets the total number of results.\"\"\"\n        params = {\n            \"jql\": cls.jql,\n            \"maxResults\": 0,\n            \"startAt\": 0\n        }\n        req = requests.get(cls.endpoint,\n                           headers=cls.headers,\n                           params=params,\n                           auth=(cls.username, cls.password)\n                           )\n        response = req.json()\n        try:\n            total_results = response['total']\n            return total_results\n        except KeyError:\n            print('Could not find any issues!')\n\n    @classmethod\n    def fetch_all_results(cls):\n        \"\"\"Recursively retrieve all pages of JIRA issues.\"\"\"\n        total_results = cls.get_total_number_of_issues()\n        issue_arr = []\n\n        def fetch_single_page():\n            \"\"\"Fetch one page of results, and determine if another page exists.\"\"\"\n            params = {\n                \"jql\": cls.jql,\n                \"maxResults\": cls.results_per_page,\n                \"startAt\": len(issue_arr)\n            }\n            req = requests.get(cls.endpoint,\n                               headers=cls.headers,\n                               params=params,\n                               auth=(cls.username, cls.password)\n                               )\n            response = req.json()\n            issues = response['issues']\n            issues_so_far = len(issue_arr) + cls.results_per_page\n            print(issues_so_far, ' out of', total_results)\n            issue_arr.extend(issues)\n            # Check if additional pages of results exist.\n        count = math.ceil(total_results/cls.results_per_page)\n        for x in range(0, count):\n            fetch_single_page()\n        return issue_arr\n\n\nYep, I'm using classes. This class has two methods:\n\n * get_total_number_of_issues: All this does is essentially pull the number of\n   issues (888) from the REST API. We'll use this number in our next function to\n   check if additional pages exist.\n * fetch_all_results: This is where things start getting fun. fetch_all_results \n   is a @classmethod  which contains a function within itself. fetch_all_results \n    gets the total number of JIRA issues and then calls upon child function \n   fetch_single_page to pull JIRA issue JSON objects and dump them into a list\n   called issue_arr  until all issues are accounted for.\n\nBecause we have 888 issues and can retrieve 100 issues  at a time, our function\nfetch_single_page  should run 9 times. And it does!\n\nTransforming Our Data\nSo now we have a list of 888 messy JIRA issues. The scope of data.py  should be\nto pull out only the data we want, and make sure that data is clean:\n\nimport os\nimport json\nfrom pandas.io.json import json_normalize\nfrom datetime import datetime\n\n\nclass TransformData:\n    \"\"\"Build JIRA issue DataFrame.\n\n    1. Loop through JIRA issues and create a dictionary of desired data.\n    2. Convert each issue dictionary into a JSON object.\n    3. Load all issues into a Pandas DataFrame.\n    \"\"\"\n\n    issue_count = 0\n\n    @classmethod\n    def construct_dataframe(cls, issue_list_chunk):\n        \"\"\"Make DataFrame out of data received from JIRA API.\"\"\"\n        issue_list = [cls.make_issue_body(issue) for issue in issue_list_chunk]\n        issue_json_list = [cls.dict_to_json_string(issue) for issue in issue_list]\n        jira_issues_df = json_normalize(issue_json_list)\n        return jira_issues_df\n\n    @staticmethod\n    def dict_to_json_string(issue_dict):\n        \"\"\"Convert dict to JSON to string.\"\"\"\n        issue_json_string = json.dumps(issue_dict)\n        issue_json = json.loads(issue_json_string)\n        return issue_json\n\n    @classmethod\n    def make_issue_body(cls, issue):\n        \"\"\"Create a JSON body for each ticket.\"\"\"\n        updated_date = datetime.strptime(issue['fields']['updated'], \"%Y-%m-%dT%H:%M:%S.%f%z\")\n        body = {\n            'id': str(cls.issue_count),\n            'key': str(issue['key']),\n            'assignee_name': str(issue['fields']['assignee']['displayName']),\n            'assignee_url': str(issue['fields']['assignee']['avatarUrls']['48x48']),\n            'summary': str(issue['fields']['summary']),\n            'status': str(issue['fields']['status']['name']),\n            'priority_url': str(issue['fields']['priority']['iconUrl']),\n            'priority_rank': int(issue['fields']['priority']['id']),\n            'issuetype_name': str(issue['fields']['issuetype']['name']),\n            'issuetype_icon': str(issue['fields']['issuetype']['iconUrl']),\n            'epic_link': str(issue['fields']['customfield_10008']),\n            'project': str(issue['fields']['project']['name']),\n            'updated': int(datetime.timestamp(updated_date)),\n            'updatedAt': str(updated_date)\n        }\n        cls.issue_count += 1\n        return body\n\n\nAgain, let's see the methods at work:\n\n * construct_dataframe: The main function we invoke to build our DataFrame\n   (mostly just calls other methods). Once all transformations are completed,\n   creates a DataFrame called jira_df  by using the Pandas json_normalize() \n   method.\n * make_issue_body: Creates a new dictionary per singular JIRA issue. Extracts \n   only  the fields we want to be imported into our database. Converts each\n   field into either a string or an int as a lazy way of avoiding null values\n   (for example, if issue['fields']['priority']['name']  contained a null value,\n   the script would error out. Wrapping this in str() is a dirty way of\n   converting null  to an empty string).\n * dict_to_json_string  Takes each issue dictionary and converts it to a JSON\n   object, which is then turned into a string (this is done for Pandas).\n\nLoading Our Data\nAnd now for the final step! Thanks to the joyful marriage of Pandas and\nSQLAlchemy, turning DataFrames into SQL tables is super simple. We never make\nthings simple, though.\n\nimport os\nimport logging\nfrom sqlalchemy import create_engine, text, MetaData\nfrom sqlalchemy.types import Integer, Text, TIMESTAMP, String\nimport pandas as pd\n\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n\n\nclass DatabaseImport:\n    \"\"\"Merge Epic metadata and upload JIRA issues.\n\n    1. Merge Epic metadata by fetching an existing table.\n    2. Explicitly set data types for all columns found in jira_issues_df.\n    2. Create a new table from the final jira_issues_df.\n    \"\"\"\n\n    URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    db_epic_table = os.environ.get('SQLALCHEMY_EPIC_TABLE')\n    db_jira_table = os.environ.get('SQLALCHEMY_JIRA_TABLE')\n    db_schema = os.environ.get('SQLALCHEMY_DB_SCHEMA')\n\n    # Create Engine\n    meta = MetaData(schema=\"hackers$prod\")\n    engine = create_engine(URI, echo=True)\n\n    @staticmethod\n    def truncate_table(engine):\n        \"\"\"Clear table of data.\"\"\"\n        sql = text('TRUNCATE TABLE \"hackers$prod\".\"JiraIssue\"')\n        engine.execute(sql)\n\n    @classmethod\n    def merge_epic_metadata(cls, jira_issues_df):\n        \"\"\"Merge epic metadata from existing SQL table.\"\"\"\n        cls.truncate_table(cls.engine)\n        epics_df = pd.read_sql_table(cls.db_epic_table,\n                                     cls.engine,\n                                     schema=cls.db_schema)\n        jira_issues_df = pd.merge(jira_issues_df,\n                                  epics_df[['epic_link', 'epic_name', 'epic_color']],\n                                  how='left',\n                                  on='epic_link',\n                                  copy=False)\n        return jira_issues_df\n\n    @classmethod\n    def upload_dataframe(cls, jira_issues_df):\n        \"\"\"Upload JIRA DataFrame to PostgreSQL database.\"\"\"\n        jira_issues_df = cls.merge_epic_metadata(jira_issues_df)\n        jira_issues_df.to_sql(cls.db_jira_table,\n                              cls.engine,\n                              if_exists='append',\n                              schema=cls.db_schema,\n                              index=False,\n                              dtype={\"assignee\": String(30),\n                                     \"assignee_url\": Text,\n                                     \"epic_link\": String(50),\n                                     \"issuetype_name\": String(50),\n                                     \"issuetype_icon\": Text,\n                                     \"key\": String(10),\n                                     \"priority_name\": String(30),\n                                     \"priority_rank\": Integer,\n                                     \"priority_url\": Text,\n                                     \"project\": String(50),\n                                     \"status\": String(30),\n                                     \"summary\": Text,\n                                     \"updated\": Integer,\n                                     \"updatedAt\": TIMESTAMP,\n                                     \"createdAt\": TIMESTAMP,\n                                     \"epic_color\": String(20),\n                                     \"epic_name\": String(50)\n                                     })\n        success_message = 'Successfully uploaded' \\\n                          + str(len(jira_issues_df.index)) \\\n                          + ' rows to ' + cls.db_jira_table\n        return success_message\n\n\n * merge_epic_metadata: Due to the nature of the JIRA REST API, some metadata is\n   missing per issue. If you're interested, the data missing revolves around \n   Epics: JIRA's REST API does not include the Epic Name  or Epic Color  fields\n   of linked epics.\n * upload_dataframe: Uses Panda's to_sql()  method to upload our DataFrame into\n   a SQL table (our target happens to be PostgreSQL, so we pass schema  here).\n   To make things explicit, we set the data type of every column on upload.\n\nWell, let's see how we made out!\n\nA look at our resulting database table.Whoaaa nelly, we did it! With our data\nclean, we can now build something useful! Here's what I built:\n\nFruits of our labor!There we have it: a pipeline that takes a bunch of messy\ndata, cleans it, and puts it somewhere else for proper use.\n\nIf you're interested in how we created the frontend for our Kanban board, check\nout our series on building features with GraphQL\n[https://hackersandslackers.com/series/graphql-hype/]. For the source code,\ncheck out the Github repository\n[https://github.com/toddbirchard/jira-database-etl].","html":"<p>Something we haven't done just yet on this site is walking through the humble process of creating data pipelines: the art of taking a bunch of data, changing said data, and putting it somewhere else. It's kind of a weird thing to be into, hence why the MoMA has been rejecting my submissions of Github repositories. Don't worry; I'll keep at it.</p><p>Something you don't see every day are people sharing their pipelines, which is understandable. Presumably, the other people who do this kind of stuff do it for work; nobody is happily building stupid pipelines in their free time begging to be open sourced. Except me.</p><p>We've recently revamped our <strong><a href=\"https://hackersandslackers.com/projects/\">projects</a></strong> page to include a public-facing Kanban board using GraphQL. To achieve this, we need to extract JIRA data from the JIRA Cloud REST API and place it securely in our database.</p><h2 id=\"structuring-our-pipeline\">Structuring our Pipeline</h2><p>An ETL pipeline which is considered 'well-structured' is in the eyes of the beholder. There are a million different ways to pull and mess with data, so there isn't a \"template\" for building these things out. In my case, the structure of my script just so happened to end up as three modules: one for <em>extracting</em>, one for <em>loading</em>, and one for <em>transforming</em>. This was unplanned, but it's a good sign when our app matches our mindset. Here's the breakdown:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">jira-database-etl\n├── __main__.py\n├── jira_etl\n│   ├── __init__.py\n│   ├── fetch.py\n│   ├── data.py\n│   └── db.py\n├── LICENSE\n├── MANIFEST.in\n├── Pipfile\n├── Pipfile.lock\n├── README.md\n├── requirements.txt\n├── setup.cfg\n└── setup.py\n</code></pre>\n<!--kg-card-end: markdown--><p><strong>main.py</strong> is our application entry point. The logic of our pipeline is stored in three parts under the <strong>jira_etl</strong> directory:</p><ul><li><strong>fetch.py</strong> grabs the data from the source (JIRA Cloud's REST API) and handles fetching all JIRA issues.</li><li><strong>data.py</strong> transforms the data we've fetched and constructs a neat DataFrame containing only the information we're after.</li><li><strong>db.py</strong> finally loads the data into a SQL database.</li></ul><p>Don't look into it too much, but here's our entry point:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">from jira_etl import fetch\nfrom jira_etl import data\nfrom jira_etl import db\n\n\ndef main():\n    &quot;&quot;&quot;Application Entry Point.\n\n    1. Fetch all desired JIRA issues from an instance's REST API.\n    2. Sanitize the data and add secondary metadata.\n    3. Upload resulting DataFrame to database.\n    &quot;&quot;&quot;\n    jira_issues_json = fetch.FetchJiraIssues.fetch_all_results()\n    jira_issues_df = data.TransformData.construct_dataframe(jira_issues_json)\n    upload_status = db.DatabaseImport.upload_dataframe(jira_issues_df)\n    return upload_status\n</code></pre>\n<!--kg-card-end: markdown--><p>Without further adieu, let's dig into the logic!</p><h2 id=\"extracting-our-data\">Extracting Our Data</h2><p>Before doing anything, it's essential we become familiar with the data we're about to pull. Firstly, JIRA's REST API returns paginated results which max out at 100 results per page. This means we'll have to loop through the pages recursively until all results are loaded.</p><p>Next, let's look at an example of a <strong><em>single</em></strong> JIRA issue JSON object returned by the API:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n    &quot;expand&quot;: &quot;names,schema&quot;,\n    &quot;startAt&quot;: 0,\n    &quot;maxResults&quot;: 1,\n    &quot;total&quot;: 888,\n    &quot;issues&quot;: [\n        {\n            &quot;expand&quot;: &quot;operations,versionedRepresentations,editmeta,changelog,renderedFields&quot;,\n            &quot;id&quot;: &quot;11718&quot;,\n            &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/11718&quot;,\n            &quot;key&quot;: &quot;HACK-756&quot;,\n            &quot;fields&quot;: {\n                &quot;issuetype&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issuetype/10014&quot;,\n                    &quot;id&quot;: &quot;10014&quot;,\n                    &quot;description&quot;: &quot;Placeholder item for \\&quot;holy shit this is going to be a lot of work\\&quot;&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&amp;avatarId=10311&amp;avatarType=issuetype&quot;,\n                    &quot;name&quot;: &quot;Major Functionality&quot;,\n                    &quot;subtask&quot;: false,\n                    &quot;avatarId&quot;: 10311\n                },\n                &quot;customfield_10070&quot;: null,\n                &quot;customfield_10071&quot;: null,\n                &quot;customfield_10073&quot;: null,\n                &quot;customfield_10074&quot;: null,\n                &quot;customfield_10075&quot;: null,\n                &quot;project&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/project/10015&quot;,\n                    &quot;id&quot;: &quot;10015&quot;,\n                    &quot;key&quot;: &quot;HACK&quot;,\n                    &quot;name&quot;: &quot;Hackers and Slackers&quot;,\n                    &quot;projectTypeKey&quot;: &quot;software&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?pid=10015&amp;avatarId=10535&quot;,\n                        &quot;24x24&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=small&amp;pid=10015&amp;avatarId=10535&quot;,\n                        &quot;16x16&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=xsmall&amp;pid=10015&amp;avatarId=10535&quot;,\n                        &quot;32x32&quot;: &quot;https://hackersandslackers.atlassian.net/secure/projectavatar?size=medium&amp;pid=10015&amp;avatarId=10535&quot;\n                    }\n                },\n                &quot;fixVersions&quot;: [],\n                &quot;resolution&quot;: null,\n                &quot;resolutiondate&quot;: null,\n                &quot;workratio&quot;: -1,\n                &quot;lastViewed&quot;: &quot;2019-03-24T02:01:31.355-0400&quot;,\n                &quot;watches&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/watchers&quot;,\n                    &quot;watchCount&quot;: 1,\n                    &quot;isWatching&quot;: true\n                },\n                &quot;created&quot;: &quot;2019-02-03T00:47:36.677-0500&quot;,\n                &quot;customfield_10062&quot;: null,\n                &quot;customfield_10063&quot;: null,\n                &quot;customfield_10064&quot;: null,\n                &quot;customfield_10065&quot;: null,\n                &quot;customfield_10066&quot;: null,\n                &quot;priority&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/priority/2&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/images/icons/priorities/high.svg&quot;,\n                    &quot;name&quot;: &quot;High&quot;,\n                    &quot;id&quot;: &quot;2&quot;\n                },\n                &quot;customfield_10067&quot;: null,\n                &quot;customfield_10068&quot;: null,\n                &quot;customfield_10069&quot;: [],\n                &quot;labels&quot;: [],\n                &quot;versions&quot;: [],\n                &quot;issuelinks&quot;: [],\n                &quot;assignee&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;updated&quot;: &quot;2019-03-24T02:01:30.724-0400&quot;,\n                &quot;status&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/status/10004&quot;,\n                    &quot;description&quot;: &quot;&quot;,\n                    &quot;iconUrl&quot;: &quot;https://hackersandslackers.atlassian.net/&quot;,\n                    &quot;name&quot;: &quot;To Do&quot;,\n                    &quot;id&quot;: &quot;10004&quot;,\n                    &quot;statusCategory&quot;: {\n                        &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/statuscategory/2&quot;,\n                        &quot;id&quot;: 2,\n                        &quot;key&quot;: &quot;new&quot;,\n                        &quot;colorName&quot;: &quot;blue-gray&quot;,\n                        &quot;name&quot;: &quot;To Do&quot;\n                    }\n                },\n                &quot;components&quot;: [],\n                &quot;description&quot;: {\n                    &quot;version&quot;: 1,\n                    &quot;type&quot;: &quot;doc&quot;,\n                    &quot;content&quot;: [\n                        {\n                            &quot;type&quot;: &quot;paragraph&quot;,\n                            &quot;content&quot;: [\n                                {\n                                    &quot;type&quot;: &quot;text&quot;,\n                                    &quot;text&quot;: &quot;https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/&quot;,\n                                    &quot;marks&quot;: [\n                                        {\n                                            &quot;type&quot;: &quot;link&quot;,\n                                            &quot;attrs&quot;: {\n                                                &quot;href&quot;: &quot;https://mailchimp.com/help/share-your-blog-posts-with-mailchimp/&quot;\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                },\n                &quot;customfield_10010&quot;: null,\n                &quot;customfield_10011&quot;: &quot;0|i0064j:i&quot;,\n                &quot;customfield_10012&quot;: null,\n                &quot;customfield_10013&quot;: null,\n                &quot;security&quot;: null,\n                &quot;customfield_10008&quot;: &quot;HACK-143&quot;,\n                &quot;customfield_10009&quot;: {\n                    &quot;hasEpicLinkFieldDependency&quot;: false,\n                    &quot;showField&quot;: false,\n                    &quot;nonEditableReason&quot;: {\n                        &quot;reason&quot;: &quot;PLUGIN_LICENSE_ERROR&quot;,\n                        &quot;message&quot;: &quot;Portfolio for Jira must be licensed for the Parent Link to be available.&quot;\n                    }\n                },\n                &quot;summary&quot;: &quot;Automate newsletter&quot;,\n                &quot;creator&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;subtasks&quot;: [],\n                &quot;reporter&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/user?accountId=557058%3A713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;name&quot;: &quot;bro&quot;,\n                    &quot;key&quot;: &quot;admin&quot;,\n                    &quot;accountId&quot;: &quot;557058:713aac6d-44ef-416d-9a1d-3e524a5c4dc8&quot;,\n                    &quot;emailAddress&quot;: &quot;toddbirchard@gmail.com&quot;,\n                    &quot;avatarUrls&quot;: {\n                        &quot;48x48&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=48&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D48%26noRedirect%3Dtrue&quot;,\n                        &quot;24x24&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=24&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D24%26noRedirect%3Dtrue&quot;,\n                        &quot;16x16&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=16&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D16%26noRedirect%3Dtrue&quot;,\n                        &quot;32x32&quot;: &quot;https://avatar-cdn.atlassian.com/9eb3868db428fb602e03b3059608199b?s=32&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2F9eb3868db428fb602e03b3059608199b%3Fd%3Dmm%26s%3D32%26noRedirect%3Dtrue&quot;\n                    },\n                    &quot;displayName&quot;: &quot;Todd Birchard&quot;,\n                    &quot;active&quot;: true,\n                    &quot;timeZone&quot;: &quot;America/New_York&quot;,\n                    &quot;accountType&quot;: &quot;atlassian&quot;\n                },\n                &quot;customfield_10000&quot;: &quot;{}&quot;,\n                &quot;customfield_10001&quot;: null,\n                &quot;customfield_10004&quot;: null,\n                &quot;environment&quot;: null,\n                &quot;duedate&quot;: null,\n                &quot;votes&quot;: {\n                    &quot;self&quot;: &quot;https://hackersandslackers.atlassian.net/rest/api/3/issue/HACK-756/votes&quot;,\n                    &quot;votes&quot;: 0,\n                    &quot;hasVoted&quot;: false\n                }\n            }\n        }\n    ]\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Whoa, mama! That's a ton of BS for a single issue. You can see now why we'd want to transform this data before importing ten million fields into any database. Make note of these important fields:</p><ul><li><code>startAt</code>: An integer which tells us which issue number the paginated results start at.</li><li><code>maxResults</code>: Denotes the maximum number of results page - maxes out at 100 issues.</li><li><code>total</code>: The total number of issues across all pages.</li><li><code>issues</code>: A list of objects which contain the information for exactly one JIRA issue per object</li></ul><p>Great. So the purpose of <strong>fetch.py </strong>will essentially consist of creating a list of all <strong>888</strong> issues (in my case), and passing that off for transformation. Check it the source I came up with:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport math\nimport requests\n\n\nclass FetchJiraIssues:\n    &quot;&quot;&quot;Fetch all public-facing issues from JIRA instance.\n\n    1. Retrieve all values from env vars.\n    2. Construct request against JIRA REST API.\n    3. Fetch paginated issues via recursion.\n    4. Pass final JSON to be transformed into a DataFrame.\n     &quot;&quot;&quot;\n    results_per_page = 100\n    username = os.environ.get('JIRA_USERNAME')\n    password = os.environ.get('JIRA_PASSWORD')\n    endpoint = os.environ.get('JIRA_ENDPOINT')\n    jql = os.environ.get('JIRA_QUERY')\n    headers = {\n        &quot;Accept&quot;: &quot;application/json&quot;\n    }\n\n    @classmethod\n    def get_total_number_of_issues(cls):\n        &quot;&quot;&quot;Gets the total number of results.&quot;&quot;&quot;\n        params = {\n            &quot;jql&quot;: cls.jql,\n            &quot;maxResults&quot;: 0,\n            &quot;startAt&quot;: 0\n        }\n        req = requests.get(cls.endpoint,\n                           headers=cls.headers,\n                           params=params,\n                           auth=(cls.username, cls.password)\n                           )\n        response = req.json()\n        try:\n            total_results = response['total']\n            return total_results\n        except KeyError:\n            print('Could not find any issues!')\n\n    @classmethod\n    def fetch_all_results(cls):\n        &quot;&quot;&quot;Recursively retrieve all pages of JIRA issues.&quot;&quot;&quot;\n        total_results = cls.get_total_number_of_issues()\n        issue_arr = []\n\n        def fetch_single_page():\n            &quot;&quot;&quot;Fetch one page of results, and determine if another page exists.&quot;&quot;&quot;\n            params = {\n                &quot;jql&quot;: cls.jql,\n                &quot;maxResults&quot;: cls.results_per_page,\n                &quot;startAt&quot;: len(issue_arr)\n            }\n            req = requests.get(cls.endpoint,\n                               headers=cls.headers,\n                               params=params,\n                               auth=(cls.username, cls.password)\n                               )\n            response = req.json()\n            issues = response['issues']\n            issues_so_far = len(issue_arr) + cls.results_per_page\n            print(issues_so_far, ' out of', total_results)\n            issue_arr.extend(issues)\n            # Check if additional pages of results exist.\n        count = math.ceil(total_results/cls.results_per_page)\n        for x in range(0, count):\n            fetch_single_page()\n        return issue_arr\n</code></pre>\n<!--kg-card-end: markdown--><p>Yep, I'm using classes. This class has two methods:</p><ul><li><code>get_total_number_of_issues</code>: All this does is essentially pull the number of issues (888) from the REST API. We'll use this number in our next function to check if additional pages exist.</li><li><code>fetch_all_results</code>: This is where things start getting fun. <strong>fetch_all_results</strong> is a <em>@classmethod</em> which contains a function within itself. <strong>fetch_all_results</strong> gets the total number of JIRA issues and then calls upon child function <strong>fetch_single_page </strong>to pull JIRA issue JSON objects and dump them into a list called <code>issue_arr</code> until all issues are accounted for.</li></ul><p>Because we have <em>888 issues </em>and can retrieve <em>100 issues</em> at a time, our function  <code>fetch_single_page</code> should run <em>9 times</em>. And it does!</p><h2 id=\"transforming-our-data\">Transforming Our Data</h2><p>So now we have a list of 888 messy JIRA issues. The scope of <strong>data.py</strong> should be to pull out only the data we want, and make sure that data is clean:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport json\nfrom pandas.io.json import json_normalize\nfrom datetime import datetime\n\n\nclass TransformData:\n    &quot;&quot;&quot;Build JIRA issue DataFrame.\n\n    1. Loop through JIRA issues and create a dictionary of desired data.\n    2. Convert each issue dictionary into a JSON object.\n    3. Load all issues into a Pandas DataFrame.\n    &quot;&quot;&quot;\n\n    issue_count = 0\n\n    @classmethod\n    def construct_dataframe(cls, issue_list_chunk):\n        &quot;&quot;&quot;Make DataFrame out of data received from JIRA API.&quot;&quot;&quot;\n        issue_list = [cls.make_issue_body(issue) for issue in issue_list_chunk]\n        issue_json_list = [cls.dict_to_json_string(issue) for issue in issue_list]\n        jira_issues_df = json_normalize(issue_json_list)\n        return jira_issues_df\n\n    @staticmethod\n    def dict_to_json_string(issue_dict):\n        &quot;&quot;&quot;Convert dict to JSON to string.&quot;&quot;&quot;\n        issue_json_string = json.dumps(issue_dict)\n        issue_json = json.loads(issue_json_string)\n        return issue_json\n\n    @classmethod\n    def make_issue_body(cls, issue):\n        &quot;&quot;&quot;Create a JSON body for each ticket.&quot;&quot;&quot;\n        updated_date = datetime.strptime(issue['fields']['updated'], &quot;%Y-%m-%dT%H:%M:%S.%f%z&quot;)\n        body = {\n            'id': str(cls.issue_count),\n            'key': str(issue['key']),\n            'assignee_name': str(issue['fields']['assignee']['displayName']),\n            'assignee_url': str(issue['fields']['assignee']['avatarUrls']['48x48']),\n            'summary': str(issue['fields']['summary']),\n            'status': str(issue['fields']['status']['name']),\n            'priority_url': str(issue['fields']['priority']['iconUrl']),\n            'priority_rank': int(issue['fields']['priority']['id']),\n            'issuetype_name': str(issue['fields']['issuetype']['name']),\n            'issuetype_icon': str(issue['fields']['issuetype']['iconUrl']),\n            'epic_link': str(issue['fields']['customfield_10008']),\n            'project': str(issue['fields']['project']['name']),\n            'updated': int(datetime.timestamp(updated_date)),\n            'updatedAt': str(updated_date)\n        }\n        cls.issue_count += 1\n        return body\n</code></pre>\n<!--kg-card-end: markdown--><p>Again, let's see the methods at work:</p><ul><li><code>construct_dataframe</code>: The main function we invoke to build our DataFrame (mostly just calls other methods). Once all transformations are completed, creates a DataFrame called <strong>jira_df</strong> by using the Pandas <em>json_normalize()</em> method.</li><li><code>make_issue_body</code>: Creates a new dictionary per singular JIRA issue. Extracts <em>only</em> the fields we want to be imported into our database. Converts each field into either a string or an int as a lazy way of avoiding null values (for example, if <code>issue['fields']['priority']['name']</code> contained a null value, the script would error out. Wrapping this in <strong>str() </strong>is a dirty way of converting <em>null</em> to an empty string).</li><li><code>dict_to_json_string</code> Takes each issue dictionary and converts it to a JSON object, which is then turned into a string (this is done for Pandas).</li></ul><h2 id=\"loading-our-data\">Loading Our Data</h2><p>And now for the final step! Thanks to the joyful marriage of Pandas and SQLAlchemy, turning DataFrames into SQL tables is super simple. We never make things simple, though.</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\">import os\nimport logging\nfrom sqlalchemy import create_engine, text, MetaData\nfrom sqlalchemy.types import Integer, Text, TIMESTAMP, String\nimport pandas as pd\n\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n\n\nclass DatabaseImport:\n    &quot;&quot;&quot;Merge Epic metadata and upload JIRA issues.\n\n    1. Merge Epic metadata by fetching an existing table.\n    2. Explicitly set data types for all columns found in jira_issues_df.\n    2. Create a new table from the final jira_issues_df.\n    &quot;&quot;&quot;\n\n    URI = os.environ.get('SQLALCHEMY_DATABASE_URI')\n    db_epic_table = os.environ.get('SQLALCHEMY_EPIC_TABLE')\n    db_jira_table = os.environ.get('SQLALCHEMY_JIRA_TABLE')\n    db_schema = os.environ.get('SQLALCHEMY_DB_SCHEMA')\n\n    # Create Engine\n    meta = MetaData(schema=&quot;hackers$prod&quot;)\n    engine = create_engine(URI, echo=True)\n\n    @staticmethod\n    def truncate_table(engine):\n        &quot;&quot;&quot;Clear table of data.&quot;&quot;&quot;\n        sql = text('TRUNCATE TABLE &quot;hackers$prod&quot;.&quot;JiraIssue&quot;')\n        engine.execute(sql)\n\n    @classmethod\n    def merge_epic_metadata(cls, jira_issues_df):\n        &quot;&quot;&quot;Merge epic metadata from existing SQL table.&quot;&quot;&quot;\n        cls.truncate_table(cls.engine)\n        epics_df = pd.read_sql_table(cls.db_epic_table,\n                                     cls.engine,\n                                     schema=cls.db_schema)\n        jira_issues_df = pd.merge(jira_issues_df,\n                                  epics_df[['epic_link', 'epic_name', 'epic_color']],\n                                  how='left',\n                                  on='epic_link',\n                                  copy=False)\n        return jira_issues_df\n\n    @classmethod\n    def upload_dataframe(cls, jira_issues_df):\n        &quot;&quot;&quot;Upload JIRA DataFrame to PostgreSQL database.&quot;&quot;&quot;\n        jira_issues_df = cls.merge_epic_metadata(jira_issues_df)\n        jira_issues_df.to_sql(cls.db_jira_table,\n                              cls.engine,\n                              if_exists='append',\n                              schema=cls.db_schema,\n                              index=False,\n                              dtype={&quot;assignee&quot;: String(30),\n                                     &quot;assignee_url&quot;: Text,\n                                     &quot;epic_link&quot;: String(50),\n                                     &quot;issuetype_name&quot;: String(50),\n                                     &quot;issuetype_icon&quot;: Text,\n                                     &quot;key&quot;: String(10),\n                                     &quot;priority_name&quot;: String(30),\n                                     &quot;priority_rank&quot;: Integer,\n                                     &quot;priority_url&quot;: Text,\n                                     &quot;project&quot;: String(50),\n                                     &quot;status&quot;: String(30),\n                                     &quot;summary&quot;: Text,\n                                     &quot;updated&quot;: Integer,\n                                     &quot;updatedAt&quot;: TIMESTAMP,\n                                     &quot;createdAt&quot;: TIMESTAMP,\n                                     &quot;epic_color&quot;: String(20),\n                                     &quot;epic_name&quot;: String(50)\n                                     })\n        success_message = 'Successfully uploaded' \\\n                          + str(len(jira_issues_df.index)) \\\n                          + ' rows to ' + cls.db_jira_table\n        return success_message\n</code></pre>\n<!--kg-card-end: markdown--><ul><li><code>merge_epic_metadata</code>: Due to the nature of the JIRA REST API, some metadata is missing per issue. If you're interested, the data missing revolves around <strong>Epics</strong>: JIRA's REST API does not include the <em>Epic Name</em> or <em>Epic Color</em> fields of linked epics.</li><li><code>upload_dataframe</code>: Uses Panda's <strong>to_sql()</strong> method to upload our DataFrame into a SQL table (our target happens to be PostgreSQL, so we pass <em>schema</em> here). To make things explicit, we set the data type of every column on upload.</li></ul><p>Well, let's see how we made out!</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-27-at-9.03.51-PM.png\" class=\"kg-image\"><figcaption>A look at our resulting database table.</figcaption></figure><!--kg-card-end: image--><p>Whoaaa nelly, we did it! With our data clean, we can now build something useful! Here's what I built:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/Screen-Shot-2019-03-27-at-9.29.20-PM.png\" class=\"kg-image\"><figcaption>Fruits of our labor!</figcaption></figure><!--kg-card-end: image--><p>There we have it: a pipeline that takes a bunch of messy data, cleans it, and puts it somewhere else for proper use.</p><p>If you're interested in how we created the frontend for our Kanban board, check out our series on <a href=\"https://hackersandslackers.com/series/graphql-hype/\">building features with GraphQL</a>. For the source code, check out the <a href=\"https://github.com/toddbirchard/jira-database-etl\">Github repository</a>.</p>","url":"https://hackersandslackers.com/building-an-etl-pipeline-from-jira-to-postgresql/","uuid":"23647abe-9b47-4f58-8206-cff1fb2ae891","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c95e08ef654036aa06c6a02"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb86736d2","title":"Recreate JIRA Service Desk in Python & Flask","slug":"building-a-better-jira","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","excerpt":"When SaaS doesn't cut it, beat it down and take everything its got.","custom_excerpt":"When SaaS doesn't cut it, beat it down and take everything its got.","created_at_pretty":"11 August, 2018","published_at_pretty":"31 August, 2018","updated_at_pretty":"02 February, 2019","created_at":"2018-08-11T14:02:52.000-04:00","published_at":"2018-08-31T10:25:00.000-04:00","updated_at":"2019-02-02T05:11:05.000-05:00","meta_title":"When SaaS doesn't cut it, beat it down and take everything its got | Hackers And Slackers","meta_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","og_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","og_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","og_title":"Recreate JIRA Service Desk in Python & Flask","twitter_description":"Vanilla helpdesks tend to dehumanize customers. We all think we're special, but a cold support queue reminds us otherwise. We can build something  better.","twitter_image":"https://hackersandslackers.com/content/images/2018/08/jsd@2x.jpg","twitter_title":"Recreate JIRA Service Desk in Python & Flask","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"},{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"Flask","slug":"flask","description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","feature_image":"https://res.cloudinary.com/hackers-and-slackers/image/upload/q_auto:good/v1/images/flaskroutes-2-1_o.jpg","meta_description":"All things Flask ranging from core framework to all conceivable libraries. Tips on how to utilize Flask’s flexibility to create expressive applications.","meta_title":"Building Python Apps in Flask | Hackers and Slackers","visibility":"public"},{"name":"Software Development","slug":"software-development","description":"General software development principals and tools. Receive insights applicable to building any application.","feature_image":null,"meta_description":"General software development principals and tools. Receive insights applicable to building any application.","meta_title":"Software Development | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"}],"plaintext":"When it comes to SaaS products in the realm of Service desks, JIRA Service Desk\nis at the very least, just as powerful as the next solution (Zendesk comes to\nmind). This naturally begs the question: Why is JIRA Service Desk's pricing\nmodel roughly 1/10th of that of it's competitor?\n\nThe answer lies within ease of use,  but more importantly, presentation. While\nAtlassian's cloud offering is slowly playing catchup, Atlassian as a company has\nnever quite seemed to nail down the importance of a friendly user interface, nor\nthe importance of this when it comes to worldwide adoption. To see what I mean,\nhere's an example that Atlassian themselves tout on their own documentation as a\n\"ready for production\" customer portal:\n\nI'm convinced this is purposefully hideous to force the purchase of plugins.To\nyour average software developer (Atlassian's core demographic for years), one\nmight see nothing wrong with this interface, but as somebody `who has rolled out\nover 30 of these desks for over 6 thousand people, layouts such as these commit\nnumerous UI atrocities which simply are not acceptable for top enterprise\nsoftware.\n\nWhat do we do about this? We build an alternative, of course.\n\nMethod to This Madness\nOur focus is not on JIRA as a product,  but rather an API. Instead of attempting\nto work within JIRA’s boundaries via customization or add-ons, we can take\nmatters into our own hands by owning the application that users use to interact\nwith a JIRA instance. By using the JIRA API, we can not only extend features but\nactually ‘rebuild’ the application to gain full control over the UI or\nadditional logic. JIRA is a hideous yet entirely necessary Java application,\nwhich makes it a perfect candidate for recreation.\n\nWe're going to use Flask for this. Shocking, I know. Here's the obligatory file\nstructure of our project:\n\nmyproject\n├─ app.py\n├─ jira.py\n├─ /static\n│  └─ js\n│  └─ less\n│  └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n\n\nThis tutorial will be working against the JIRA Server  API for Service Desk -\nthat said, Cloud users should still find this applicable.\n\nPulling Your Service Desk Form\nBefore we get nuts building our application, we’ll need to be sure that a\nService Desk already exists in JIRA with our expected intake form. Remember: our\nend goal is to simply consume JIRA as an API, but that entails interacting with\nsomething that exists in the first place.\n\nWith your Service Desk created, there’s one annoyance we need to resolve before\ngetting into code: determining your Service Desk’s ID number. Like most things\nin JIRA, Service Desks are identified by an ID which is simply an arbitrary\ngrouping of integers in some way. What is the official way to find this ID, you\nmight ask? Why, by extracting it from the portal’s URL or by inspecting your XHR\nrequests, of course! Remember: JIRA hates you, that’s why we’re doing this in\nthe first place.\n\nWith your Service Desk ID handy, we can finally break into retrieving our desk\nvia the Service Desk API:\n\nimport requests\nfrom jira_config import jira_username, jira_password\n\nrequest_types_endpoint = \"https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/\"\n\nheaders = {'Content-Type': 'application/json'}\n\ndef fieldsPerRequest(id):\n    \"\"\"Get form fields per request type.\"\"\"\n    r = requests.get(request_types_endpoint + id + '/field', auth=(jira_username, jira_password), headers=headers)\n    form = r.json()\n    return form\n\n\ndef serviceDeskRequestTypes():\n    \"\"\"Get request types.\"\"\"\n    request_array = []\n    r = requests.get(request_types_endpoint, auth=(jira_username, jira_password), headers=headers)\n    for requesttype in r.json()['values']:\n        id = requesttype['id']\n        request_dict = {\n            'name': requesttype['name'],\n            'description': requesttype['description'],\n            'icon': requesttype['icon']['_links']['iconUrls']['32x32'],\n            'fields': fieldsPerRequest(id)\n        }\n        request_array.append(request_dict)\n    return request_array\n\n\nserviceDeskRequestTypes()\nBy using the request_types_endpoint  URL, our function serviceDeskRequestTypes() \n returns the request types  of a given JIRA service desk; or in other words, the\n types of requests users can submit.  This alone only gives us high-level\ninformation about the types of requests we allow but doesn't go into further\ndetail such as the actual resulting form. That's where our next function comes\nin.\n\nfieldsPerRequest()\nThis function gets passed the ID of each request type. With that, we extend our\nendpoint to look like \n'https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/[REQUESTID]/field'\n. Looping through each request type gives up exactly what we need: every request\ntype and every form field per request type.\n\nuserSession()\nThere's another thing left to consider: what if the user isn't currently logged\nin to JIRA? At the very least, we need to check to see if a JIRA session is\nactive:\n\nuser_session_endpoint = 'https://jira.we.co/rest/auth/1/session'\n\ndef getUserSession():\n    \"\"\"Get logged-in user.\"\"\"\n    r = requests.get(user_session_endpoint, headers=headers)\n    if r.status_code == 200:\n        return r.json()\n    else:\n        return False\n\n\nIf the user is logged in to JIRA, we'll receive a 200 code letting us know\neverything is alright. The body of the response will also contain the name of\nthe user plus some extra metadata. What if the user isn't  logged in? Let's get\nto that in a bit.\n\nEasy Routing\nOur view will be nice and simple:\n\nfrom jira import request_forms, user_details\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    \"\"\"Landing page.\"\"\"\n    if user_details == False:\n        return redirect('https://example.com')\n    else:\n        return render_template('/index.html', requests=request_forms)\n\n\nNotice that all we're doing is making sure the user is signed in to JIRA. But\nwhat's with the example.com, you ask? Well, because I'm leaving this part up to\nyou, dear friend. There's really a number of things we can do, but it depends\nentirely on your situation. For instance:\n\n * You can handle basic auth on your own\n * Register an OAuth application to handle sign-ins (perhaps the most robust\n   solution)\n * If your JIRA instance is behind SSO, you may want to send users to your\n   company's  SAML partner\n * Simply throw an error message\n\nWhatever you decide to do, it's not really my problem. Obligatory smiley face\nemoji :).\n\nThe Template\nRemember: the main reason most of you are probably doing this is to control the\npresentation layer as you see fit. That said, here comes a call of presentation\nlayer text, in the form of a Jinja template:\n\n{% block form %}\n  <div>\n    <h3 class=\"subtitle\">Submit new requests here</h3>\n    <ul class=\"collapsible\">\n      {% for request in requests %}\n      <li class=\"{{request.name}}\">\n        <div class=\"collapsible-header\">\n          <img src=\"{{request.icon}}\">\n          <div class=\"info\">\n            <h5>{{request.name}}</h5>\n            <p>{{request.description}}</p>\n          </div>\n        </div>\n        <div class=\"collapsible-body\">\n          <div class=\"row\">\n            <form method=\"post\">\n              <div>\n                {% for field in request.fields.requestTypeFields %}\n                  {% if field.name in ('Category', 'Product') %}\n                    <div class=\"input-field\">\n                      <select id=\"{{request.name}} {{field.name}}\">\n                        <option value=\"Choose your option\" disabled selected>Choose your option</option>\n                        {% for option in field.validValues %}\n                          <option value=\"{{option.label}}\">{{option.label}}</option>\n                        {% endfor %}\n                      </select>\n                      <label>{{field.name}}</label>\n                    </div>\n                  {% elif field.name == 'Description' %}\n                    <div class=\"input-field\">\n                      <textarea id=\"{{field.name}}\" class=\"materialize-textarea\" placeholder=\"{{field.description}}\"></textarea>\n                      <label for=\"{{request.name}} {{field.name}}\">{{field.name}}</label>\n                    </div>\n                  {% else %}\n                    <div class=\"input-field\">\n                      <input placeholder=\"{{field.description}}\" id=\"{{request.name}} {{field.name}}\" type=\"text\" class=\"validate\">\n                      <label for=\"{{request.name}} {{field.name}}\">{{field.name}}</label>\n                    </div>\n                  {% endif %}\n                {% endfor %}\n                <input type=\"button\" value=\"Submit\" class=\"btn cyan lighten-3 formsubmit\">\n              </div>\n            </form>\n          </div>\n        </div>\n      </li>\n      {% endfor %}\n    </ul>\n  </div>\n{% endblock %}\n\n\nBecause we passed the Service Desk JSON we extracted from the JIRA API to our\nform, we can go crazy setting our labels, placeholder text, or whatever,\nanywhere we please. In my example, I utilize Material Design\n[https://materializecss.com/]'s pretty package of pre-made frontend elements,\nbecause God knows nobody wants to deal with designing that shit. Sorry, I was\njust having a brief flashback to Frontend dev.\n\nThe code above explicitly looks for fields we know are dropdowns, so that we may\nfill the select options accordingly. Same goes for textarea fields. That said,\nthe way I've handled this above is, well, stupid. Instead of hardcoding if\nstatements to look for certain fields, leverage our JSON to determine the type\nof each field as you iterate over them. Do as I say, not as I do.\n\nGoing Further\nThere's so much more we can add here. Take a list of the user's opened tickets,\nfor instance. The great thing about controlling your own portal UI is that you\ncan now control the narrative of your own workload: perhaps the person in\nmarketing who started 2 weeks ago could benefit from seeing the 200 tickets\nbeing addressed before her, thus second-guessing the urge to type URGENT across\na subject line only to be violently shoved down your throat.\n\nIn all seriousness, nobody likes the experience of a vanilla helpdesk because it\ndehumanizes the customer. While our personal beliefs reassure us that we are\nspecial, entering a cold support queue is a stark suggestion that we may not be\nso special after all, which isn't exactly a fact Millennials or Executives like\nto ponder on. If nothing else, take this as a chance to build software friendly\ntowards humans with full transparency, and both parties will surely benefit.\nRemember: happy humans bides times for the inevitable robot revolution on the\nhorizon destined to eradicate mankind. Do your part!","html":"<p>When it comes to SaaS products in the realm of Service desks, JIRA Service Desk is at the very <em>least</em>, just as powerful as the next solution (Zendesk comes to mind). This naturally begs the question: Why is JIRA Service Desk's pricing model roughly 1/10th of that of it's competitor?</p><p>The answer lies within <em>ease of use,</em> but more importantly, <em>presentation</em>. While Atlassian's cloud offering is slowly playing catchup, Atlassian as a company has never quite seemed to nail down the importance of a friendly user interface, nor the importance of this when it comes to worldwide adoption. To see what I mean, here's an example that Atlassian themselves tout on their own documentation as a \"ready for production\" customer portal:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://res-2.cloudinary.com/hackers-and-slackers/image/upload/f_auto,q_auto/v1/images/customer-portal.png\" class=\"kg-image\"><figcaption>I'm convinced this is purposefully hideous to force the purchase of plugins.</figcaption></figure><p>To your average software developer (Atlassian's core demographic for years), one might see nothing wrong with this interface, but as somebody `who has rolled out over 30 of these desks for over 6 thousand people, layouts such as these commit numerous UI atrocities which simply are not acceptable for top enterprise software.</p><p>What do we do about this? We build an alternative, of course.</p><h2 id=\"method-to-this-madness\">Method to This Madness</h2><p>Our focus is not on JIRA as a <em>product,</em> but rather an <em>API. </em>Instead of attempting to work within JIRA’s boundaries via customization or add-ons, we can take matters into our own hands by owning the application that users use to interact with a JIRA instance. By using the JIRA API, we can not only extend features but actually ‘rebuild’ the application to gain full control over the UI or additional logic. JIRA is a hideous yet entirely necessary Java application, which makes it a perfect candidate for recreation.</p><p>We're going to use Flask for this. Shocking, I know. Here's the obligatory file structure of our project:</p><pre><code class=\"language-bash\">myproject\n├─ app.py\n├─ jira.py\n├─ /static\n│  └─ js\n│  └─ less\n│  └─ img\n└─ /templates\n   └─ layout.html\n   └─ index.html\n</code></pre>\n<p>This tutorial will be working against the JIRA <em>Server</em> API for Service Desk - that said, Cloud users should still find this applicable.</p><h2 id=\"pulling-your-service-desk-form\">Pulling Your Service Desk Form</h2><p>Before we get nuts building our application, we’ll need to be sure that a Service Desk already exists in JIRA with our expected intake form. Remember: our end goal is to simply consume JIRA as an API, but that entails interacting with something that exists in the first place.</p><p>With your Service Desk created, there’s one annoyance we need to resolve before getting into code: determining your Service Desk’s ID number. Like most things in JIRA, Service Desks are identified by an ID which is simply an arbitrary grouping of integers in some way. What is the official way to find this ID, you might ask? Why, by extracting it from the portal’s URL or by inspecting your XHR requests, of course! Remember: JIRA hates you, that’s why we’re doing this in the first place.</p><p>With your Service Desk ID handy, we can finally break into retrieving our desk via the Service Desk API:</p><pre><code class=\"language-python\">import requests\nfrom jira_config import jira_username, jira_password\n\nrequest_types_endpoint = &quot;https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/&quot;\n\nheaders = {'Content-Type': 'application/json'}\n\ndef fieldsPerRequest(id):\n    &quot;&quot;&quot;Get form fields per request type.&quot;&quot;&quot;\n    r = requests.get(request_types_endpoint + id + '/field', auth=(jira_username, jira_password), headers=headers)\n    form = r.json()\n    return form\n\n\ndef serviceDeskRequestTypes():\n    &quot;&quot;&quot;Get request types.&quot;&quot;&quot;\n    request_array = []\n    r = requests.get(request_types_endpoint, auth=(jira_username, jira_password), headers=headers)\n    for requesttype in r.json()['values']:\n        id = requesttype['id']\n        request_dict = {\n            'name': requesttype['name'],\n            'description': requesttype['description'],\n            'icon': requesttype['icon']['_links']['iconUrls']['32x32'],\n            'fields': fieldsPerRequest(id)\n        }\n        request_array.append(request_dict)\n    return request_array\n</code></pre>\n<h3 id=\"servicedeskrequesttypes-\">serviceDeskRequestTypes()</h3><p>By using the <em>request_types_endpoint</em> URL, our function <code>serviceDeskRequestTypes()</code> returns the <strong>request types</strong> of a given JIRA service desk; or in other words, the <em>types of requests users can submit.</em> This alone only gives us high-level information about the types of requests we allow but doesn't go into further detail such as the actual resulting form. That's where our next function comes in.</p><h3 id=\"fieldsperrequest-\">fieldsPerRequest()</h3><p>This function gets passed the ID of each request type. With that, we extend our endpoint to look like <code>'https://yourjirainstance.com/rest/servicedeskapi/servicedesk/[SERVICEDESKID]/requesttype/[REQUESTID]/field'</code>. Looping through each request type gives up exactly what we need: every request type and every form field per request type.</p><h3 id=\"usersession-\">userSession()</h3><p>There's another thing left to consider: what if the user isn't currently logged in to JIRA? At the very least, we need to check to see if a JIRA session is active:</p><pre><code class=\"language-python\">user_session_endpoint = 'https://jira.we.co/rest/auth/1/session'\n\ndef getUserSession():\n    &quot;&quot;&quot;Get logged-in user.&quot;&quot;&quot;\n    r = requests.get(user_session_endpoint, headers=headers)\n    if r.status_code == 200:\n        return r.json()\n    else:\n        return False\n</code></pre>\n<p>If the user is logged in to JIRA, we'll receive a 200 code letting us know everything is alright. The body of the response will also contain the name of the user plus some extra metadata. What if the user <em>isn't</em> logged in? Let's get to that in a bit.</p><h2 id=\"easy-routing\">Easy Routing</h2><p>Our view will be nice and simple:</p><pre><code class=\"language-python\">from jira import request_forms, user_details\n\n@app.route('/', methods=['GET', 'POST', 'OPTIONS'])\ndef home():\n    &quot;&quot;&quot;Landing page.&quot;&quot;&quot;\n    if user_details == False:\n        return redirect('https://example.com')\n    else:\n        return render_template('/index.html', requests=request_forms)\n</code></pre>\n<p>Notice that all we're doing is making sure the user is signed in to JIRA. But what's with the <em>example.com</em>, you ask? Well, because I'm leaving this part up to you, dear friend. There's really a number of things we can do, but it depends entirely on your situation. For instance:</p><ul><li>You can handle basic auth on your own</li><li>Register an OAuth application to handle sign-ins (perhaps the most robust solution)</li><li>If your JIRA instance is behind SSO, you may want to send users to your company's  SAML partner</li><li>Simply throw an error message</li></ul><p>Whatever you decide to do, it's not really my problem. Obligatory smiley face emoji :).</p><h2 id=\"the-template\">The Template</h2><p>Remember: the main reason most of you are probably doing this is to control the presentation layer as you see fit. That said, here comes a call of presentation layer text, in the form of a Jinja template:</p><pre><code class=\"language-jinja\">{% block form %}\n  &lt;div&gt;\n    &lt;h3 class=&quot;subtitle&quot;&gt;Submit new requests here&lt;/h3&gt;\n    &lt;ul class=&quot;collapsible&quot;&gt;\n      {% for request in requests %}\n      &lt;li class=&quot;{{request.name}}&quot;&gt;\n        &lt;div class=&quot;collapsible-header&quot;&gt;\n          &lt;img src=&quot;{{request.icon}}&quot;&gt;\n          &lt;div class=&quot;info&quot;&gt;\n            &lt;h5&gt;{{request.name}}&lt;/h5&gt;\n            &lt;p&gt;{{request.description}}&lt;/p&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;collapsible-body&quot;&gt;\n          &lt;div class=&quot;row&quot;&gt;\n            &lt;form method=&quot;post&quot;&gt;\n              &lt;div&gt;\n                {% for field in request.fields.requestTypeFields %}\n                  {% if field.name in ('Category', 'Product') %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;select id=&quot;{{request.name}} {{field.name}}&quot;&gt;\n                        &lt;option value=&quot;Choose your option&quot; disabled selected&gt;Choose your option&lt;/option&gt;\n                        {% for option in field.validValues %}\n                          &lt;option value=&quot;{{option.label}}&quot;&gt;{{option.label}}&lt;/option&gt;\n                        {% endfor %}\n                      &lt;/select&gt;\n                      &lt;label&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% elif field.name == 'Description' %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;textarea id=&quot;{{field.name}}&quot; class=&quot;materialize-textarea&quot; placeholder=&quot;{{field.description}}&quot;&gt;&lt;/textarea&gt;\n                      &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% else %}\n                    &lt;div class=&quot;input-field&quot;&gt;\n                      &lt;input placeholder=&quot;{{field.description}}&quot; id=&quot;{{request.name}} {{field.name}}&quot; type=&quot;text&quot; class=&quot;validate&quot;&gt;\n                      &lt;label for=&quot;{{request.name}} {{field.name}}&quot;&gt;{{field.name}}&lt;/label&gt;\n                    &lt;/div&gt;\n                  {% endif %}\n                {% endfor %}\n                &lt;input type=&quot;button&quot; value=&quot;Submit&quot; class=&quot;btn cyan lighten-3 formsubmit&quot;&gt;\n              &lt;/div&gt;\n            &lt;/form&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n{% endblock %}\n</code></pre>\n<p>Because we passed the Service Desk JSON we extracted from the JIRA API to our form, we can go crazy setting our labels, placeholder text, or whatever, anywhere we please. In my example, I utilize <a href=\"https://materializecss.com/\">Material Design</a>'s pretty package of pre-made frontend elements, because God knows nobody wants to deal with designing that shit. Sorry, I was just having a brief flashback to Frontend dev.</p><p>The code above explicitly looks for fields we know are dropdowns, so that we may fill the select options accordingly. Same goes for textarea fields. That said, the way I've handled this above is, well, stupid. Instead of hardcoding if statements to look for certain fields, leverage our JSON to determine the type of each field as you iterate over them. Do as I say, not as I do.</p><h2 id=\"going-further\">Going Further</h2><p>There's so much more we can add here. Take a list of the user's opened tickets, for instance. The great thing about controlling your own portal UI is that you can now control the narrative of your own workload: perhaps the person in marketing who started 2 weeks ago could benefit from seeing the 200 tickets being addressed before her, thus second-guessing the urge to type <strong>URGENT </strong>across a subject line only to be violently shoved down your throat.</p><p>In all seriousness, nobody likes the experience of a vanilla helpdesk because it dehumanizes the customer. While our personal beliefs reassure us that we are special, entering a cold support queue is a stark suggestion that we may not be so special after all, which isn't exactly a fact Millennials or Executives like to ponder on. If nothing else, take this as a chance to build software friendly towards humans with full transparency, and both parties will surely benefit. Remember: happy humans bides times for the inevitable robot revolution on the horizon destined to eradicate mankind. Do your part!</p>","url":"https://hackersandslackers.com/building-a-better-jira/","uuid":"789d1406-0dbf-432e-aaa0-32d10f7d6337","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5b6f24cc0cd9b8583e46ab5b"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb867365d","title":"JIRA Analysis in Tableau","slug":"jira-analysis-in-tableau","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/05/tableau3@2x.jpg","excerpt":"Utilizing Tableau Desktop to visualize data pulled from JIRA.","custom_excerpt":"Utilizing Tableau Desktop to visualize data pulled from JIRA.","created_at_pretty":"27 May, 2018","published_at_pretty":"27 May, 2018","updated_at_pretty":"28 March, 2019","created_at":"2018-05-27T13:16:31.000-04:00","published_at":"2018-05-27T17:38:37.000-04:00","updated_at":"2019-03-28T05:50:40.000-04:00","meta_title":"JIRA Analysis in Tableau | Hackers and Slackers","meta_description":"Utilizing Tableau Desktop to visualize data pulled from JIRA","og_description":"Utilizing Tableau Desktop to visualize data pulled from JIRA","og_image":"https://hackersandslackers.com/content/images/2018/05/tableau3@2x.jpg","og_title":"JIRA Analysis in Tableau","twitter_description":"Utilizing Tableau Desktop to visualize data pulled from JIRA","twitter_image":"https://hackersandslackers.com/content/images/2018/05/tableau3@2x.jpg","twitter_title":"JIRA Analysis in Tableau","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Tableau","slug":"tableau","description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","feature_image":null,"meta_description":"Dissect Tableau server and implement hacks to improve your workflow, or simply become familiar with the Tableau desktop user interface.","meta_title":"Tableau Desktop & Server | Hackers and Slackers","visibility":"public"},{"name":"BI","slug":"business-intelligence","description":"Business Intelligence, otherwise known as \"making nice reports for executives to ignore.\"","feature_image":null,"meta_description":null,"meta_title":"Business Intelligence Tools | Hackers and Slackers","visibility":"public"},{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"}],"plaintext":"Greetings to all my feathered friends upon this fine Memorial Day weekend.\nSeeing as how you're here, it appears as though we have a lot in common. Namely,\nwe've chosen to spend our three-day weekends on the internet, as opposed to\noutside.\n\nI've been meaning to build a  widget for this very blog for quite some time now.\nThe vision is to embed a custom Kanban board, which would pull issues from our\nprivate JIRA instance to be publicly displayed and formatted to our liking. To\nmy knowledge, nobody has bothered to attempt building something like this yet;\nprobably for good reason. There are a few gotchas off the bat: for one, JIRA\ncloud's REST API has introduced a \"bug\" which disallows cross-domain calls.\nFine.\n\nMy frustration with propriety software has come down to this: we're going to use\ntwo highly-protected closed source behemoth products against one another. Here's\nthe plan:\n\n * Pull JIRA issues into Tableau\n * Format the data in a worksheet\n * Output our data to a MongoDB database\n * Build a Kanban widget to display these issues\n * Hack the shit out of both JIRA and Tableau to make this process automated\n\nIf this seems like a convoluted way of achieving a small goal, it absolutely is\n- the goal is just as much to become familiar with these systems as is the end\nprize. There's a lot going on here, so for part 1 let's do a dry run of getting\nour issues from JIRA to MongoDB.\n\nThe Extraction\nPulling all issues from JIRA would normally be a simple API call, but in the\nspirit of learning new things we'll try out JIRA's Tableau connector\n[https://marketplace.atlassian.com/apps/1214641/all-in-one-tableau-connector-for-jira]\n. This essentially enables an endpoint specifically for Tableau to pull JIRA\ndata from. After installing the JIRA add-on, we'll be able to produce a URL for\nTableau to consume via the Web Data Connector source:\n\nThe connector allows us to select the data we're looking to pull from JIRA\nupfront. Keep our scope in mind: we're looking to simply display a \"card\" (think\nTrello for all you noobs out there) per issue, so we're only concerned with the\ninformation we'd need to build that. I've boiled this down to:\n\n * Key\n * Issue Type\n * Summary\n * Description\n * Status\n * Creator\n * Priority\n * Epic link\n * Epic Name\n * Epic Color\n\nThe field selection screen when setting up our connector.Work That Sheet\nWith our data imported, create a new worksheet. If you've used Tableau before\nyou're probably very aware of the default column limit on Worksheets. Before we\ndo anything, go to Analysis  > Table Layout  > Advanced  to increase the max\ncolumns from 6 to whatever, let's say 12.\n\nWARING: super sick advanced Tableau hacks incoming.Drag your data into the\n\"rows\" shelf to get something like this:\n\nOur first look at the data.There are a few problems here we need to clean up.\nFirst, take a look at the \"Epic Color\" column.\n\nEyes as Blue as ghx-label-7\nFor some reason, JIRA finds it appropriate to label its colors this cryptic\n code of ghx-label-#. Go ahead and add this to the long list of shitty decisions\nAtlassian has chosen to pursue.\n\nKeeping our goal in mind, we need \"epic colors\" to add some style and flavor to\nour board. Could we make the board without this? Probably, if you're a quitter.\nI'm going to save you some time here. I went ahead and inspected the epic\nelements in my JIRA instance to extract their hex values. Create a new\ncalculated field and add this query to manually map the label nonsense to actual\nvalues:\n\nIF [Epic Colour] = \"ghx-label-1\"\nTHEN \"#42526E\"\nELSEIF [Epic Colour] = \"ghx-label-2\"\nTHEN \"#FFC400\"\nELSEIF [Epic Colour] = \"ghx-label-3\"\nTHEN \"#FFE380\"\nELSEIF [Epic Colour] = \"ghx-label-4\"\nTHEN \"#4C9AFF\"\nELSEIF [Epic Colour] = \"ghx-label-5\"\nTHEN \"#00C7E6\"\nELSEIF [Epic Colour] = \"ghx-label-6\"\nTHEN \"#79F2C0\"\nELSEIF [Epic Colour] = \"ghx-label-7\"\nTHEN \"#C0B6F2\"\nELSEIF [Epic Colour] = \"ghx-label-8\"\nTHEN \"#998DD9\"\nELSEIF [Epic Colour] = \"ghx-label-9\"\nTHEN \"#FFBDAD\"\nELSEIF [Epic Colour] = \"ghx-label-10\"\nTHEN \"#B3D4FF\"\nELSEIF [Epic Colour] = \"ghx-label-11\"\nTHEN \"#79E2F2\"\nELSEIF [Epic Colour] = \"ghx-label-12\"\nTHEN \"#EBECF0\"\nELSEIF [Epic Colour] = \"ghx-label-13\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-14\"\nTHEN \"#FF8F73\"\nELSEIF [Epic Colour] = \"ghx-label-15\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-16\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-17\"\nTHEN \"#57D9A3\"\nEND\n\nReplace the \"Epic Color\" field with this new calculated field to reveal our next\nproblem.\n\nEpic Lynx\nIf you check out our sheet now, we'll see the proper colors values come through,\nbut they will only be appearing for what seems to be one issue per \"Epic\" in our\nsheet:\n\nFeel free to moan and groan a bit while we realize what's happening. We're\nlooking at a list of issues  here, where epics  are themselves to be considered\nan issue. Therefore, only issues which are epics will have colors: issues which\nare linked  to said epics, however, will not. This is annoying. It took me a bit\nto come up with the following solution, although I'd be curious to hear if\nanybody has a better way of doing this.\n\nGo ahead and create a new worksheet. Add Epic Link  and Epic Color  to the\nsheet, and filter out the null values:\n\nCreating a table to perform a SQL-like JOINSo here's the game plan. Stay with me\non this one: we're going to use this sheet as a new source to perform a join \nwith our original data. Once we join on Epic Link, every issue containing an\nepic link will have the parent color as a field as well.\n\nExport this data as a CSV. Go back to Data Sources, open a new data source, and\nselect the CSV we just created. Create an inner merge and associate by epic\nlink:\n\nCreating JOINs via a UI!Now we're getting somewhere. Go back to the original\nsheet and drag the color field from the new data source on to the shelf:\n\nThe result.Pro move. Calculated.\n\nMondo Bongo\nYou'll notice I switched the order of our rows around to have \"Issue key\" as the\nfirst column. Originally I made the mistake of not doing this, only to realize\nthat Tableau will not export merged cells into a CSV. We need to order our\ncolumns starting with the most unique first to avoid any cell merging.\n\nExport that bad boy.\n\nThis is where we'll import our data into MongoDB. How dope is MongoDB, you ask?\nWell, one feature is the ability to import a CSV into an empty database to\nautomatically create the resulting schema and populate it with your values.\nYeah, it's that sick.\n\nI won't turn this into a MongoDB tutorial. Setting up a MongoDB Atlas cluster is\nsomewhat straightforward, and we can use the MongoDB Compass  client to simply\nimport the CSV we created.\n\nWhat Next?\nAs mentioned, our first take at this is going to be a dry run of building this\nwidget with our initial data import. We'll be building this widget in an\nExpressJS app, so next we'll focus on how to connect our app to MongoDB and\nextract this data.\n\nAfter that, we'll need to find a way to automate this process moving forward.\nFull disclosure: Tableau most definitely will not play nice with this, and I'm\niffy on how possible this is. All I know is I've got a Tableau Server instance\nup and running, and I paid good money for it. Therefore, it is my right to break\nit.\n\nI hope at least one or two people have found this to be helpful or interesting\nthus far. Again, I realize this process is a completely roundabout way of\naccomplishing this task... this is mostly a way for us to learn the ins-and-outs\nof these systems. Perhaps we might even build something special. Just think: if\nwe manage to close the loop on this system, we can leverage a GUI to create apps\nnearly as fast as we can imagine them.","html":"<p>Greetings to all my feathered friends upon this fine Memorial Day weekend. Seeing as how you're here, it appears as though we have a lot in common. Namely, we've chosen to spend our three-day weekends on the internet, as opposed to outside.</p><p>I've been meaning to build a  widget for this very blog for quite some time now. The vision is to embed a custom Kanban board, which would pull issues from our private JIRA instance to be publicly displayed and formatted to our liking. To my knowledge, nobody has bothered to attempt building something like this yet; probably for good reason. There are a few gotchas off the bat: for one, JIRA cloud's REST API has introduced a \"bug\" which disallows cross-domain calls. Fine.</p><p>My frustration with propriety software has come down to this: we're going to use two highly-protected closed source behemoth products against one another. Here's the plan:</p><ul><li>Pull JIRA issues into Tableau</li><li>Format the data in a worksheet</li><li>Output our data to a MongoDB database</li><li>Build a Kanban widget to display these issues</li><li>Hack the shit out of both JIRA and Tableau to make this process automated</li></ul><p>If this seems like a convoluted way of achieving a small goal, it absolutely is - the goal is just as much to become familiar with these systems as is the end prize. There's a lot going on here, so for part 1 let's do a dry run of getting our issues from JIRA to MongoDB.</p><h2 id=\"the-extraction\">The Extraction</h2><p>Pulling all issues from JIRA would normally be a simple API call, but in the spirit of learning new things we'll try out <a href=\"https://marketplace.atlassian.com/apps/1214641/all-in-one-tableau-connector-for-jira\">JIRA's Tableau connector</a>. This essentially enables an endpoint specifically for Tableau to pull JIRA data from. After installing the JIRA add-on, we'll be able to produce a URL for Tableau to consume via the Web Data Connector source:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-13.42.11.png\" class=\"kg-image\" alt=\"Connector\"></figure><!--kg-card-end: image--><p>The connector allows us to select the data we're looking to pull from JIRA upfront. Keep our scope in mind: we're looking to simply display a \"card\" (think Trello for all you noobs out there) per issue, so we're only concerned with the information we'd need to build that. I've boiled this down to:</p><ul><li>Key</li><li>Issue Type</li><li>Summary</li><li>Description</li><li>Status</li><li>Creator</li><li>Priority</li><li>Epic link</li><li>Epic Name</li><li>Epic Color</li></ul><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-13.52.24.png\" class=\"kg-image\" alt=\"Fields\"><figcaption>The field selection screen when setting up our connector.</figcaption></figure><!--kg-card-end: image--><h2 id=\"work-that-sheet\">Work That Sheet</h2><p>With our data imported, create a new worksheet. If you've used Tableau before you're probably very aware of the default column limit on Worksheets. Before we do anything, go to <strong>Analysis</strong> &gt; <strong>Table Layout</strong> &gt; <strong>Advanced</strong> to increase the max columns from 6 to whatever, let's say 12.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.02.46.png\" class=\"kg-image\" alt=\"Increase columns\"><figcaption>WARING: super sick advanced Tableau hacks incoming.</figcaption></figure><!--kg-card-end: image--><p>Drag your data into the \"rows\" shelf to get something like this:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2019/03/tableausheet.png\" class=\"kg-image\"><figcaption>Our first look at the data.</figcaption></figure><!--kg-card-end: image--><p>There are a few problems here we need to clean up. First, take a look at the \"Epic Color\" column.</p><h3 id=\"eyes-as-blue-as-ghx-label-7\">Eyes as Blue as ghx-label-7</h3><p>For some reason, JIRA finds it appropriate to label its colors this cryptic  code of <em>ghx-label-#</em>. Go ahead and add this to the long list of shitty decisions Atlassian has chosen to pursue.</p><p>Keeping our goal in mind, we need \"epic colors\" to add some style and flavor to our board. Could we make the board without this? Probably, if you're a quitter. I'm going to save you some time here. I went ahead and inspected the epic elements in my JIRA instance to extract their hex values. Create a new calculated field and add this query to manually map the label nonsense to actual values:</p><!--kg-card-begin: code--><pre><code>IF [Epic Colour] = \"ghx-label-1\"\nTHEN \"#42526E\"\nELSEIF [Epic Colour] = \"ghx-label-2\"\nTHEN \"#FFC400\"\nELSEIF [Epic Colour] = \"ghx-label-3\"\nTHEN \"#FFE380\"\nELSEIF [Epic Colour] = \"ghx-label-4\"\nTHEN \"#4C9AFF\"\nELSEIF [Epic Colour] = \"ghx-label-5\"\nTHEN \"#00C7E6\"\nELSEIF [Epic Colour] = \"ghx-label-6\"\nTHEN \"#79F2C0\"\nELSEIF [Epic Colour] = \"ghx-label-7\"\nTHEN \"#C0B6F2\"\nELSEIF [Epic Colour] = \"ghx-label-8\"\nTHEN \"#998DD9\"\nELSEIF [Epic Colour] = \"ghx-label-9\"\nTHEN \"#FFBDAD\"\nELSEIF [Epic Colour] = \"ghx-label-10\"\nTHEN \"#B3D4FF\"\nELSEIF [Epic Colour] = \"ghx-label-11\"\nTHEN \"#79E2F2\"\nELSEIF [Epic Colour] = \"ghx-label-12\"\nTHEN \"#EBECF0\"\nELSEIF [Epic Colour] = \"ghx-label-13\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-14\"\nTHEN \"#FF8F73\"\nELSEIF [Epic Colour] = \"ghx-label-15\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-16\"\nTHEN \"#57D9A3\"\nELSEIF [Epic Colour] = \"ghx-label-17\"\nTHEN \"#57D9A3\"\nEND</code></pre><!--kg-card-end: code--><p>Replace the \"Epic Color\" field with this new calculated field to reveal our next problem.</p><h3 id=\"epic-lynx\">Epic Lynx</h3><p>If you check out our sheet now, we'll see the proper colors values come through, but they will only be appearing for what seems to be one issue per \"Epic\" in our sheet:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.18.05.png\" class=\"kg-image\" alt=\"Epic Colors\"></figure><!--kg-card-end: image--><p>Feel free to moan and groan a bit while we realize what's happening. We're looking at a list of <em>issues</em> here, where <em>epics</em> are themselves to be considered an issue. Therefore, only issues which are epics will have colors: issues which are <em>linked</em> to said epics, however, will not. This is annoying. It took me a bit to come up with the following solution, although I'd be curious to hear if anybody has a better way of doing this.</p><p>Go ahead and create a new worksheet. Add <strong>Epic Link</strong> and <strong>Epic Color</strong> to the sheet, and filter out the null values:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.26.24.png\" class=\"kg-image\" alt=\"Epic Color Sheet\"><figcaption>Creating a table to perform a SQL-like JOIN</figcaption></figure><!--kg-card-end: image--><p>So here's the game plan. Stay with me on this one: we're going to use this sheet as a new source to perform a <strong>join</strong> with our original data. Once we join on <strong>Epic Link</strong>, every issue containing an epic link will have the parent color as a field as well.</p><p>Export this data as a CSV. Go back to Data Sources, open a new data source, and select the CSV we just created. Create an inner merge and associate by epic link:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.31.36.png\" class=\"kg-image\" alt=\"Merge Inner\"><figcaption>Creating JOINs via a UI!</figcaption></figure><!--kg-card-end: image--><p>Now we're getting somewhere. Go back to the original sheet and drag the color field from the new data source on to the shelf:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.33.27.png\" class=\"kg-image\" alt=\"Issues with colors\"><figcaption>The result.</figcaption></figure><!--kg-card-end: image--><p>Pro move. Calculated.</p><h2 id=\"mondo-bongo\">Mondo Bongo</h2><p>You'll notice I switched the order of our rows around to have \"Issue key\" as the first column. Originally I made the mistake of not doing this, only to realize that Tableau will not export merged cells into a CSV. We need to order our columns starting with the most unique first to avoid any cell merging.</p><p>Export that bad boy.</p><p>This is where we'll import our data into MongoDB. How dope is MongoDB, you ask? Well, one feature is the ability to import a CSV into an empty database to automatically create the resulting schema and populate it with your values. Yeah, it's that sick.</p><p>I won't turn this into a MongoDB tutorial. Setting up a MongoDB Atlas cluster is somewhat straightforward, and we can use the <strong>MongoDB Compass</strong> client to simply import the CSV we created.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://hackersandslackers.com/content/images/2018/05/Screenshot-2018-05-27-16.40.19.png\" class=\"kg-image\" alt=\"MongoDB\"></figure><!--kg-card-end: image--><h2 id=\"what-next\">What Next?</h2><p>As mentioned, our first take at this is going to be a dry run of building this widget with our initial data import. We'll be building this widget in an ExpressJS app, so next we'll focus on how to connect our app to MongoDB and extract this data.</p><p>After that, we'll need to find a way to automate this process moving forward. Full disclosure: Tableau most definitely will not play nice with this, and I'm iffy on how possible this is. All I know is I've got a Tableau Server instance up and running, and I paid good money for it. Therefore, it is my right to break it.</p><p>I hope at least one or two people have found this to be helpful or interesting thus far. Again, I realize this process is a completely roundabout way of accomplishing this task... this is mostly a way for us to learn the ins-and-outs of these systems. Perhaps we might even build something special. Just think: if we manage to close the loop on this system, we can leverage a GUI to create apps nearly as fast as we can imagine them.</p>","url":"https://hackersandslackers.com/jira-analysis-in-tableau/","uuid":"e3aebe6d-5ae2-4fca-97f5-b805c77cad60","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5b0ae7ef057ed3587f8621b3"}},{"node":{"id":"Ghost__Post__5c12d7bfe875ad7bb867364b","title":"Python's Requests Library: Bring Your Scripts to the Web","slug":"pythons-requests-library","featured":false,"feature_image":"https://hackersandslackers.com/content/images/2018/05/snek@2x.jpg","excerpt":"Get familiar with what might become your most used Python library.","custom_excerpt":"Get familiar with what might become your most used Python library.","created_at_pretty":"01 May, 2018","published_at_pretty":"02 May, 2018","updated_at_pretty":"25 November, 2018","created_at":"2018-05-01T18:38:59.000-04:00","published_at":"2018-05-01T20:10:32.000-04:00","updated_at":"2018-11-25T09:55:28.000-05:00","meta_title":"Python's Requests Library | Hackers and Slackers","meta_description":"Get familiar with what might become your most used Python library","og_description":"APIs like a snake","og_image":"https://hackersandslackers.com/content/images/2018/05/snek@2x.jpg","og_title":"Python's Requests Library","twitter_description":"APIs like a snake","twitter_image":"https://hackersandslackers.com/content/images/2018/05/snek@2x.jpg","twitter_title":"Python's Requests Library","authors":[{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"}],"primary_author":{"name":"Todd Birchard","slug":"todd","bio":"Product manager turned engineer with an ongoing identity crisis. Breaks everything before learning best practices. Completely normal and emotionally stable.","profile_image":"https://hackersandslackers.com/content/images/2019/03/todd3.jpg","twitter":"@ToddRBirchard","facebook":null,"website":"https://toddbirchard.com"},"primary_tag":{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},"tags":[{"name":"Python","slug":"python","description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold.","feature_image":null,"meta_description":"Let us feed your endless Python addiction! Regardless of where you stand as a Pythonista, our team of pros are constantly teaching and sharing pythonic gold","meta_title":"Python Tricks, Hacks, and Snippets | Hackers and Slackers","visibility":"public"},{"name":"REST APIs","slug":"restapis","description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","feature_image":null,"meta_description":"Get the most out of REST APIs by example, or build your own. Discover new APIs and how to interact with them, regardless of proffered programming language.","meta_title":"Consuming and Building REST APIs | Hackers and Slackers","visibility":"public"},{"name":"Atlassian","slug":"atlassian","description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","feature_image":null,"meta_description":"Beef up JIRA and Confluence by scripting and automating nearly anything. Empower teams with customized workflows and philosophies.","meta_title":"Atlassian Development for JIRA and Confluence. | Hackers and Slackers","visibility":"public"}],"plaintext":"Last episode [https://hackersandslackers.com/making-ajax-calls-with-jquery/]  we\ncovered every programming noob's favorite 'A-ha' moment: making GET requests\nusing AJAX. Stepping stones such as these can serve as great turning points in a\ncareer, but they also expose how little we still know. For instance, when we\nintegrated the functional logic of APIs on the client side, we actually broke a\ncardinal rule: storing and passing private keys on the client side like an\nidiot. Does that make everything we learned useless? Not entirely, but kinda\nyeah.\n\nToday we'll do the equivalent in Python by using the requests  library. Requests\nis successor to Urllib, both of which are simple tools to retrieve or modify\ninformation on the web, most commonly in the case of APIs.\n\nWe'll be using JIRA's API as an example of how to format GET and POST requests.\nJIRA's API in particular is an excellent example of a powerful and useful API.\nThere's a ton we can do, thus a perfect demonstration of how much power one\nlibrary can give you.\n\nBatteries Not Included\nEven I sometimes forget that requests is not a built-in Python library. Make\nsure requests  is installed in your environment via pip install requests.\n\nCreate a file in your directory called creds.py  to store your credentials. Make\nsure to add that file to your .gitignore  if you plan on committing anything any\ntime soon.\n\n# creds.py\nusername = fake.user\npassword = securepassword123\n\n\nThe only libraries we need to import are requests  and json. Make sure you\nimport your credentials from the file you created earlier.\n\nimport requests\nimport json\nfrom creds import username, password\n\n\nGET Requests\nAs long as you have a URL, you can make a GET request. The requests library will\nreturn the content of any page it hits; if you make a request to an HTML page,\nyour response will be that page's HTML source.\n\nWhen we know what sort of data we're expecting to receive back, we can specify\nthe expected content type  by passing the headers  argument, and specifying the \nContent-Type. Authentication is handled via passing arguments as well,\nspecifically the auth  argument. Take a look at what you can pass in a GET\nrequest:\n\nCommon GET Arguments\n * url:  The URL we will either retrieve or pass the information along to.\n * parameters  (optional):  Depending on the API, some URLs can accept a\n   dictionary of variables to be passed along with the URL. These are called\n   query strings; you notice these all the time whenever you come across a URL\n   that looks like nonsense... that nonsense is information!\n * headers  (optional): A collection of metadata sent along with the request.\n   Our browsers send HTTP headers every time we visit a site, but the scope of\n   what a header value might cover ranges from tokens to content types.\n * auth  (optional):  Method for logging in if needed. Basic/Digest/Custom HTTP\n   Auth.\n\nLet’s GET Some\nWe're going to make a relatively simple request to pull open tickets from a JIRA\nproject called EXM.\n\nThis request will:\n\n * Accept our destination's base URL\n * Append 'search/' (the endpoint for searching issues)\n * Pass two parameters:  A query to return issues A flag to show the issue\n   history\n * Authenticate with our username/password\n * Print the result\n\nimport requests\nimport json\nfrom creds import username\nfrom creds import password\n\nbase_url = 'https://examplejira.com/rest/api/2/'\nheaders = {'Content-Type': 'application/json'}\nparams = {\n    'jql': 'project = EXM AND resolution is not EMPTY',\n    'expand': 'changelog',\n}\n\nreq = requests.get(base_url + 'search/', headers=headers, params=params, auth=(username, password))\n\nprint(req.content)\n\n\nNotice that setting a variable equal to the request will equal the result of\nthat request. Printing r  alone would return a numerical status code (200, 404,\netc). The response that comes back from request such as r  are actually complex\nobjects — printing r.json()  will display the contents of the response as a JSON\nobject. Alternatively, r.text  returns the raw response as a string.\n\nIf your response comes back with an error, remember that you can always debug\nyour requests via Postman [https://www.getpostman.com/].\n\nIf all went well with our request, r.json()  should return something similar to\nthe following:\n\n{  \n   \"expand\":\"schema,names\",\n   \"startAt\":0,\n   \"maxResults\":50,\n   \"total\":63,\n   \"issues\":[  \n      {  \n         \"expand\":\"operations,versionedRepresentations,editmeta,changelog,renderedFields\",\n         \"id\":\"10558\",\n         \"self\":\"https://hackersandslackers.atlassian.net/rest/api/2/issue/10558\",\n         \"key\":\"HSB-63\",\n         \"fields\":{  \n            \"issuetype\":{  \n               \"self\":\"https://hackersandslackers.atlassian.net/rest/api/2/issuetype/10007\",\n               \"id\":\"10007\",\n               \"description\":\"Non-development related content task\",\n               \"iconUrl\":\"https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&avatarId=10306&avatarType=issuetype\",\n               \"name\":\"Content\",\n               \"subtask\":false,\n               \"avatarId\":10306\n            },\n         }\n    ]\n}\n\n\nThe entirety of the request is probably much longer (depending on how many\nissues you have). Notice how JIRA will only return a maximum of 50 results\nunless otherwise specified (this is one of the parameters they accept). Feel\nfree to check out JIRA's API documentation to see what else you can do, but be\nwarned: their docs kind of suck.\n\nRetrieving information is cool, but modifying it is even better. Here's a use\ncase which might be immediately useful: creating a user.\n\nPOST Requests\nIn addition to the arguments GET requests can receive, POST requests can also\naccept arguments like as data.  This is where we tell the API the specifics of\nwhat we're trying to do.\n\nCommon POST Arguments\n * url: Endpoint URL.\n * params  (optional): Dictionary of variables to be passed as parameters of a\n   query string.\n * body  (optional): A JSON or  ML object sent in the body of the Request.\n * headers  (optional):  Dictionary of HTTP Headers to send with the Request.\n * auth  (optional):  Auth to enable Basic/Digest/Custom HTTP Auth.\n\nLet There be Users\nThe main difference between this request and the last will be what we pass via\nthe data  argument. For example's sake we'll be creating a user named bro  with\nthe appropriate broiest details.\n\nTake special note of json.dumps(userdata). If an endpoint is expecting JSON (it\nprobably is) we need to explicitly convert our dictionary of values to JSON\nbefore making this request.\n\nimport requests\nimport json\nfrom creds import username\nfrom creds import password\n\nbase_url = \"https://examplejira.com/rest/api/2/\"\nheaders = {'Content-Type': 'application/json'}\nuserdata = {\n  'username': 'bro',\n  'name': 'Bro',\n  'password': '32456456',\n  'email': 'bro@broiest.com',\n  \"notification\" : \"true\"\n}\n\nreq = requests.post(base_url + 'user/', data=json.dumps(userdata), headers=headers, auth=(username, password))\n\nprint(req.content)\n\n\n\nYou just created a user. That's basically like giving birth to a child.\nCongratulations.\n\nAdvanced POST Requests\nAs fun as it is to create bro users in JIRA instances, one-off usage of APIs\nlike this isn't really useful. We haven't done anything that we couldn't have\njust done ourselves via the UI.\n\nTo spice things up, here's a very real use case: importing a list of users via a\nCSV. As we speak, people in corporations around the world are manually adding\nthousands of users by hand to internal SaaS products. Don't be that person.\n\nThis request will do the following:\n\n * Use pandas  to open users.csv   (presumably this CSV should have columns for\n   name, email, etc)\n * Generate a random password using secrets\n * Use the CSV to create accounts with each user's information\n * Output the result to users_created.csv\n * \n\n# JIRA User Import\n\nimport pandas as pd\nimport requests\nimport secrets\nimport json\n\n# store credentials\nfrom creds import username\nfrom creds import password\n\n# dataframe from csv\nuser_df = pd.read_csv('users.csv')\n\n# store results of import\nrows_list = []\n\nheaders = {'Content-Type': 'application/json'}\nbase_url = \"https://examplejira.com/rest/api/2/\"\n\n# generate 20-character password\ndef generate_password():\n    alphabet = string.ascii_letters + string.digits\n    password = ''.join(secrets.choice(alphabet) for i in range(20))\n    return password\n\n# iterate and create users\nfor index, row in user_df.iterrows():\n    userdata = {\n        \"name\": row['email'].split('@')[0],\n        \"password\": generate_password(),\n        \"emailAddress\": row['email'],\n        \"displayName\": row['name'],\n        \"notification\" : \"true\"\n    }\n    req = requests.post(base_url + 'user/', data=json.dumps(userdata), headers=headers, auth=(jirauser, password))\n    rows_list.append(userdata) # adds row to array to be tracked\n    # create & export results to a csv\n    users_imported_df = pd.DataFrame(rows_list)\n    users_imported_df.to_csv('users_created.csv')\n\n\n\nIf this worked for you, take a moment to put something in perspective: you just\nautomated somebody's entire 9-5 job in a few minutes.\n\nAlso feel free to reflect on our purpose as a species. If automating this was so\nstraightforward, why do so many of us choose not to automate more tasks? Is our\nentire economy a hoax created to grant the masses an illusion of free will? Are\nwe running around in circles trying to solve problems we create ourselves, to\npay the bills which come with being employed? Finally: if robots are clearly\nthis superior, is there a purpose for the human race at all?\n\nNow you're asking the real questions. Hail Megatron.","html":"<p><a href=\"https://hackersandslackers.com/making-ajax-calls-with-jquery/\">Last episode</a> we covered every programming noob's favorite 'A-ha' moment: making GET requests using AJAX. Stepping stones such as these can serve as great turning points in a career, but they also expose how little we still know. For instance, when we integrated the functional logic of APIs on the client side, we actually broke a cardinal rule: storing and passing private keys on the client side like an idiot. Does that make everything we learned useless? Not entirely, but kinda yeah.</p><p>Today we'll do the equivalent in Python by using the <em>requests</em> library. Requests is successor to Urllib, both of which are simple tools to retrieve or modify information on the web, most commonly in the case of APIs.</p><p>We'll be using JIRA's API as an example of how to format GET and POST requests. JIRA's API in particular is an excellent example of a powerful and useful API. There's a ton we can do, thus a perfect demonstration of how much power one library can give you.</p><h2 id=\"batteries-not-included\">Batteries Not Included</h2><p>Even I sometimes forget that requests is not a built-in Python library. Make sure <strong>requests</strong> is installed in your environment via <code>pip install requests</code>.</p><p>Create a file in your directory called <code>creds.py</code> to store your credentials. Make sure to add that file to your <code>.gitignore</code> if you plan on committing anything any time soon.</p><pre><code class=\"language-python\"># creds.py\nusername = fake.user\npassword = securepassword123\n</code></pre>\n<p>The only libraries we need to import are <code>requests</code> and <code>json</code>. Make sure you import your credentials from the file you created earlier.</p><pre><code class=\"language-python\">import requests\nimport json\nfrom creds import username, password\n</code></pre>\n<h2 id=\"get-requests\">GET Requests</h2><p>As long as you have a URL, you can make a GET request. The requests library will return the content of any page it hits; if you make a request to an HTML page, your response will be that page's HTML source.</p><p>When we know what sort of data we're expecting to receive back, we can specify the expected <em>content type</em> by passing the <em>headers</em> argument, and specifying the <em>Content-Type</em>. Authentication is handled via passing arguments as well, specifically the <em>auth</em> argument. Take a look at what you can pass in a GET request:</p><h3 id=\"common-get-arguments\">Common GET Arguments</h3><ul><li><strong>url:</strong> The URL we will either retrieve or pass the information along to.</li><li><strong>parameters</strong> (optional):  Depending on the API, some URLs can accept a dictionary of variables to be passed along with the URL. These are called query strings; you notice these all the time whenever you come across a URL that looks like nonsense... that nonsense is information!</li><li><strong>headers</strong> (optional): A collection of metadata sent along with the request. Our browsers send HTTP headers every time we visit a site, but the scope of what a header value might cover ranges from tokens to content types.</li><li><strong>auth</strong> (optional):  Method for logging in if needed. Basic/Digest/Custom HTTP Auth.</li></ul><h3 id=\"let-s-get-some\">Let’s GET Some</h3><p>We're going to make a relatively simple request to pull open tickets from a JIRA project called <em>EXM.</em></p><p>This request will:</p><ul><li>Accept our destination's base URL</li><li>Append 'search/' (the endpoint for searching issues)</li><li>Pass two parameters:  A query to return issues A flag to show the issue history</li><li>Authenticate with our username/password</li><li>Print the result</li></ul><pre><code class=\"language-python\">import requests\nimport json\nfrom creds import username\nfrom creds import password\n\nbase_url = 'https://examplejira.com/rest/api/2/'\nheaders = {'Content-Type': 'application/json'}\nparams = {\n    'jql': 'project = EXM AND resolution is not EMPTY',\n    'expand': 'changelog',\n}\n\nreq = requests.get(base_url + 'search/', headers=headers, params=params, auth=(username, password))\n\nprint(req.content)\n</code></pre>\n<p>Notice that setting a variable equal to the request will equal the result of that request. Printing <code>r</code> alone would return a numerical status code (200, 404, etc). The response that comes back from request such as <code>r</code> are actually complex objects — printing <code>r.json()</code> will display the contents of the response as a JSON object. Alternatively, <code>r.text</code> returns the raw response as a string.</p><p>If your response comes back with an error, remember that you can always debug your requests via <a href=\"https://www.getpostman.com/\" rel=\"noopener\">Postman</a>.</p><p>If all went well with our request, <code>r.json()</code> should return something similar to the following:</p><pre><code class=\"language-json\">{  \n   &quot;expand&quot;:&quot;schema,names&quot;,\n   &quot;startAt&quot;:0,\n   &quot;maxResults&quot;:50,\n   &quot;total&quot;:63,\n   &quot;issues&quot;:[  \n      {  \n         &quot;expand&quot;:&quot;operations,versionedRepresentations,editmeta,changelog,renderedFields&quot;,\n         &quot;id&quot;:&quot;10558&quot;,\n         &quot;self&quot;:&quot;https://hackersandslackers.atlassian.net/rest/api/2/issue/10558&quot;,\n         &quot;key&quot;:&quot;HSB-63&quot;,\n         &quot;fields&quot;:{  \n            &quot;issuetype&quot;:{  \n               &quot;self&quot;:&quot;https://hackersandslackers.atlassian.net/rest/api/2/issuetype/10007&quot;,\n               &quot;id&quot;:&quot;10007&quot;,\n               &quot;description&quot;:&quot;Non-development related content task&quot;,\n               &quot;iconUrl&quot;:&quot;https://hackersandslackers.atlassian.net/secure/viewavatar?size=xsmall&amp;avatarId=10306&amp;avatarType=issuetype&quot;,\n               &quot;name&quot;:&quot;Content&quot;,\n               &quot;subtask&quot;:false,\n               &quot;avatarId&quot;:10306\n            },\n         }\n    ]\n}\n</code></pre>\n<p>The entirety of the request is probably much longer (depending on how many issues you have). Notice how JIRA will only return a maximum of 50 results unless otherwise specified (this is one of the parameters they accept). Feel free to check out JIRA's API documentation to see what else you can do, but be warned: their docs kind of suck.</p><p>Retrieving information is cool, but modifying it is even better. Here's a use case which might be immediately useful: creating a user.</p><h2 id=\"post-requests\">POST Requests</h2><p>In addition to the arguments GET requests can receive, POST requests can also accept arguments like as <em>data.</em> This is where we tell the API the specifics of what we're trying to do.</p><h3 id=\"common-post-arguments\">Common POST Arguments</h3><ul><li><strong>url</strong>: Endpoint URL.</li><li><strong>params</strong> (optional): Dictionary of variables to be passed as parameters of a query string.</li><li><strong>body</strong> (optional): A JSON or  ML object sent in the body of the Request.</li><li><strong>headers</strong> (optional):  Dictionary of HTTP Headers to send with the Request.</li><li><strong>auth</strong> (optional):  Auth to enable Basic/Digest/Custom HTTP Auth.</li></ul><h3 id=\"let-there-be-users\">Let There be Users</h3><p>The main difference between this request and the last will be what we pass via the <em>data</em> argument. For example's sake we'll be creating a user named <em>bro</em> with the appropriate broiest details.</p><p>Take special note of <code>json.dumps(userdata)</code>. If an endpoint is expecting JSON (it probably is) we need to explicitly convert our dictionary of values to JSON before making this request.</p><pre><code class=\"language-python\">import requests\nimport json\nfrom creds import username\nfrom creds import password\n\nbase_url = &quot;https://examplejira.com/rest/api/2/&quot;\nheaders = {'Content-Type': 'application/json'}\nuserdata = {\n  'username': 'bro',\n  'name': 'Bro',\n  'password': '32456456',\n  'email': 'bro@broiest.com',\n  &quot;notification&quot; : &quot;true&quot;\n}\n\nreq = requests.post(base_url + 'user/', data=json.dumps(userdata), headers=headers, auth=(username, password))\n\nprint(req.content)\n\n</code></pre>\n<p>You just created a user. That's basically like giving birth to a child. Congratulations.</p><h2 id=\"advanced-post-requests\">Advanced POST Requests</h2><p>As fun as it is to create bro users in JIRA instances, one-off usage of APIs like this isn't really useful. We haven't done anything that we couldn't have just done ourselves via the UI.</p><p>To spice things up, here's a very real use case: importing a list of users via a CSV. As we speak, people in corporations around the world are manually adding thousands of users by hand to internal SaaS products. Don't be that person.</p><p>This request will do the following:</p><ul><li>Use <strong>pandas</strong> to open <em>users.csv</em>  (presumably this CSV should have columns for name, email, etc)  </li><li>Generate a random password using <strong>secrets</strong></li><li>Use the CSV to create accounts with each user's information</li><li>Output the result to <em>users_created.csv</em></li><li></li></ul><pre><code class=\"language-python\"># JIRA User Import\n\nimport pandas as pd\nimport requests\nimport secrets\nimport json\n\n# store credentials\nfrom creds import username\nfrom creds import password\n\n# dataframe from csv\nuser_df = pd.read_csv('users.csv')\n\n# store results of import\nrows_list = []\n\nheaders = {'Content-Type': 'application/json'}\nbase_url = &quot;https://examplejira.com/rest/api/2/&quot;\n\n# generate 20-character password\ndef generate_password():\n    alphabet = string.ascii_letters + string.digits\n    password = ''.join(secrets.choice(alphabet) for i in range(20))\n    return password\n\n# iterate and create users\nfor index, row in user_df.iterrows():\n    userdata = {\n        &quot;name&quot;: row['email'].split('@')[0],\n        &quot;password&quot;: generate_password(),\n        &quot;emailAddress&quot;: row['email'],\n        &quot;displayName&quot;: row['name'],\n        &quot;notification&quot; : &quot;true&quot;\n    }\n    req = requests.post(base_url + 'user/', data=json.dumps(userdata), headers=headers, auth=(jirauser, password))\n    rows_list.append(userdata) # adds row to array to be tracked\n    # create &amp; export results to a csv\n    users_imported_df = pd.DataFrame(rows_list)\n    users_imported_df.to_csv('users_created.csv')\n\n</code></pre>\n<p>If this worked for you, take a moment to put something in perspective: you just automated somebody's entire 9-5 job in a few minutes.</p><p>Also feel free to reflect on our purpose as a species. If automating this was so straightforward, why do so many of us choose not to automate more tasks? Is our entire economy a hoax created to grant the masses an illusion of free will? Are we running around in circles trying to solve problems we create ourselves, to pay the bills which come with being employed? Finally: if robots are clearly this superior, is there a purpose for the human race at all?</p><p>Now you're asking the real questions. Hail Megatron.</p>","url":"https://hackersandslackers.com/pythons-requests-library/","uuid":"9ee37ee8-83d1-452a-acb4-b90b96cf6725","page":false,"codeinjection_foot":"","codeinjection_head":"","comment_id":"5ae8ec83ed09bd1cb7110e65"}}]}},"pageContext":{"slug":"atlassian","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}